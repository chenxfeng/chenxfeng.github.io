<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="并行计算," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="(并行与分布式计算一)
基础知识设计分布式并行算法基本流程1.1发现计算问题的内在并行性
1.2设计与硬件无关的并行算法">
<meta property="og:type" content="article">
<meta property="og:title" content="并行计算基础知识及基本并行算法">
<meta property="og:url" content="https://chenfeng.github.io/2017/02/28/parellel_and_distributed_computing/paralell_compute1&2/index.html">
<meta property="og:site_name" content="chenxfeng's blog">
<meta property="og:description" content="(并行与分布式计算一)
基础知识设计分布式并行算法基本流程1.1发现计算问题的内在并行性
1.2设计与硬件无关的并行算法">
<meta property="og:image" content="https://chenfeng.github.io/img/prefix_sum_balance_tree.png">
<meta property="og:image" content="https://chenfeng.github.io/img/nonrecursive_prefix_sum.png">
<meta property="og:image" content="https://chenfeng.github.io/img/tree_root_pointer_jumping.png">
<meta property="og:updated_time" content="2017-04-03T08:27:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并行计算基础知识及基本并行算法">
<meta name="twitter:description" content="(并行与分布式计算一)
基础知识设计分布式并行算法基本流程1.1发现计算问题的内在并行性
1.2设计与硬件无关的并行算法">
<meta name="twitter:image" content="https://chenfeng.github.io/img/prefix_sum_balance_tree.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chenfeng.github.io/2017/02/28/parellel_and_distributed_computing/paralell_compute1&2/"/>





  <title>并行计算基础知识及基本并行算法 | chenxfeng's blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chenxfeng's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/02/28/parellel_and_distributed_computing/paralell_compute1&2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">并行计算基础知识及基本并行算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T00:00:00+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>(并行与分布式计算一)</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="设计分布式并行算法基本流程"><a href="#设计分布式并行算法基本流程" class="headerlink" title="设计分布式并行算法基本流程"></a>设计分布式并行算法基本流程</h3><p>1.1发现计算问题的<strong>内在并行性</strong></p>
<p>1.2设计<strong>与硬件无关</strong>的并行算法</p>
<a id="more"></a>
<ul>
<li><p>让算法设计者专注于挖掘问题相关的内在并行性而不是被繁琐的硬件特性所干扰</p>
</li>
<li><p>便于不同硬件环境下的开发者移植算法</p>
</li>
<li><p>便于算法到硬件的映射的自动匹配和优化</p>
</li>
<li><p>为并行和分布式计算的系统库(中间件)研发提供一套高层语义抽象</p>
</li>
</ul>
<p>PRAM(Parallel Random Access Machine, 随机存取并行机器): 一个简单的并行算法模型</p>
<ul>
<li><p>Parallel: 可以自由分布任意个处理器并行地读、写和计算</p>
</li>
<li><p>Random Access: 处理器可以按下面其中一条规则自由地访问“共享内存”</p>
</li>
</ul>
<ol>
<li><p>规则一: Exclusive Read Exclusive Write(EREW)(不允许同时读和同时写)</p>
</li>
<li><p>规则二: Concurrent Read Exclusive Write(CREW)(允许同时读但不允许同时写)</p>
</li>
<li><p>规则三: Concurrent Read Concurrent Write(CRCW)(允许同时读和同时写)</p>
</li>
</ol>
<ul>
<li>算法复杂度框架: work(计算量(operation)), time(计算时间)</li>
</ul>
<p>2.1发现硬件的<strong>网络拓扑和处理能力</strong></p>
<p>网络拓扑: </p>
<ul>
<li>静态: 环、星、树、超立方、图</li>
<li>动态: 互联网或移动网络中的分布式计算</li>
</ul>
<p>处理能力: </p>
<ul>
<li>指标: 处理速度和处理规模</li>
<li>结构: 同构、异构</li>
<li>方式: 内存计算还是内外存混合计算，计算密集型还是数据密集型</li>
</ul>
<p>发现网络拓扑的算法: </p>
<ul>
<li>目的一: 建立数据通信的路由</li>
<li>目的二: 死锁检测和解除</li>
<li>目的三: 优化数据传播和交换</li>
</ul>
<p>发现处理能力的方法: </p>
<ul>
<li>测试程序</li>
<li>人工检测</li>
</ul>
<p>2.2设计<strong>与计算问题无关</strong>的分布式计算协议</p>
<p>(所需计算协议包括以下但不止)</p>
<ul>
<li><p>广播、多播和数据收集</p>
</li>
<li><p>同步和异步控制</p>
</li>
<li><p>终止检测和全局谓词(条件)检测</p>
</li>
<li><p>快照保存与检查点恢复</p>
</li>
</ul>
<p>3.把并行算法<em>映射</em>到硬件上，匹配、优化</p>
<p>匹配: </p>
<ul>
<li>与硬件相关的具体并行算法</li>
<li>数据分划和任务指派方案(静态或动态)</li>
<li>并行和分布式计算的程序</li>
</ul>
<p>优化: </p>
<ul>
<li>面向硬件体系结构的算法复杂度分析</li>
<li>针对硬件特性的算法改进和程序调优</li>
</ul>
<h2 id="并行计算的基本方法"><a href="#并行计算的基本方法" class="headerlink" title="并行计算的基本方法"></a>并行计算的基本方法</h2><h3 id="平衡树方法-Balanced-Trees"><a href="#平衡树方法-Balanced-Trees" class="headerlink" title="平衡树方法(Balanced Trees)"></a>平衡树方法(Balanced Trees)</h3><ul>
<li>例: 设<em>是满足结合律的二元运算符，考虑计算<br>$$ S_i = x_1 </em> x_2 <em> … </em> x_i, 1 \leq i \leq n $$</li>
</ul>
<p>Algorithm 2.1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># Prefix Sums</div><div class="line"></div><div class="line">Input: An <span class="built_in">array</span> of n = <span class="number">2</span>^k elements (x_1, x_2, ..., x_n), where k is a nonnegative integer.</div><div class="line"></div><div class="line">Output: The prefix sums s_i, <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= n.</div><div class="line"></div><div class="line">begin</div><div class="line"><span class="number">1.</span> <span class="keyword">if</span> n = <span class="number">1</span> then &#123;<span class="built_in">set</span> s_1 := x_1; <span class="built_in">exit</span>&#125;</div><div class="line"><span class="number">2.</span> <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= n/<span class="number">2</span> pardo</div><div class="line">    <span class="built_in">set</span> y_i := x_2i<span class="number">-1</span> * x_2i</div><div class="line"><span class="number">3.</span> Recursively, compute the prefix sums of &#123;y_1, y_2, ..., y_n&#125;, and store them in z_1, z_2, ..., z_n/<span class="number">2</span></div><div class="line"><span class="number">4.</span> <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= n pardo</div><div class="line">    &#123;i even     :  <span class="built_in">set</span> s_i := z_i/<span class="number">2</span></div><div class="line">     i = <span class="number">1</span>      :  <span class="built_in">set</span> s_1 := x_1</div><div class="line">     i odd &gt; <span class="number">1</span>  :  <span class="built_in">set</span> s_i := z_(i<span class="number">-1</span>)/<span class="number">2</span> * x_i&#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<ul>
<li>复杂度分析<br>$$ T(n) = T(\frac{n}{2}) + a  $$<br>$$ W(n) = W(\frac{n}{2}) + bn $$<br>求解递归方程<br>$$ T(n) = O(logn) $$<br>$$ W(n) = O(n) $$</li>
</ul>
<blockquote>
<p><img src="/img/prefix_sum_balance_tree.png" alt="prefix_sum_balance_tree.png"></p>
</blockquote>
<p>Algorithm 2.2<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># Nonrecursive Prefix Sums</div><div class="line"></div><div class="line">Input: An <span class="built_in">array</span> A of size n = <span class="number">2</span>^k, where k is a nonnegative integer.</div><div class="line"></div><div class="line">Output: An <span class="built_in">array</span> C such that C(<span class="number">0</span>, j) is the jth prefix sum, <span class="keyword">for</span> <span class="number">1</span> &lt;= j &lt;= n</div><div class="line"></div><div class="line">begin</div><div class="line"><span class="number">1.</span> <span class="keyword">for</span> <span class="number">1</span> &lt;= j &lt;= n pardo</div><div class="line">    <span class="built_in">set</span> B(<span class="number">0</span>, j) := A(j)</div><div class="line"><span class="number">2.</span> <span class="keyword">for</span> h = <span class="number">1</span> to logn <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= j &lt;= n/<span class="number">2</span>^h pardo</div><div class="line">        <span class="built_in">set</span> B(h, j) := B(h - <span class="number">1</span>, <span class="number">2</span>j - <span class="number">1</span>) * B(h - <span class="number">1</span>, <span class="number">2</span>j)</div><div class="line"><span class="number">3.</span> <span class="keyword">for</span> h = logn to <span class="number">0</span> <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= j &lt;= n/<span class="number">2</span>^h pardo</div><div class="line">        &#123;j even    : <span class="built_in">set</span> C(h, j) := C(h + <span class="number">1</span>, j/<span class="number">2</span>)</div><div class="line">         j = <span class="number">1</span>     : <span class="built_in">set</span> C(h, <span class="number">1</span>) := B(h, <span class="number">1</span>)</div><div class="line">         j odd &gt; <span class="number">1</span> : <span class="built_in">set</span> C(h, j) := C(h + <span class="number">1</span>, (j - <span class="number">1</span>)/<span class="number">2</span>)*B(h, j)&#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<blockquote>
<p><img src="/img/nonrecursive_prefix_sum.png" alt="nonrecursive_prefix_sum.png"></p>
</blockquote>
<h3 id="指针跳转法-Pointer-Jumping"><a href="#指针跳转法-Pointer-Jumping" class="headerlink" title="指针跳转法(Pointer Jumping)"></a>指针跳转法(Pointer Jumping)</h3><ul>
<li>例一: 存储在数组中的链表求序</li>
</ul>
<ul>
<li>串行算法: 线性复杂度</li>
<li>并行复杂度: T = O(logn), W = O(nlogn)</li>
</ul>
<ul>
<li>例二: 为森林里的每个节点找所在的那棵树的根节点</li>
</ul>
<blockquote>
<p><img src="/img/tree_root_pointer_jumping.png" alt="tree_root_pointer_jumping.png"></p>
</blockquote>
<p>Algorithm 2.4<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Pointer Jumping</div><div class="line"></div><div class="line">Input: A forest of rooted directed trees, each with a self-loop at its root, such that each arc is specified by (i, P(i)), where 1 &lt;= i &lt;= n.</div><div class="line"></div><div class="line">Output: For each vertex i, the root S(i) of the tree containing i.</div><div class="line"></div><div class="line">begin</div><div class="line">1. for 1 &lt;= i &lt;= n pardo</div><div class="line">    set S(i) := P(i)</div><div class="line">    while (S(i)) != S(S(i)) do</div><div class="line">        set S(i) := S(S(i))</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>T = O(logh); W = O(nlogh)</p>
<p>Algorithm 2.5<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Parallel Prefix on Rooted Directed Trees</div><div class="line"></div><div class="line">Input: A forest of rooted directed trees, each with a self-loop at its root such that (1)each arc is specified by (i, P(i)), (2)each vertex i has a weight W(i), and (3)for each root r, W(r) = 0</div><div class="line"></div><div class="line">Output: For each vertex i, W(i) is set equal to the sum of the weights of vertices on the path from i to the root of its tree.</div><div class="line"></div><div class="line">begin</div><div class="line">1. for 1 &lt;= i &lt;= n pardo</div><div class="line">    set S(i) := P(i)</div><div class="line">    while (S(i)) != S(S(i)) do</div><div class="line">        set W(i) := W(i) + W(S(i))</div><div class="line">        set S(i) := S(S(i))</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>T = O(logn); W = O(nlogn)</p>
<h3 id="分而治之法-Divide-and-Conquer"><a href="#分而治之法-Divide-and-Conquer" class="headerlink" title="分而治之法(Divide and Conquer)"></a>分而治之法(Divide and Conquer)</h3><p>例: 找二维平面上的点的凸包(planar convex hull)</p>
<ul>
<li>分: 把这些顶点按由左到右平均分成两组</li>
<li>治: 在这两组内分别求凸包(求解两个规模相对较小的问题，递归)</li>
<li>合: 把两组凸包用快速算法合为一个</li>
</ul>
<p>Algorithm 2.6<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Simple Upper Hull</div><div class="line"></div><div class="line">Input: A set S of n points in the plane, no two of which have the same x or y coordinates such that x(p_1) &lt; x(p_2) &lt; ... &lt; x(p_n), where n is a power of 2.</div><div class="line"></div><div class="line">Output: The upper hull of S.</div><div class="line"></div><div class="line">begin</div><div class="line">1. If n &lt;= 4, then use a brute-force method to determine UH(S), and exit.</div><div class="line">2. Let S_1 = (p_1, p_2, ..., P_n/2) and S_2 = (p_n/2+1, ..., p_n). Recursively, compute UH(S_1) and UH(S_2) in parallel.</div><div class="line">3. find the upper common tangent between UH(S_1) nad UH(S_2), and deduce the upper hull of S.</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>$$ T(n) \leq T(\frac{n}{2}) + alogn $$<br>$$ W(n) \leq 2W(\frac{n}{2} + bn) $$<br>并行复杂度: $ T = O(log^2 n); W = O(nlogn) $</p>
<h3 id="数据划分法-partition-strategy"><a href="#数据划分法-partition-strategy" class="headerlink" title="数据划分法(partition strategy)"></a>数据划分法(partition strategy)</h3><ul>
<li>例: 归并排序</li>
</ul>
<ul>
<li>1.数据均分为若干等分</li>
<li>2.在每一等分内用其它方法排序</li>
<li>3.平衡树快速并行合并这些等分</li>
</ul>
<p>Algorithm 2.7<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># Partition</div><div class="line"></div><div class="line">Input: Two arrays A = (a_1, a_2, ..., a_n) and B = (b_1, b_2, ..., b_m) in increasing order, where both logm and k(m) = m/logm are integers.</div><div class="line"></div><div class="line">Output: k(m) pairs (A_i, B_i) of subsequences of A and B such that (<span class="number">1</span>)|B_i| = <span class="built_in">log</span> m, (<span class="number">2</span>)\sum |A_i| = n, and (<span class="number">3</span>)each element of A_i and B_i is larger than each element of A_i<span class="number">-1</span> or B_i<span class="number">-1</span>, <span class="keyword">for</span> all <span class="number">1</span> &lt;= i &lt;= k(m)<span class="number">-1</span></div><div class="line"></div><div class="line">begin</div><div class="line"><span class="number">1.</span> <span class="built_in">set</span> j(<span class="number">0</span>) := <span class="number">0</span>, j(k(m)) := n</div><div class="line"><span class="number">2.</span> <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= k(m) - <span class="number">1</span> pardo</div><div class="line">    <span class="number">2.1</span>. Rank b_ilogm in A <span class="keyword">using</span> binary search method, and let j(i) = rank(b_ilogm : A)</div><div class="line"><span class="number">3.</span> <span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt;= k(m) - <span class="number">1</span> pardo</div><div class="line">    <span class="number">3.1</span>. <span class="built_in">set</span> B_i := (b_ilogm+<span class="number">1</span>, ..., b_(i+<span class="number">1</span>)logm)</div><div class="line">    <span class="number">3.2</span>. <span class="built_in">set</span> A_i := (a_j(i) + <span class="number">1</span>, ..., a_j(i+<span class="number">1</span>))</div><div class="line">        (A_i is empty <span class="keyword">if</span> j(i) = j(i+<span class="number">1</span>))</div><div class="line">end</div></pre></td></tr></table></figure></p>
<ul>
<li>合并后的序 = 自序 + 交叉序</li>
<li>自序(a_i) = {a_0, a_1, …, a_n-1}中有多少a_j 排在a_i前面(在这里即i)</li>
<li>交叉序(a_i) = {b_0, b_1, …, b_n-1}中有多少b_j排在a_i前面</li>
</ul>
<p>并行复杂度: T = O(logn); W = O(n)</p>
<h3 id="流水线方法-Pipelining"><a href="#流水线方法-Pipelining" class="headerlink" title="流水线方法(Pipelining)"></a>流水线方法(Pipelining)</h3><ul>
<li>例: 2-3树的数据插入</li>
</ul>
<ul>
<li>批量插入多个点及其并行复杂度<br>T = O(logn); W = O(klogn)</li>
</ul>
<ul>
<li>breaking up a task into a sequence of subtask t_1, t_2, …, t_m<br>……</li>
</ul>
<h3 id="加速层叠法-Accelerated-Cascading"><a href="#加速层叠法-Accelerated-Cascading" class="headerlink" title="加速层叠法(Accelerated Cascading)"></a>加速层叠法(Accelerated Cascading)</h3><ul>
<li>例: 数组找最大值</li>
</ul>
<p>常数的并行时间复杂度</p>
<p>Algorithm 2.8<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Basic Maximum</div><div class="line"></div><div class="line">Input: An array A of p distinct elements.</div><div class="line"></div><div class="line">Output: A Boolean array M such that M(i) = 1 if and only if A(i) is the maximum element of A.</div><div class="line"></div><div class="line">begin</div><div class="line">1. for 1 &lt;= i, j &lt;= p pardo if (A(i) &gt;= A(j)) then set B(i, j) := 1</div><div class="line">                                              else set B(i, j) := 0</div><div class="line">2. for 1 &lt;= i &lt;= p pardo</div><div class="line">    set M(i) := B(i, 1) &amp; B(i, 2) &amp; ... B(i, p)</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>$ T = O(1); W = O(p^2) $</p>
<p>双层log深度树(doubly logarithmic-depth tree): 最底层节点数 为 n，根节点的孩子节点数 为 $n^{\frac{1}{2}}$，下一层每个节点的孩子节点数 $n^{\frac{1}{2^2}}$，…</p>
<ul>
<li><p>假设$n = 2^{2^k}$, 树根有$2^{2^{k-1}}$个孩子, 第一层有$2^{2^{k-2}}$个孩子, …, 第i层有$2^{2^{k-i-1}}$个孩子, …</p>
</li>
<li><p>倒数第二层每个节点有常数个子节点</p>
</li>
<li>向上合并用常数复杂度求最大值方法</li>
<li>整体并行复杂度: $$ T(n) = O(log log n) $$ $$ W(n) = O(n log log n) $$</li>
</ul>
<p>accelerated cascading:</p>
<ol>
<li>start with the optimal algorithm until the size of the problem is reduced to a centain threshold value. 双层log深度树加速</li>
<li>Then, shift to the fast but nonoptimal algorithm. 常数时间算法层叠</li>
</ol>
<h3 id="对称破坏法-Symmetry-Breaking"><a href="#对称破坏法-Symmetry-Breaking" class="headerlink" title="对称破坏法(Symmetry Breaking)"></a>对称破坏法(Symmetry Breaking)</h3><ul>
<li>例: 环的三色着色问题</li>
</ul>
<ul>
<li>要求: 相邻的点不能是相同的颜色</li>
<li>串行算法: 在环上随机选一点把环打开得到一个队列；从队首开始除队尾外以0，1相间着色，队尾着色为2(确保队尾和队首、对中倒数第二节点的颜色都不同)</li>
<li>并行算法大致思想: 从以节点编号为颜色的着色方案开始，通过迭代算法，逐步减少着色数量</li>
</ul>
<p>Algorithm 2.9<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Basic Coloring</div><div class="line"></div><div class="line">Input: A directed cycle whose arcs are specified by an <span class="built_in">array</span> S of size n and a coloring c of the vertices.</div><div class="line"></div><div class="line">Output: Another coloring c' of the verteces of the cycle.</div><div class="line"></div><div class="line">begin</div><div class="line"><span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= n pardo</div><div class="line">    <span class="number">1.</span> <span class="built_in">set</span> k to the least significant bit position in which c(i) and c(S(i)) disagree.</div><div class="line">    <span class="number">2.</span> <span class="built_in">set</span> c'(i) := <span class="number">2</span>k + c(i)_k</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>T = O(1); W = O(n)</p>
<blockquote>
<p>definition: $log^{(1)}x = logx$, and $log^{(i)}x = log(log^{(i-1)}x)$</p>
</blockquote>
<ul>
<li>Fast Coloring<br>反复运用这个算法使得从颜色序号{0, 1, 2}中重新选择颜色给每个顶点着色且相邻顶点色不同, 整体并行复杂度为: $$ T = O(log<em>n); W = O(nlog</em>n) $$</li>
</ul>
<p>Algorithm 2.10<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># <span class="number">3</span>-coloring of a Cycle</div><div class="line"></div><div class="line">Input: A directed cycle of length n whose arcs are specified by an <span class="built_in">array</span> S.</div><div class="line"></div><div class="line">Output: A <span class="number">3</span>-coloring of the vertices of the cycle.</div><div class="line"></div><div class="line">begin</div><div class="line"><span class="number">1.</span> <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= n pardo</div><div class="line">    <span class="built_in">set</span> C(i) := i</div><div class="line"><span class="number">2.</span> Apply Algorithm <span class="number">2.9</span> once.</div><div class="line"><span class="number">3.</span> Sort the vertices by their colors.</div><div class="line"><span class="number">4.</span> <span class="keyword">for</span> i = <span class="number">3</span> to <span class="number">2</span> \ceiling(logn) <span class="keyword">do</span></div><div class="line">    <span class="keyword">for</span> all vertices v of color i pardo</div><div class="line">    color v with the smallest color from &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; that is diffrrent from the colors of its two neighbors.</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>T = O(logn); W = O(n)</p>
<ul>
<li><strong>三色环着色过程</strong></li>
</ul>
<ol>
<li>迭代调用算法2.9，把颜色降至c种以下(c是较小常数，如10等)</li>
<li>遍历从3到c-1种颜色:<br>for(color = 3; color &lt; c; ++color) {<br> 环中结点号i<br> if i的颜色为color pardo<pre><code>根据左右邻居占用3颜色0,1,2中的哪几种，决定结点i可以取得颜色({0,1,2}中的某一个)
</code></pre>}</li>
</ol>
<blockquote>
<p>在1.中，设迭代t的颜色数为$n<em>t$，则$n</em>{t+1} \leqslant 2(\ulcorner log_2n_t \urcorner - 1) + 1$</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并行计算/" rel="tag"># 并行计算</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/28/computer_network/computer_network_1/" rel="next" title="计算机网络和因特网">
                <i class="fa fa-chevron-left"></i> 计算机网络和因特网
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/14/parellel_and_distributed_computing/paralell_compute3/" rel="prev" title="列表和树">
                列表和树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="chenxf" />
          <p class="site-author-name" itemprop="name">chenxf</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">82</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计分布式并行算法基本流程"><span class="nav-number">1.1.</span> <span class="nav-text">设计分布式并行算法基本流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行计算的基本方法"><span class="nav-number">2.</span> <span class="nav-text">并行计算的基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡树方法-Balanced-Trees"><span class="nav-number">2.1.</span> <span class="nav-text">平衡树方法(Balanced Trees)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针跳转法-Pointer-Jumping"><span class="nav-number">2.2.</span> <span class="nav-text">指针跳转法(Pointer Jumping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分而治之法-Divide-and-Conquer"><span class="nav-number">2.3.</span> <span class="nav-text">分而治之法(Divide and Conquer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据划分法-partition-strategy"><span class="nav-number">2.4.</span> <span class="nav-text">数据划分法(partition strategy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线方法-Pipelining"><span class="nav-number">2.5.</span> <span class="nav-text">流水线方法(Pipelining)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加速层叠法-Accelerated-Cascading"><span class="nav-number">2.6.</span> <span class="nav-text">加速层叠法(Accelerated Cascading)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对称破坏法-Symmetry-Breaking"><span class="nav-number">2.7.</span> <span class="nav-text">对称破坏法(Symmetry Breaking)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenxf</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  








  





  

  

  

  
  


  

  

</body>
</html>
