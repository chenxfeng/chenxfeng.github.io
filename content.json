[{"title":"","slug":"paralell_compute3","date":"2017-03-11T11:54:39.719Z","updated":"2017-03-11T11:54:39.719Z","comments":true,"path":"2017/03/11/paralell_compute3/","link":"","permalink":"https://chenfeng.github.io/2017/03/11/paralell_compute3/","excerpt":"","text":"列表排序The list-ranking problem is to determine the distance of each node i from the end of the list 指针跳转法(pointer jumping technique)思想： 链表中的指针跳转可以由一次跳转一步改为一次跳转多步 如果能在O（1）时间内一次跳转k步，那么一次跳转2k步只需要双倍时间 如果为每个节点，把一次跳转2k步的跳转结果记录下来，那么以后一次跳转2k步也只需要O（1）时间 反复利用跳转步数翻倍和跳转结果记录的技巧，可以在O（log N）的时间内把跳转步数扩大为N T = O(logn); W = O(nlogn)并不比串行算法(linear, O(n))更优 Algorithm 3.112345678910111213141516# List Ranking Using Pointer JumpingInput: A linked list of n nodes such that (1)the successor of each node i is given by S(i), and (2)the S value of the last node on the list is euqal to 0.Output: For each 1 &lt;= i &lt;= n, the distance R(i) of node i from the end of the list.begin1. for 1 &lt;= i &lt;= n pardo if (S(i) != 0) then set R(i):= 1 else set R(i):= 02. for 1 &lt;= i &lt;= n pardo set Q(i) := S(i) while (Q(i) ！= 0 and Q(Q(i)) != 0) do set R(i) := R(i) + R(Q(i)) set Q(i) := Q(Q(i))end 优化思路: 用快速并行算法把链表长度缩短为n/log n 要求：缩短和恢复都可以用很小的T，并且W=O(n) 方法：通过删除链表中的独立顶点集来缩短链表 在缩短的链表上用指针跳转法来求序，只需W=O(n) 最后用快速并行算法来恢复链表的长度 也即： 把列表分成约n/logn块{ $B_{i}$ }, 每块包含O(logn)个节点 在每块内对每个节点用最优串行算法求序(preliminary rank) 用O(logn)的平行算法把所有排好序的块组合 List-Ranking Strategy Shrink the linked list L until only O(n/logn) nodes remain. Apply the pointer jumping technique(Algorithm 3.1) on the short list of the remaining nodes. Restore the original list and rank all the nodes removed in step 1. independent sets A set I of nodes is independent if, whenever i belongs to I, S(i) not belongs to I. 缩减的列表结点必须构成一个独立集，即不相邻 Algorithm 3.21234567891011121314# removing nodes of an independent setInput: (1)Arrays S and P of length n representing, respectively, the successor and predecessor relations of linked list; (2)an independent set I of nodes such that P(i), S(i) != 0; (3)a value R(i) for each node i.Output: The list obtained after removal of all the nodes in I with the updated R values.begin1. Assign consecutive serial numbers N(i) to the elements of I, where 1 &lt;= N(i) &lt;= |I| = n'.2. for for all i belongs to I pardo set U(N(i)) := (i, S(i), R(i)) set R(P(i)) := R(P(i) + R(i)) set S(P(i)) := S(i) set P(S(i)) := P(i)end 删除独立顶点集并合并其权重到剩余顶点的并行复杂度: T=O(1) W=O(n) Determination of an Independent Set独立集合充分大：存在常数c，c属于(0, 1)，使集合包含顶点数不少于c×n 保证快速地迭代缩短链表 把长度为n的链表缩短为n/logn只需不超过log_1-c(logn)的T 最理想但没有快速算法：用序的奇偶性确定独立顶点集合，c=1/2 (存在快速算法)对链表使用三色着色算法，把局部最小色数(或最大)的节点作为独立集元素 从一个局部极小到下一个局部极小着色点，中间经过的点数最多为3，因此C=1/4 3-color 算法收敛很快，每次调用算法，着色的色数都变小为原色数的对数比例，这里的对数以2为基底 要把色数变小为3，T几乎是O(1) Algorithm 3.312345678910111213141516# simple optimal list rankingInput: A linked list with n nodes suc that the successor of each node i is given by S(i).Output: For each node i, the distance of i from the end of the list.begin1. set n_0 := n, k := 02. while n_k &gt; n/logn do 2.1 set k := k + 1 2.2 color the list with three colors and identify the set I of local minima. 2.3 remove the nodes in I, and store the appropriate information regarding the removed nodes(Algorithm 3.2). 2.4 let n_k be the size of the remaining list. compact the list into consecutive memory locations.3. apply the pointer jumping technique (Algorithm 3.1) to the resulting list.4. restore the original list and rank all the removed nodes by reversing the process performed in step2.end 缩短链表和恢复链表：T = O(log logn), W = O(n) 把长度为n的链表缩短为n/logn，只需不超过log_1-c(logn)的T 第一次迭代W = O(n), 第二次迭代W = O((1 - c)*c), … W = O(n + (1 - c)n + (1 - c)^2 *n + …) = O(n/c) = O(n) 恢复和缩短是对称的，T和W都相同 指针跳转是在长度为n/logn的已缩短链表上zuo做的，T = O(logn), W = O(n) 算法的并行复杂度: T = O(loglogn); W = (n) *一个优化的时间复杂度为O(logn)的列表求序算法…… 欧拉回路(the Euler-Tour Technique)树的欧拉回路是指：将一棵树的每一条边换成两条指向相反的有向边，成为一个欧拉图，就存在欧拉回路；可以定义一个论域为所有有向边的函数s(successor function)，描述这棵树的欧拉回路 Lemma 3.6: Given a tree T = (V, E) and an ordering of the set of vertices adjacent to each vertex v belongs to V, the function s defined previously specifies an Euler circuit in the directed graph T’ = (V, E’), where E’ is obtained by replacement of each e belongs to E by two arcs of opposite directions. we call the Euler circuit of T’ the Euler tour of T 每棵树都有欧拉回路 如果欧拉回路从树的根节点出发，则它实际上是树的节点深度优先遍历路径 给出一个由邻接表及附加的指针信息描述的树，求得一条欧拉回路的T = O(1), W = O(n), |V| = n(指针信息: data field + pointer * 2(描述下一个邻接点 + 描述该点在邻接表中指向此顶点的item)) 树求根(rooting a tree): 树根结点为r，对于每个非根结点v，寻找其父父结点p(v) 一对顶点之间的两条弧，先出后进的顶点是父节点，先进后出的是子节点 弧的顺序的确定：-把欧拉回路从其中一点处断开（例如去除回路路径列表中的最前与最后的弧的相邻关系） 用链表求序来对这些弧定序 树的一个欧拉回路为L[r] = &lt; u_0, u_1, … , u_d-1 &gt; 设s(&lt; u_d-1, r &gt;) = 0，将欧拉回路从r处截断，得到一条始于r，遍历所有顶点一次，终于r的欧拉路径 Algorithm 3.51234567891011# rooting a treeInput: (1)a tree T defined by the adjacency lists of its vertices, (2)an Euler tour defined by the successor function s, and (3)a special vertex rOutput: For each vertex v != r, the parent p(v) of v in the tree rooted at r.begin1. Identify the last vertex u appearing on the adjacency list of r. set s(&lt;u, r&gt;) = 02. Assign a weight of 1 to each arc &lt;x, y&gt;, and apply parallel prefix on the list of arcs defined by s.3. For each arc &lt;x, y&gt;, set x = p(y) whenever the prefix sum of &lt;x, y&gt; is smaller than the prefix sum of &lt;y, x&gt;.end 并行复杂度与链表求序相同： T=O(log n log log n) ？？？ W=O(n) 这里n是顶点数（树的边数是顶点数减一） 1、Postorder Numbering 后序遍历的序数 往下走的弧的权重为0，往上走的弧的权重为1，然后用链表中求前缀和的方法来算出后序遍历编号 Algorithm 3.61234567891011# Postorder NumberingInput: (1)A rooted binary tree with root r, and (2)the coresponding Euler path defined by the function sOutput: The postorder number post(v) of each vertex vbegin1. For each vertex v != r, assign the weights w(&lt;v, p(v)&gt;) = 1 and w(&lt;p(v&gt;, v) = 02. Perform parallel prefix on the list of arcs defined by s.3. For each vertex v != r, set post(v) equal to the prefix sum of &lt;v, p(v)&gt;. For v = r, set post(v) = n, where n is the number of vertices in the given tree.end 2、Computing the Vertex level 结点层数 可用类似Algorithm 3.6的算法，1和3做改动: w() = +1; w() = -1。level(v) = 的前缀和 3、Computing the preorder Number w(&lt; p(v), v &gt;) = 1; w(&lt; v, p(v) &gt;) = 0; preorder(v) = &lt; p(v), v &gt;前缀和 + 1; preorder(r) = 1 4、Computing the Number of Descendants w(&lt; p(v), v &gt;) = 1; w(&lt; v, p(v) &gt;) = 0; desc(v) = &lt; v, p(v) &gt;前缀和 - &lt; p(v), v &gt;前缀和; desc(r) = n - 1 以上四个并行算法:T = O(logn); W = O(n)（由平衡树方法求前缀和的平行算法所决定） *Tree Contraction(树收缩) …… *Lowest Common Ancestors ……","categories":[],"tags":[]},{"title":"","slug":"computer_network_1","date":"2017-03-10T14:49:29.201Z","updated":"2017-03-10T14:48:17.178Z","comments":true,"path":"2017/03/10/computer_network_1/","link":"","permalink":"https://chenfeng.github.io/2017/03/10/computer_network_1/","excerpt":"","text":"计算机网络和因特网 因特网连接到因特网的设备：主机(host)或端系统(end system) 端系统通过通信链路(communication link)和分组交换机(parket switch)连接到一起 路由器(router) 链路层交换机(link-layer switch) 端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网 因特网部件运行一系列协议(protocol),协议控制因特网中信息的接受和发送 Reliable Stream Transport Service:Sends a large amount of data across a reliable “connection” Connectionless Packet Delivery Service:Routes small messages from one computer to another TCP(Transmission Control Protocol, 传输控制协议) IP(Internet Protocol, 网际协议)定义在路由器和端系统之间发送和接受的分组格式 因特网标准(Internet standard)由因特网工程任务组(Internet Engineering task Force, IETF)研发 IETF标准文档称请求评论(Request For Comment, RFC) 分布式应用程序(distributed application)涉及多台相互交换数据的端系统 应用程序编程接口(Application Programming Interface, API) 网络边缘主机(hosts) = 端系统: 客户(client)和服务器(server) 数据中心(data center)由许多服务器构成 接入网(access network)指将端系统连接到其边缘路由器(edge router)的物理链路 residential access nets institutional access networks (school, company) mobile access networks bandwidth(bit per second, bps); shared / dedicated(专用) 数字用户线(Digital Subscriber Line, DSL): existing telephone line to central office DSLAM &lt; 2.5 Mbps upstream transmission rate (typically &lt; 1 Mbps) &lt; 24 Mbps downstream transmission rate (typically &lt; 10 Mbps) frequency division multiplexing: different channels transmittedin different frequency bands 电缆因特网接入(cable Internet access) 有线电视 HFC: hybrid fiber coax asymmetric: up to 30Mbps downstream transmission rate, 2 Mbps upstream transmission rate 以太网Ethernet 光纤到户(Fiber To The Home, FTTH) 光纤分布体系结构：主动光纤网络(Active Optical Network, AON)和被动光纤网络(Passive Optical Network, PON) 光纤网络端接器(Optical Network Terminator, ONT) 分配器(splitter) 光纤线路端接器(Optical Line Terminator, OLT) wireless network wireless LANs: within building (100 ft.) 802.11b/g/n (WiFi): 11, 54, 450 Mbps transmission rate wide-area wireless access provided by telco (cellular) operator, 10’s km between 1 and 10 Mbps 3G, 4G: LTE host sending function: takes application message breaks into smaller chunks, known as packets, of length L bits transmits packet into access network at transmission rate R link transmission rate, aka link capacity, aka link bandwidth 物理媒体(physical medium): 双绞铜线、同轴电缆、多模光纤缆、陆地无线电频谱、卫星无线电频谱 bit: propagates between transmitter/receiver pairs physical link: what lies between transmitter &amp; receiver 导引型媒体(guided media): signals propagate in solid media: copper, fiber, coax 非导引型媒体(unguided media): signals propagate freely, e.g., radio 双绞铜线 twisted pair (TP): two insulated copper wires Category 5: 100 Mbps, 1 Gbps Ethernet Category 6: 10Gbps 两根隔离的铜线以规则的螺旋形式排列组成；两根线绞合起来以减少邻近类似双绞线的电气干扰 一对电线构成一个通信链路；通常许多双绞线捆扎在一起成电缆 无屏蔽双绞线(Unshielded Twisted Pair, UTP) 常用于建筑物内网络 同轴电缆 coaxial cable: two concentric copper conductors bidirectional broadband: multiple channels on cable HFC 光纤 fiber optic cable: glass fiber carrying light pulses, each pulse a bit high-speed operation:high-speed point-to-point transmission (e.g., 10’s-100’s Gbps transmission rate) low error rate: repeaters spaced far apart immune to electromagnetic noise(不受电磁干扰) 单模光纤速率高，价格贵; 多模光纤速率低，价格便宜 电磁波 ratio signal carried in electromagnetic spectrum no physical “wire” bidirectional propagation environment effects: reflection obstruction by objects interference adio link types: terrestrial microwavee.g. up to 45 Mbps channels LAN (e.g., WiFi)54 Mbps wide-area (e.g., cellular)4G cellular: ~ 10 Mbps satellite Kbps to 45Mbps channel (or multiple smaller channels) 270 msec end-end delay geosynchronous versus low altitude 同步卫星(geostationary satellite); 近地轨道(Low-Earth Orbiting, LEO)卫星 编码(encoding)Non-return to Zero Inverted (NRZI): make a transition from current signal to encode a one; stay at current signal to encode a zero solves the problem of consecutive ones 经网络传输数据会产生时钟同步问题 Manchester: transmit XOR of the NRZ encoded data and the clock only 50% efficient (bit rate = 1/2 baud rate) 包含丰富的时钟信息 4B/5B: every 4 bits of data encoded in a 5-bit code 5-bit codes selected to have no more than one leading 0 and no more than two trailing 0s thus, never get more than three consecutive 0s resulting 5-bit codes are transmitted using NRZI achieves 80% efficiency 数据帧化Framing Break sequence of bits into a frame Typically implemented by network adaptor Sentinel-based: delineate frame with special pattern: 01111110 e.g., HDLC, SDLC, PPP Beginning sequence(8) + Header(16) + Body + CRC(16) + Ending sequence(8) problem: special pattern appears in the payload solution: bit stuffing sender: insert 0 after five consecutive 1s receiver: delete 0 that follows five consecutive 1s Counter-based: include payload length in header e.g., DDCMP SYN(8) + SYN(8) + Class(8) + Count(14) + Header(42) + Body + CRC(16) problem: count field corrupted solution: catch when CRC fails Clock-based: each frame is 125us long e.g., SONET: Synchronous Optical Network STS-n (STS-1 = 51.84 Mbps) 网络核心Communication networks can be classified based on the way in which the nodes exchange information: Communication Network: Broadcast Communication Network Switched Communication Network Circuit-Switched Communication Network Packet-Switched Communication Network Datagram Network Virtual Circuit Network Connection Oriented(面向连接)Has connection establish and release procedures Similar to circuit switched Transmission in order Bandwidth may be guaranteed Flow control may exist Error control may exist Connectionless(无连接)Each datagram may take a different path Datagrams may arrive out of order Link failures not a problem problem in a Generic Switch incoming links : how to demultiplex switch : how to switch outgoing links : how to multiplex Packet Switching(分组交换)各种网络应用中，端系统彼此交换报文(message) 分组(packet swicth): 源端系统像目的端系统发送报文，源将报文划分为较小的数据块 每个分组通过通信链路和分组交换机(packet switch)传送 两类交换机: 路由器和链路层交换机 packet-switching:hosts break application-layer messages into packets Data from any conversation can be transmitted at any given time A single conversation can use the entire link capacity if it is alone How to demultiplex? Use meta-data (header) to describe data Data are sent as formatted bit-sequences so-called packets. Packets have the following structure: Header + Data + Tailer Header and Trailer carry control information e.g., destination address, check sum Store-and-Forward Networks(存储转发传输): At each node the entire packet is received, stored briefly, and then forwarded to the next node based on the header information Allows statistical(统计的) multiplexing 在接收完所有的比特后进行查错，无误在再进行转发 “热土豆”传输: 一边接收，一边转发 适用于网络质量好，出错概率低的情况 通过N条速率均为R的链路组成的路径(源和目的地之间有N-1台路由器)发送一个分组，端到端时延: $$d_{EndToEnd} = N \\frac{L}{R}$$ takes L/R seconds to transmit L-bit packet into link at R bps one-hop numerical example: L = 7.5 Mbits R = 1.5 Mbps one-hop transmission delay = 5 sec packet-switching forward packets from one router to the next across links on path from source to destination Each packet is independently switched header contains destination address Two key network-core functions routing: determines source-destination route taken by packets routing algorithms forwarding: move packets from router’s input to appropriate router output 输出缓存(output buffer)(输出队列 output queue):用于存储路由器准备发往相连的链路的分组; 排队时延(queue delay):到达的分组在链路忙于传输其他分组时必须在输出缓存中等待; 分组丢失(丢包 packet lost):一个分组到达时缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃 queuing and loss: if arrival rate exceeds transmission rate of link for a period of time packets will queue, wait to be transmitted on link can be dropped (lost) if memory (buffer) fills up Circuit Switching(电路交换)两台主机通信时网络在两台主机之间创建一条专用的端到端连接(end-to-end connection) 频分复用(Frequency-Division Multiplexing, FDM):链路的频谱由跨越链路创建的所有连接所共享; 在连接期间链路为每条连接专用一个频段 时分复用(Time-Division Multiplexing, TDM):时间被划分为固定区间的帧(frame)，每帧划分为固定数量的时隙;网络跨越一条链路创建一条连接时在每个帧中为该连接指定一个时隙(slot) Time divided in frames and frames divided in slots Relative slot position inside a frame determines which conversation the data belongs to Needs synchronization(同步) between sender and receiver If a conversation does not use its circuit the capacity is lost Three phases(三个阶段) circuit establishment data transfer circuit termination If circuit not available: busy Examples Telephone networks ISDN (Integrated Services Digital Networks)(综合业务数字网) end-end resources allocated to, reserved for “call” between source &amp; dest dedicated resources: no sharing circuit-like (guaranteed) performance circuit segment idle(闲置) if not used by call (no sharing) Packet-Switching vs. Circuit-SwitchingMost important advantage of packet-switching: Ability to exploit statistical multiplexing More efficient bandwidth usage However, packet-switching needs to buffer and deal with congestion More complex switches Harder to provide good network services (e.g., delay and bandwidth guarantees) packet switching allows more users to use network example: 1 Mb/s linkeach user: 100 kb/s when “active” active 10% of time circuit-switching: 10 users packet switching: with 35 users, probability &gt; 10 active at same time is less than .0004 * packet switching: great for bursty data resource sharing simpler, no call setup excessive congestion possible: packet delay and loss protocols needed for reliable data transfer, congestion control Q: How to provide circuit-like behavior? bandwidth guarantees needed for audio/video apps Virtual-Circuit Packet Switching(虚电路交换)Hybrid of circuit switching and packet switching Data is transmitted as packets All packets from one packet stream are sent along a pre-established path (=virtual circuit) Guarantees in-sequence delivery of packets Packet header only contains local virtual circuit identifier (VCI) Demultiplexing and switching based on VCI Note: packet headers don’t need to contain the full destination address of the packet Example: ATM networks Communication with virtual circuits takes place in three phases VC establishment data transfer VC disconnect Internet structure: network of networks(网络的网络)End systems connect to Internet via access ISPs (Internet Service Providers) residential, company and university ISPs Access ISPs in turn must be interconnected. so that any two hosts can send packets to each other Resulting network of networks is very complex evolution was driven by economics and national policies Question: given millions of access ISPs, how to connect them together?Option: connect each access ISP to every other access ISP?Option: connect each access ISP to one global transit ISP? Customer and provider ISPs have economic agreement. at center: small # of well-connected large networks “tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), national &amp; international coverage content provider network (e.g., Google): private network that connects it data centers to Internet, often bypassing tier-1, regional ISPs 分组交换网中的时延、丢包和吞吐量(delay, loss, throughput in networks)时延结点处理时延(nodal processing delay): 检查分组首部和决定出口链路、查错校验 排队时延(queuing delay): 分组在出口链路队列上等待传输 传输时延(transmission delay): L/R(分组长度/链路传输速率); 将所有分组比特推(传输)向链路所需时间 传播时延(propagation delay): d/s(距离/传播速率)，介质相关 结点总时延(total nodal delay) $$d{nodal} = d{proc} + d{queue} + d{trans} + d_{prop}$$ How do loss and delay occur:packets queue in router buffers packet arrival rate to link (temporarily) exceeds output link capacity packets queue, wait for turn $d_{proc}$: nodal processing check bit errors determine output link typically &lt; msec $d_{queue}$: queueing delay time waiting at output link for transmission depends on congestion level of router $d_{trans}$: transmission delay L: packet length (bits) R: link bandwidth (bps) $d_{trans} = L/R$ $d_{prop}$: propagation delay d: length of physical link s: propagation speed (~2x108 m/sec) $d_{prop} = d/s$ $d{trans}$ and $d{prop}$ are very different 排队时延和丢包流量强度(traffic intensity): La/R; a: 分组到达队列的平均速率(pkt/s)(a: average packet arrival rate) R: link bandwidth (bps) L: packet length (bits) La/R ~ 0: avg. queueing delay small La/R -&gt; 1: avg. queueing delay large La/R &gt; 1: more “work” arriving than can be serviced, average delay infinite! 设计系统时流量强度不能大于1 随着流量强度接近于1，平均排队时延迅速增加 丢包: 分组到达时路由器链路队列已满，路由器丢弃(drop)该分组，该分组会丢失(lost) queue (aka buffer) preceding link in buffer has finite capacity packet arriving to full queue dropped (aka lost) lost packet may be retransmitted by previous node, by source end system, or not at all 吞吐量(throughput)瞬时吞吐量(instantaneous throughput): 主机接收到文件的速率(bps) 平均吞吐量(average throughput): F/T秒; 接收总共F比特用去T秒 瓶颈链路(bottleneck link): 系统中传输速率最小的链路 throughput: rate (bits/time unit) at which bits transferred between sender/receiver instantaneous: rate at given point in time average: rate over longer period of time bottleneck link:link on end-end path that constrains end-end throughput 协议层次 服务模型(protocol layers, service models)分层(layer) layers: each layer implements a service via its own internal-layer actions relying on services provided by layer below 协议栈(protocol stack) 应用层(第七层): 报文(message) 运输层(四层): 报文段(segment) 网络层(三层): 数据报(datagram) 链路层(二层): 帧(frame) 物理层(一层): 将帧中的比特一个一个从一个结点移动到下一个结点 OSI(Open System Interconnect Reference Model, 开放系统互联参考模型) 表示层: 数据压缩、数据加密、数据描述 会话层: 数据交换定界、同步功能，建立检查点和恢复方案 Internet protocol stack: application: supporting network applications FTP, SMTP, HTTP transport: process-process data transfer TCP, UDP network: routing of datagrams from source to destination IP, routing protocols link: data transfer between neighboring network elements Ethernet, 802.111 (WiFi), PPP physical: bits “on the wire ISO/OSI reference model: (two more layer) presentation: allow applications to interpret meaning of data, e.g., encryption, compression, machine-specific conventions session: synchronization, checkpointing, recovery of data exchangeInternet stack “missing” these layers! these services, if needed, must be implemented in application 封装(encaosulation) 应用层报文(application-layer message) -&gt; 运输层报文段(transport-layer segment) -&gt; 网络层数据报(network-layer datagram) -&gt; 链路层帧(link-layer frame) 分组 : 首部字段 + 有效载荷字段(payload field)(来自上一层的分组) 面对攻击的网络(networks under attack: security)Internet not originally designed with (much) security in mind original vision: “a group of mutually trusting users attached to a transparent network”  Internet protocol designers playing “catch-up” security considerations in all layers! 恶意软件(malware) 僵尸网络(botnet) 病毒(virus): 需要某种形式的用户交互感染用户设备的恶意软件 蠕虫(worm): 无需任何明显用户交互就能进入设备的恶意软件 malware can get in host from: virus: self-replicating infection by receiving/executing object (e.g., e-mail attachment) worm: self-replicating infection by passively receiving object that gets itself executed spyware malware can record keystrokes, web sites visited, upload info to collection site infected host can be enrolled in botnet, used for spam. DDoS attacks 拒绝服务攻击(Denial-of-Service (DoS) attack) 弱点攻击: 向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文 带宽洪泛: 向目标主机发送大量的分组使目标接入链路拥塞 连接洪泛: 在目标主机中创建大量半开或全开TCP连接 分布式Dos(Distributed DoS, DDoS): 攻击者控制多个源向目标发送大量流量 Denial of Service(DoS): attackers make resources (server, bandwidth) unavailable to legitimate traffic by overwhelming resource with bogus traffic select target break into hosts around the network (see botnet) send packets to target from compromised hosts 分组嗅探器(packet sniffer) packet “sniffing”: broadcast media (shared Ethernet, wireless) promiscuous network interface reads/records all packets (e.g., including passwords!) passing by wireshark software is a (free) packet-sniffer IP哄骗(IP spooning) IP spoofing: send packet with false source address ~ history","categories":[],"tags":[]},{"title":"","slug":"economics/经济学基础知识","date":"2017-03-08T04:10:41.266Z","updated":"2017-03-08T04:10:41.266Z","comments":true,"path":"2017/03/08/economics/经济学基础知识/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/economics/经济学基础知识/","excerpt":"","text":"经济学基础知识标签： 微观经济学 研究一个社会如何利用稀缺资源生产有价值的物品和劳务并将它们在不同人中间进行分配。 物品和资源是稀缺的 社会必须有效地加以利用 稀缺(sarcity)：相对于需求，物品总是有限的 效率(efficiency)：最有效地使用社会资源以满足人类的愿望和需要 经济学逻辑 后此谬误(the post hoc fallacy)仅仅因为一件事发生在另一件事之前就想当然地认为前者是后者的原因 不能保持其他条件不变(failure to hold other things constant)考虑某一问题是没能保持其他相关条件不变 合成谬误(the fallacy of composition)认为对局部成立的东西对总体也必然成立 经济组织三个经济问题基本经济问题： 生产什么(什么商品和多少)； 如何生产； 为谁生产(谁享用经济活动的成果) 实证经济学(positive economics)：讨论经济社会的事实规范经济学(normative economics)：提出价值判断，涉及伦理信条(应当是什么) 市场经济(market economy):主要由个人和私人企业决定生产和消费的经济制度 极端情况：自由放任(lasse-faire)经济 指令经济(command economy):由政府做出有关生产和分配的所有重大决策 政府通过它的资源所有权和实施经济政策的权力解答基本的经济问题 混合经济(mixed economy):既带有市场经济的成分又带有指令经济的成分 社会的技术可能性 投入和产出投入(inputs):指生产物品和劳务的过程中所使用的物品和劳务 产出(outputs):指生产过程中创造的各种有用的物品和劳务，可用于消费或进一步生产 投入也称生产要素(factors of production)，划分成三大基本范畴 土地(自然资源)，生产过程中大自然所赋予的 劳动，人们花费在生产过程中的时间和精力 资本资源，一个经济体为了生产其他的物品而生产出来的耐用品 生产可能性边界(production-possibility frontier, PPF)表示在技术知识和可投入品数量既定的条件下，一个经济体所能得到的最大产量。 PPF代表可供社会利用的物品和劳务的不同组合。 生产可能性边界说明许多基本的经济过程： 经济增长将边界向外推移(生产潜能的增长) 贫穷的国家必须将其大部分资源用于生产食品；富裕的国家能生产出更多奢侈品 贫穷的国家仅仅能承担很少的公共品；随着经济增长公共品及环境质量占产出量的比重势必加大 通过牺牲现在消费和生产更多的资本品，一国经济能更快速增长使未来有可能生产出更多两种物品 机会成本(opportunity cost)在存在稀缺的社会上，选择一种东西意味着需要放弃其他一些东西；一项选择的机会成本是相应的所放弃的物品和劳务的价值。 效率 有效率的生产(productive efficiency)必然位于生产可能性边界上；经济体无法在不减少一种物品产量的前提下生产出更多的另一种产品。 生产可能性边界表示社会为人们提供的各种选择 未利用资源和无效率 经济体中存在着未利用的资源(失业的劳动者、闲置的工厂、废弃的土地等)时，不可能处于生产可能性边界上，而是处于其边界之内的某个位置。 无资源的根源：商业周期(周期性经济危机)、罢工、政治动乱、革命等。","categories":[],"tags":[]},{"title":"","slug":"economics/现代经济中的市场和政府","date":"2017-03-08T04:10:41.265Z","updated":"2017-03-08T04:10:41.265Z","comments":true,"path":"2017/03/08/economics/现代经济中的市场和政府/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/economics/现代经济中的市场和政府/","excerpt":"","text":"现代经济中的市场和政府标签：微观经济学 什么是市场 市场(market)是买者和卖者相互作用并共同决定商品和劳务的价格和交易数量的机制 在市场中，是价格在协调生产者和消费者的决策。较高的价格趋于抑制消费者购买，同时会刺激生产；而较低的价格则鼓励消费，同时抑制生产。价格(price)在市场机制中起着平衡的作用 市场不断地解决生产什么、如何生产和为谁生产的问题，当平衡了所有影响经济的力量时，市场就达到了供给和需求的市场均衡(market equilibrium of supply and demand)。 市场均衡代表了所有不同的买者和卖者之间的一种平衡。在某一价格水平上，买者所愿意购买的数量正好等于卖者所愿意出售的数量，这一价格就达成了供给和需求的均衡。 市场如何解决三大经济问题 生产什么商品和劳务取决于消费者的货币选票——每天的购买决策。企业会受到利润(profit，净收益，等于总销售额和总成本之间的差额)最大化愿望的驱使。 如何生产取决于不同生产者之间的竞争。生产者的最佳方法是采用效率最高的生产技术以将成本降到最低点。 为谁生产主要取决于生产要素市场上的供给与需求。要素市场决定了工资、地租、利息和利润的水平(要素价格)。收入在消费者之间的分配取决于他们所拥有的要素的数量和价格。 经济的核心控制者是偏好和技术。消费者根据自己先天或后天的偏好(并以其货币选票加以表达)解决社会资源的最终用途，即在生产可能性边界上的各个点之间作决定。 可供利用的资源和技术对消费者的选择构成了一种基本的约束，经济不能超越于它的生产可能性边界。经济资源与可供利用的科学技术加在一起，限定了消费者花钱消费的对象 追逐个人利益的结果，是经常地增进社会的利益，其效果要比真的想要增进社会的利益时更好。(“看不见的手”在引导)(亚当·斯密《国富论》) 在一定条件下，完全竞争经济是有效率的(经济效率指的是无法在不损害其他人经济福利的前提下增进某个人的经济福利) 市场不灵的一种情况是垄断以及其他形式的不完全竞争。 第二种不灵表现为市场的外溢效果或外部性：正面的外部性包括科学发现等，而负面的外溢效果应包括环境污染。 市场的收入分配的后果在政治上或道义上时无法接受的。 贸易、货币和资本 发达经济以细密的贸易网络(基于大量的专业化和精细的劳动分工)为特征 当今的经济都大量使用货币(支付手段) 现代工业技术依赖于大规模的资本运用: 精密的机器、大型的工厂和库存 贸易、专业化和劳动分工 专业化是指让个人或国家各自集中精力去完成某一种(或一系列)任务，使得每个人或国家都能够发挥其特殊技能和资源优势 发达经济致力于专业化和劳动分工，因而能提高其资源的生产率。个人和国家用自己专业化生产的物品自愿地交换其他人的产品，能极大地增加消费品的范围和数量，并提高每个人的生活水平。 货币(money)是一种支付手段或交换媒介，即购物时所支付的现金和支票。 货币是供应适度是各国宏观经济政策的主要任务之一。 资本(capital)，一种被生产出来的要素，一种本身就是由经济过程产出的耐用的投入品 三大生产要素：资本、土地和劳动。 基本生产要素：土地和劳动，其供给主要取决于非经济要素。 资本使用之前必须首先被生产出来。资本在本质上意味着时间的耗费和间接的生产手段。 靠牺牲当前消费而获得的增长 许多经济活动都涉及到放弃现时消费以增加资本，提高经济未来的生产率，进而增加未来的消费 资本和私有财产 在市场经济中资本主要归私人拥有，从投资中得到的收益也归个人所有 产权赋予资本使用者使用、交换、装修、挖掘、钻探等利用其资本品的权利 个人占有资本并能从中获取利润，是资本主义的实质之所在 最有价值的经济资源，即劳动，不能像私人财产那样成为可以买卖的商品。人不能自由地卖出自己，只能在某个工资价位上将自己租借出去 政府的经济职能 现实世界中还不曾有一种经济能够完全依照“看不见的手”的原则而顺利地运行 政府对市场经济主要行使三项职能：提高效率、增进公平以及促进宏观经济的稳定与增长 政府通过促进竞争、控制诸如污染这类外部性问题，以及提供公共品等活动来提高经济效率 政府通过财政税收和预算支出等手段，向某些团体进行有倾斜的收入再分配，从而增进公平 政府通过财政政策和货币政策促进宏观经济的稳定和增长，在鼓励经济增长的同时减少失业和降低通货膨胀 效率 只有在完全竞争成立时，市场机制的优点才能充分体现出来 完全竞争(perfect competition)指的是所有的物品和劳务都有一个价格并都在市场上交易。意味着没有一家企业或一位消费者足以影响整个市场的价格 不完全竞争(imperfect competition)，当买者或卖者能够左右一种商品的价格时；社会的产出将会从生产可能性边界上移至边界之内，物品的产出就会低于有效率的水平。 不完全竞争导致价格高于成本，消费者购买量低于效率水平。过高的价格和过低的产出是伴随不完全竞争而来的非效率的标志 不完全竞争的极端情况是垄断，唯一的卖者独自决定某种物品或劳务的价格水平 外部性(溢出效应) 外部性(externalities)指的是企业或个人向市场之外的其他人所强加的成本或效益 一个行动可能在市场交易之外有助于或有损于其他人的利益，也即存在着根本不发生经济支付的经济交易 负的外部性已逐渐由微小的麻烦变成巨大的威胁，是政府进行干预的地方。 公共品 正外部性的极端情况是公共品 公共品(public goods)指一类商品：将该商品的效用扩展与他人的成本为零(非相克性)；无法排除他人参与共享(非相斥性)。 税收：政府对个人和公司的收入、工资、消费品销售额和其他项目所征收的税款。政府的收入来源，以提供公共品和实施收入再分配计划 公平 市场并不必然能够带来公平的收入分配。市场经济可能会产生令人难以接受的收入水平和消费水平的巨大差异 收入取决于一系列因素，包括努力程度、教育、继承权、要素价格和运气；由此导致的收入分配可能会同公平的结果相悖 物品追随的是货币选票而不是最大满足 累进税 转移支付，帮助根本没有收入的人 宏观经济增长与稳定 资本主义自产生以来不时地受通货膨胀(价格上升)和萧条(高失业率)的周期性困扰。这些波动被称为商业周期。 通过审慎地运用财政和货币政策，政府能够影响产出、就业和通货膨胀的水平 政府的财政政策是税收权力和预算支出权力 货币政策涉及到货币供应量和利率水平， 进而影响到资本品的投资和其他利率敏感性的支出(影响利率和信贷条件)","categories":[],"tags":[]},{"title":"","slug":"economics/宏观经济现象鸟瞰","date":"2017-03-08T04:10:41.265Z","updated":"2017-03-08T04:10:41.265Z","comments":true,"path":"2017/03/08/economics/宏观经济现象鸟瞰/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/economics/宏观经济现象鸟瞰/","excerpt":"","text":"宏观经济现象鸟瞰标签： 宏观经济学 三个重要的宏观经济变量 实际国内生产总值(real GDP):经济体内所有人的实际总收入。人均国内生产总值(GDP per capita): 经济体内平均而言每个人的实际收入。 通货膨胀率(inflation rate):物价水平变动的百分比。(物价指数)用消费者价格指数(consumer price index, CPI)或GDP缩减指数(GDP deflator index)衡量。 失业率(unemployment rate):经济体中没有工作当正在积极找工作的劳动力比重。 GDP：衡量经济活动创造的价值经济体在既定时期内生产的所有的最终产品和服务的当期市场总值 核算GDP三种方法 生产法把GDP作为经济体里当期所生产的最终产品与服务的总值 收入法把GDP作为经济体中所有人的总收入国内顾客的购买总值=企业的总收益=工资+资本所得+中间投入品的购买最终消费=增加值=工资+资本所得(in China)增加值=劳动者报酬+生产税净额+固定资产折旧+营业盈额 支出法把GDP作为经济体里对产品与服务的总支出Y=C+I+G(GDP、消费、投资、政府购买)开放经济条件下Y=Cd+Id+Gd+EX(国内产品和服务的消费、国内产品和服务的投资、国内产品和服务的政府采购、国内产品和服务的出口)国外产品和服务的消费Cf=C-Cd国外产品和服务的投资If=I-Id国外产品和服务的政府采购Gf=G-Gd国外产品和服务的进口IM=Cf+If+Gf净出口(net export)NEX=EX-IM国民经济核算表达式Y=C+I+G+NEX 国民生产总值(gross national product,GNP)一国居民在一个既定时期内所获得的总收入GNP=GDP+来自国外的生产要素收入-对国外的生产要素支付 物价水平：衡量生活费用通货膨胀：物价水平上升 消费者价格指数(CPI)最常用的度量物价水平的指标 选定一个开始时期(基期) 选定一个典型消费者所购买的一篮子产品和服务的种类和数量 计算每一期购买同样一篮子产品和服务的支出 计算每一期的CPI(CPI=当期与基期一篮子产品和服务支出的比值) 通货膨胀率 = (CPI(后一期)-CPI(前一期))/CPI(前一期) 生产者价格指数(producer price index, PPI)度量物价水平的另一指标 典型生产者购买的一篮子产品和服务 GDP缩减指数 名义GDP(nominal GDP)：按照当期价格度量的GDP实际GDP(real GDP)：按照不变价格度量的GDP(尽可能反映经济体生产能力的变化) GDP缩减指数=名义GDP/实际GDP * 100% 名义GDP剔除通货膨胀的影响得到实际GDP 失业率：度量经济体痛苦程度就业：在一定年龄段的经济活动主体从事有报酬的活动 失业者：有劳动能力并愿意就业但找不到工作的经济活动主体 劳动力人口 = 劳动年龄(16~65)人口 - 不在劳动力(not in labor force)人口 劳动参与率 = 劳动力人口 / 劳动年龄人口 失业率 = 失业人口 / 劳动力人口 测算失业人口两种方法 收集失业者在劳动行政部门申报的数据大多数失业者有申报动机：失业申报可以领取失业救济金、获得再就业信息等 定期抽样调查估计失业人口 数据查找 中国国家统计局网站 http://www.stats.gov.cn 中国经济学教育科研网 http://www.cenet.org.cn/cn/ 美国 总统经济报告 www.access.gpo.gov/eop/ 美国统计概要 www.census.gov/compendia/statab 经济合作与发展组织 www.oecd.org 宾夕法尼亚大学国际比较中心 http://pwt.econ.upenn.edu/ 哈佛商学院宏观经济学资源网站 www.hbs.edu/units/bgie/internet","categories":[],"tags":[]},{"title":"","slug":"economics/宏观经济学鸟瞰","date":"2017-03-08T04:10:41.265Z","updated":"2017-03-08T04:10:41.265Z","comments":true,"path":"2017/03/08/economics/宏观经济学鸟瞰/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/economics/宏观经济学鸟瞰/","excerpt":"","text":"宏观经济学鸟瞰标签：宏观经济学 研究对象：整体经济行为 个体行为的总体成果 不是研究特定部门或特定经济活动主体的行为 经济生活中的重大问题 基本研究方法：考察经济的总体趋势 收集不同时期、不同国家有关收入、通货膨胀和失业等变量的数据，尝试构建有助于理解这些数据的一般理论 发展历程凯恩斯革命 系统收集、处理总量数据，为宏观经济学的研究提供科学基础 对经济波动的系统研究 始于1929年的“大萧条” 凯恩斯《就业、利息和货币通论》(General Theory of Employment, Interest and Money) 有效需求：总需求(aggregate demand) 构成现代宏观经济学的要素 乘数，解释需求冲击如何被放大以及如何导致产出更大的变化 流动性偏好，凯恩斯对货币需求的称谓，解释货币政策如何影响利率和有效需求 预期在影响消费和投资方面的重要性，动物精神，即预期的变化是造成需求和产出变化的主要因素 凯恩斯主义的发展 新古典综合(neoclassical synthesis)：整合凯恩斯思想和古典思想 IS-LM模型 用数学语言对凯恩斯的观点进行表述 预期没有起到任何作用 缺少对价格和工资的调整 消费理论：持久收入在消费决策中具有重要作用 投资理论 货币需求理论：基于流动性、投资报酬率和风险发展不同资产之间的选择理论 凯恩斯主义和货币主义(争论) 货币政策和财政政策(的效果) 凯恩斯强调，治理经济衰退中财政政策优于货币政策，IS曲线非常陡峭，推论货币政策作用不大 弗里德曼、施瓦茨考察货币史发现货币政策非常有效，可以解释大多数产出波动 IS曲线并没有想象的那样陡峭，财政政策和货币政策都会产生效果 菲利普斯曲线 失业和通胀之间存在可靠的交替关系 失业和通胀之间并不存在长期的交替关系：违背基本的经济规律 宏观经济管理模式(的作用) 凯恩斯主义：政府在宏观经济管理上要相机决策；经济学知识可用以稳定经济，政策制定者能够做正确的事情 弗里德曼质疑政府的良好初衷未必能可信地做正确的事情，建议政府在宏观经济管理上采取固定法则 理性预期批判 危机(20世纪70年代) 经济生活中发生石油危机 滞涨(stagflation): 高失业和高通胀同时存在 石油危机是一次不利的供给冲击 一部分经济学家开始从理论上质疑凯恩斯主义 凯恩斯主义经济学在石油危机中所表现出的漏洞：忽略预期影响经济活动主体行为的全面含义 解决办法：人们基于目前所有的信息理性地做出预期 凯恩斯主义经济学遭到严重破坏(经济活动主体是理性的，其预期也是理性的) 卢卡斯批判(Lucas Critique) 如果政策发生变化，人们会基于新的政策形成预期，其行为也会发生变化，从而导致原先的宏观经济(计量)模型可能会对在新政策下将要发生的事情做出糟糕的指导。 如20世纪70年代初期的菲利普斯曲线 理性预期与菲利普斯曲线 凯恩斯模型中，由于价格和工资将沿着菲利普斯曲线缓慢调整，产出是缓慢而不是迅速调整到潜在产出水平。 卢卡斯：供给和价格的调整很大程度上取决于工资制定者对通胀的预期方式，一旦我们假定工资制定是理性预期的，调整可能快得多 最优控制与博弈论 凯恩斯主义采用的(宏观经济政策)分析工具，最优控制等，忽视了宏观经济政策制定者与经济活动主体之间的互动 理性预期的第三个含义：如果经济活动主体是理性预期的，那么政策通常是政策制定者与经济活动主体之间的博弈 采用博弈论研究宏观经济政策 理性预期的整合(20世纪70年代和80年代) 消费随机游走假说(Random-Walk Model of Consumption) 理性预期引入到消费研究领域：如果消费者是理性预期的且非常有远见，那么对于下一年消费的最好预测就是今天的消费 消费的变化难以预测：消费者只有得知有关将来的新信息后才会改变消费行为，但将来的新信息是不可预测的 工资与价格的交错调整(staggered price adjustment) 工资和价格的调整过程不会出现突然的同步调整，而是交错调整，可能是缓慢的 即使经济活动主体是理性预期的，产出也是缓慢调整到其潜在产出水平的 政府有效需求管理的有效性并不依赖于理性预期的假定，而是依赖于市场瞬时出清的假定 政策理论 博弈不仅存在于政策制定者和经济活动主体之间，也存在与政策制定者(政党、央行和中央政府，或不同国家政府)之间 当前发展 新古典主义，新凯恩斯主义，新增长理论 实际商业周期理论(real business cycle, RBC)：经济体的产出通常处于其潜在水平，因此所有波动都是源于潜在产出水平自身的变动，而不是源于对潜在产出水平的偏离。 RBC强调经济波动的根源是技术进步 新凯恩斯主义(New Keynesians) 以最大化行为和理性预期为基础构建严密可信的工资、价格粘性模型 研究方向主要集中在劳动力市场的工资决定、信用市场的不完全以及名义刚性(nominal rigidities) 由于工资和价格决策的交错，产出会偏离潜在水平很长一段时间； 菜单成本理论(menu cost): 即使改变价格的成本很小也会导致交错的价格调整，产生名义价格刚性 新经济增长理论(new growth theory) 经济体增长速度取决于技术进步速度，决定技术进步的因素 规模报酬递增在增长中的作用，有效地分析框架 微观经济学经济学家如何思考 经济学家最基本的工具：数据、术语、思考问题的方式；利用这些工具构建模型(model)，用数学术语清晰地说明变量之间的关系。 外生变量(exogenous variables)：模型中给定的变量 内生变量(endogenous variables)：模型要解释的变量 模型界定外生变量如何影响内生变量 供求模型某种商品的竞争性市场，市场需求曲线单调下降，市场供给曲线单调上升，交点为市场均衡点。 内生变量：对应价格为均衡价格，对应商品数量为均衡交易数量 外生变量：消费习惯、原材料来源、技术水平、政治法律等的变化，市场规模或居民收入水平变化等 需求膨胀：需求方购买商品的愿望和能力增强，商品的需求量在每个价格水平上都有所增加；需求曲线向右平移，会导致市场均衡点上升，均衡价格和均衡交易量同时上升 需求收缩：需求方购买商品的愿望和能力减弱，商品的需求量在每个价格水平上都有所下降；需求曲线向左平移，会导致市场均衡点下降，均衡价格和均衡交易量同时下降 供给膨胀：供给方出售商品的愿望增强，商品的供给量在每个价格水平上都有所增加;供给曲线向右平移，市场均衡点下降，均衡价格下降，均衡交易量上升 供给收缩：供给方出售商品的愿望减弱，商品的供给量在每个价格水平上都有所减少；供给曲线向左平移，市场均衡点上升，均衡价格上升，均衡交易量下降 从微观到宏观宏观经济理论必须与微观经济活动主体的基本行为一致 试图在理论水平上理解单个家庭和企业的决策过程 试图通过加总经济体中微观主体的所有决定来解释整体经济行为 通过手机分析数据，实证检验宏观经济学模型是否与现实一致 基本假定一种产品或服务的价格可以迅速调整；市场可以自动走向供求均衡，市场迅速出清 现实中存在工资和价格缓慢调整的情况，价格黏性 价格并不总是黏性的，最终会随着供求的变动而变动；这一假定可以描述经济体的长期趋势 基本模型 总需求(aggregate demand, AD)：在货币政策、财政政策以及消费者信心不变的情况下，每给定一个价格水平，产品市场和货币市场同时处于均衡状态时的产量水平 总需求函数(aggregate demand function)：Y = D(P)，经济体中价格水平P，总需求量Y 总需求曲线(aggregate deamnd curve) 其它条件不变(ceteris paribus)：除价格水平之外其它与经济体的总需求相关的条件都保持不变 总供给(aggregate supply)：在经济体中，对于每一既定价格水平，厂商愿意提供的产量 总供给函数(aggregate supply function)：Y = S(P) 长期总供给曲线是垂直的。其它条件发生变化(技术进步等)，生产能力提高时总供给曲线向右平移 在短期，价格是黏性的，总供给曲线是水平线 通常情况下，短期总供给曲线是向右上方倾斜","categories":[],"tags":[]},{"title":"","slug":"economics/供给与需求的基本原理","date":"2017-03-08T04:10:41.264Z","updated":"2017-03-08T04:10:41.264Z","comments":true,"path":"2017/03/08/economics/供给与需求的基本原理/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/economics/供给与需求的基本原理/","excerpt":"","text":"供给与需求的基本原理标签：微观经济学 需求表 在其他条件相同时，一种物品的价格越高，人们愿意购买的数量就越少；而市场价格越低，人们愿意购买的数量就越多 价格与需求之间的关系可以用一张需求表(demand schedule)或一条需求曲线(demand curve)表示 需求曲线：数量和价格呈反比关系 需求向下倾斜规律(law of downward-sloping demand): 当一种商品的价格上升时(同时其他条件保持不变)，购买者便会趋向于购买更少的数量；当价格下降、其他条件保持不变时，需求量会增加 替代效应(substitution effect): 当一种物品的价格上升时，人们会用其他类似的物品替代它 收入效应(income effect): 当价格上升时，人们会发现自己比以前穷了一些 市场需求 市场需求曲线是将在每一价格水平下所有个人的需求量加总而得到的 市场需求曲线符合需求向下倾斜规律 需求曲线背后的因素 消费者的平均收入是需求的重要决定因素。个人收入上升，即使价格不变，人们也会倾向于购买更多数量的几乎任何物品。 市场规模(用人口衡量)影响市场需求曲线 相关物品的价格及其可获得性会影响对该物品的需求，尤其是替代品之间存在着重要的联系 爱好或偏好的主观因素。代表文化、历史因素，反映心理、生理需要或人为造成的需要或者传统、宗教的因素 其他特殊的因素 需求的移动：除物品价格以外的其他因素(非价格变量)发生了变化 需求变动：商品价格之外的因素变化引起购买数量发生变化 需求增加，需求曲线向右移动，每一价格水平人们会购买更多物品 需求减少，需求曲线向左移动，每一价格水平人们会购买更少物品 供给表 一种商品的供给表(supply schedule)或供给曲线(supply curve)体现在其它条件下，该商品的市场价格与生产者愿意生产和销售的数量之间的关系 应当保持不变的条件包括生产成本、相关物品的价格和政府政策 供给曲线 供给曲线向上倾斜的重要原因之一是边际收益递减规律：每一个新增加的劳动(要素)所增添的数量是递减的 供给曲线背后的因素 一个关键因素是生产成本 生产成本主要取决于投入品(劳动、能源或机器等)价格和技术进步(降低生产同量产出所需的投入品数量的变化)(从应用科学突破到现有技术的更新与挖潜、生产流程的重新组织) 供给受相关物品价格的影响 一种替代品的价格上升，另一种替代品的供给就会下降 政府政策会对供给曲线产生重大影响 特殊因素(气候条件之类)也会影响供给曲线 供给的移动：价格之外的其他因素发生变动而引起供给数量发生变动 在市场的每一价格水平，当供给的数量都增加(或减少)时，供给增加(或减少) 供给和需求的平衡 市场均衡(market equilibrium)：供给和需求的力量相互作用，产生均衡的价格和均衡的数量。 在该点买者所愿意购买的数量正好等于卖者所愿意出售的数量。 当供求力量平衡时，只要其他条件保持不变，价格就没有理由继续波动 市场出清价格(market-clearing price)：需求量与供给量相等的价格水平(均衡价格) 供给曲线与需求曲线的均衡 均衡价格与均衡数量发生在愿意供给的数量等于愿意购买的数量的水平上 在竞争市场上，均衡发生在供给曲线与需求曲线的交点 在均衡价格水平上，市场上不存在短缺或过剩 供给或需求的移动对均衡的影响 当影响需求或供给的诸因素发生变化时就会导致需求或供给发生变动，并引起市场上的均衡价格和均衡数量也发生变动 解释价格和数量的变动：供给变化或需求变化；需求变化或沿着需求曲线移动 供给、需求和移民：移民对于当地劳工市场影响微弱;人口流动性强，新移民流向最可能找到工作的城市，迁入城市对劳工需求已经上升;移民迁入，当地居民迁出，劳动总供给实际上没变动 通过价格进行分配 用钱包进行配给(rationing by the purse)：市场通过供求的相互作用决定所有投入和产出的均衡价格和均衡数量，将社会的稀缺品配置或配给到各种用途中","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/面向对象编程","date":"2017-03-08T04:10:41.260Z","updated":"2017-03-08T04:10:41.260Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/面向对象编程/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/面向对象编程/","excerpt":"","text":"面向对象编程标签： C++ 一个面向对象程序范例 面向对象对象编程三要素： 数据抽象 继承 动态绑定 适用于大型程序 以算术表达式树形表示的面向对象解决方案为例创建和打印表达式 定义表达式树节点类每个节点可能有一到三个子节点，可用一个联合加上一个指示节点类型的专门字段表示节点 三种节点： 包含一个整数值，无子节点 包含一个操作符，一个子节点 包含一个操作符，两个子节点 当需要用到一个类型字段时可以考虑定义一系列类并用继承组织起来能否更有效 用一个类表示“节点”概念 12345678910111213class Expr_node &#123; // print the expression friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr_node&amp;);protected: virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Expr_node&amp; e) &#123; e.print(o); return o;&#125; 用继承声明具体类型 12345678910111213141516171819202122232425262728293031323334353637// save first node-typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr_node* opnd; Unary_node(const string&amp; a, Expr_node* b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; *opnd &lt;&lt; \")\"; &#125;&#125;;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr_node* left; Expr_node* right; Binary_node(const string&amp; a, Expr_node* b, Expr_node* c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; *left &lt;&lt; op &lt;&lt; *right &lt;&lt; \")\"; &#125;&#125;; 用句柄类管理指针避免使用者管理内存的麻烦使用者关心的只是树和子树而非单个节点，定义句柄类Expr隐藏Expr_node继承层次 12345678910111213141516171819202122232425class Expr &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int); Expr(const string&amp;, Expr); Expr(const string&amp;, Expr, Expr); Expr(const Expr&amp;); Expr&amp; operator=(const Expr&amp;); ~Expr() &#123; delete p; &#125;&#125;;Expr::Expr(int n) &#123; p = new Int_node(n);&#125;Expr::Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t);&#125;Expr::Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right);&#125; 改进 可在Expr_node派生层次加入虚函数copy 加入引用计数避免复制下层Expr_node会更有效率123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Expr_node &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); friend class Expr; // add a use count int use;protected: Expr_node(): use(1) &#123;&#125; virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125;&#125;;class Expr &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp;);&#125;;// assignment operator increase use count of the right objectExpr&amp; Expr::operator=(const Expr&amp; rhs) &#123; rhs.p-&gt;use++; if (--p-&gt;use == 0) delete p; p = rhs.p; return *this;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Expr&amp; t) &#123; t.p-&gt;print(o); return o;&#125;// save first typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr opnd; Unary_node(const string&amp; a, Expr b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; opnd &lt;&lt; \")\"; &#125;&#125;;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr right; Binary_node(const string&amp; a, Expr b, Expr c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; \")\"; &#125;&#125;; 扩展新操作：表达式求值方法和打印表达式相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Expr_node &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); friend class Expr; int use;protected: Expr_node(): use(1) &#123;&#125; virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125; // add a pure virtual function virtual int eval() const = 0;&#125;;class Expr &#123; friend class Expr_node; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp; t); // new function: calculate the evaluation int eval() const &#123; return p-&gt;eval(); &#125;&#125;;// save first typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;; // new function int eval() const &#123; return n; &#125;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr opnd; Unary_node(const string&amp; a, Expr b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; opnd &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Unary_node::eval() const &#123; // only consider certain operands if (op == \"-\") return -opnd.eval(); throw \"error, bad op \" + op + \" int UnaryNode\";&#125;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr right; Binary_node(const string&amp; a, Expr b, Expr c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Binary_node::eval() const &#123; int op1 = left.eval(); int op2 = right.eval(); if (op == \"-\") return op1 - op2; if (op == \"+\") return op1 + op2; if (op == \"*\") return op1 * op2; if (op == \"/\" &amp;&amp; op2 != 0) return op1 / op2; throw \"error, bad op \" + op + \"in BinaryNode\";&#125; 类的抽象对算术表达式进行了精确建模 扩展程序以计算表达式所需要增加的代码较少 扩展增加新节点类型如增加Ternary_node表示三元操作符(?:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Ternary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr middle; Expr right; Ternary_node(const string&amp; a, Expr b, Expr c, Expr d): op(a), left(b), middle(c), right(d) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; \" ? \" &lt;&lt; middle &lt;&lt; \" : \" &lt;&lt; right &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Ternary_node::eval() const &#123; if (left.eval()) return middle.eval(); else return right.eval();&#125;// add a constructor for Ternary_node in Exprclass Expr &#123; friend class Expr_node; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const string* op, Expr left, Expr middle, Expr right) &#123; p = new Ternary_node(op, left, middle, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp; t); // new function: calculate the evaluation int eval() const &#123; return p-&gt;eval(); &#125;&#125;; 总结面向对象编程能简化程序的设计和更新过程 对下层系统中的对象进行建模 保证修改时耦合度低","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/类设计者的核查表","date":"2017-03-08T04:10:41.259Z","updated":"2017-03-08T04:10:41.259Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/类设计者的核查表/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/类设计者的核查表/","excerpt":"","text":"类设计者的核查表标签：C++ 构造函数简单的类 结构就是接口 不需要构造函数 数据成员私有阻止类的使用者私自改动提供相应接口 供使用者执行修改或访问等操作 无参构造函数声明对象数组必需 初始化数据成员每个构造函数都要负责为所有的数据成员设置经过明确定义的值除非该数据成员在类的对象存在一定时间后才有意义或其它特殊情况 析构函数该类分配了不会被成员函数自动释放的资源（动态内存）时必需 虚析构函数(类B派生的子类D，若可能对D类型对象的B*指针执行delete表达式时必需)例如:123456789101112class B &#123; string s;&#125;;class D : public B &#123; string t; // virtual ~B() &#123;&#125;;&#125;;int main() &#123; B* bp = new D; // no problem delete bp; // unless B has a virtual destructor // or the wrong dstructor would be called&#125; 拷贝构造函数当复制类的对象并非复制其数据成员和基类对象时必需 若不想使用者能够复制类的对象，就声明复制构造函数(赋值操作符)为私有的 赋值操作符当赋值类的对象并非复制其数据成员和基类对象时必需 考虑赋值给对象本身的情况例如: 1234567891011121314class String &#123;public: string&amp; operator=(const String &amp;s);private: char *data;&#125;;String&amp; String::operator=(const String&amp; s) &#123; if (&amp;s != this) &#123; // do nothing with self-assignment delete [] data; // delete old array data = new char[strlen(s.data) + 1]; strcpy(data, s.data); &#125; return *this;&#125; 若不想使用者能够设置类中的对象，就将赋值操作符私有化 析构函数、拷贝构造函数、赋值操作符= 通常为同时必需的 关系操作符类逻辑上支持相等操作则提供 operator== 和 operator!=类具有某种排序关系则提供余下的关系操作符(&lt; &gt; &lt;= &gt;=) 拷贝构造函数和赋值操作符的参数类型加上constlike X::X(const X&amp;) X::operator=(const X&amp;) 函数的const引用参数除非函数用来改变参数的值否则应为const引用例如: Complex operator+(const Complex&amp; x, const Complex&amp; y); 适当声明成员函数为const成员函数不用修改它的对象时 const对象只能使用声明为const的函数 设计理念：C++不可能自动处理所有这些事情(难以保证做得对)始终加入的话增加太多的额外负担，开销过大如给所有类自动添加一个虚析构函数，当类较小时开销明显作为变通方法，让编译器指出什么时候类该有什么必需的","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/模板（二）","date":"2017-03-08T04:10:41.258Z","updated":"2017-03-08T04:10:41.258Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/模板（二）/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/模板（二）/","excerpt":"","text":"模板（二）标签：C++ 访问容器中的元素保留Array和一个指向T的指针之间的密切关系要付出一定的代价 用户能够轻易得到一个指向Array内部的指针，即使Array本身不存在了，这个指针仍被保留 不得不暴露类的内部机制，一旦内存变化肯定导致用户错误；resize之类的扩展有诸多潜在错误 增加防止出错的中间层 模拟指针1234567891011template &lt;class T&gt; class Pointer &#123;public： Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(&amp;a), sub(n) &#123;&#125; Pointer(): ap(0), sub(0) &#123;&#125; // Array&lt;T&gt; cann't be default: reference should bind a objectprivate: Array&lt;T&gt;* ap; unsigned sub; // ...&#125;; 复制一个Pointer之后，原Pointer和其副本都指向一个位置 获取元素 最直接的方法会面临上述问题： 12345678template &lt;class T&gt; class Pointer &#123;public: T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125;&#125;; 另一种解决方案会带来赋值不方便的新问题： 123456789101112template &lt;class T&gt; class Pointer &#123;public: T operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125;&#125;;// \"t = *p\" is allowed but \"*p = t\" is forbidden// the point is that it is hard to implement \"*p = t\"// while \"T* tp = &amp;*p\" is allowed 引进update操作 12345678910111213141516171819202122template &lt;class T&gt; class Pointer &#123;public： Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(&amp;a), sub(n) &#123;&#125; Pointer(): ap(0), sub(0) &#123;&#125; T operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125; void update(const T&amp; t) &#123; if (ap == 0) throw \"update of unbound Pointer\"; (*ap)[sub] = t; &#125;private: Array&lt;T&gt;* ap; unsigned sub; // ...&#125;; 相应地，Array类使用update操作，但会带来无法实现包含Array的Array的功能的问题 12345678910111213template &lt;class T&gt; class Array &#123;public: T operator[](unsigned n) const &#123; if (n &gt;= sz) throw \"Array suubscript out of range\"; return data[n]; &#125; void update(unsigned n, const T&amp; t) &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; data[n] = t; &#125;&#125;; 方便性和安全性之间的权衡问题 选择何种方法取决于类会被确切地怎样使用 遗留问题 如果Array不存在了还可能存在一个指向它的空悬Pointer “软件工程基本定理”(though it isn’t a real theory): 通过引进一个额外的中间层能够解决任何问题。’ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091template &lt;class T&gt; class Array_data &#123; friend class Array&lt;T&gt;; friend class Pointer&lt;T&gt;; Array_data(unsigned size = 0): data(new T[size]), sz(size), use(1) &#123;&#125; ~Array_data() &#123; delete [] data; &#125; const T&amp; operator[](unsigned n) const &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; return data[n]; &#125; T&amp; operator[](unsigned n) &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; return data[n]; &#125; // no implement that copy is no allowed Array_data(const Array_data&amp;); Array_data&amp; operator=(const Array_data&amp;); T* data; unsigned sz; int use;&#125;;template &lt;class T&gt; class Array &#123; friend class Pointer&lt;T&gt;;public: Array(unsigned size): data(new Array_data&lt;T&gt;(size)) &#123;&#125; ~Array() &#123; if (--data-&gt;use == 0) delete data; &#125; const T&amp; operator[](unsigned n) const &#123; return (*data)[n]; &#125; T* operator[](unsigned n) &#123; return (*data)[n]; &#125;private: Array(const Array&amp;); Array&amp; operator=(const Array&amp;); Array_data&lt;T&gt;* data;&#125;;template &lt;class T&gt; class Poiter: public Ptr_to_const&lt;T&gt; &#123;public: Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(a.data), sub(n) &#123; ++ap-&gt;use; &#125; Pointer(): ap(0), sub(0) &#123;&#125; Pointer(const Pointer&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123; if (ap) ++ap-&gt;use; &#125; ~Pointer() &#123; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; &#125; Pointer&amp; operator=(const Pointer&lt;T&gt;&amp; p) &#123; if (p.ap) ++p.ap-&gt;use; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; ap = p.ap; sub = p.sub; return *this; &#125; T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;private: Array_data&lt;T&gt;* ap; unsigned sub;&#125;;// the following code does workArray&lt;int&gt;* ap = new Array&lt;int&gt;(10);Pointer&lt;int&gt; p(*ap, 5);delete ap;*p = 42; 指向const Array的Pointer 还无法使Pointer指向const Array的元素 const Array的实际对象很少，但通过引用传递Array参数(const Array&amp;)时还是有用的 定义独立的类，提供类型转换操作符给这个类，通过继承获得两种类型间的相似性 类Pointer从Ptr_to_const继承而来，即使对象不是const类型也能把指针保存在Array_data中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template &lt;class T&gt; class Ptr_to_const &#123;public: // catch a argument const Array&lt;T&gt;&amp; instead of Array&lt;T&gt;&amp; Ptr_to_const(const Array&lt;T&gt;&amp; a, unsigned n = 0): ap(a.data), sub(n) &#123; ++ap-&gt;use; &#125; Ptr_to_const(): ap(0), sub(0) &#123;&#125; Ptr_to_const(const Ptr_to_const&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123; if (ap) ++ap-&gt;use; &#125; ~Ptr_to_const() &#123; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; &#125; Ptr_to_const&amp; operator=(const Ptr_to_const&lt;T&gt;&amp; p) &#123; if (p.ap) ++p.ap-&gt;use; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; ap = p.ap; sub = p.sub; return *this; &#125; const T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;private: Array_data&lt;T&gt;* ap; unsigned sub;&#125;;// redefine class Pointer to keep something about constanttemplate &lt;class T&gt; class Poiter: public Ptr_to_const&lt;T&gt; &#123;public: Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): Ptr_to_const&lt;T&gt;(a, n) &#123;&#125; Pointer() &#123;&#125; T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;&#125;; 增强操作重新设置Array大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;class T&gt; class Array &#123;public: void resize(unsigned n) &#123; // Array_data do the real operation data-&gt;resize(n); &#125; //...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::resize(unsigned n) &#123; if (n == sz) return ; T* odata = data; data = new T[n]; copy(odata, sz &gt; n ? n : sz); delete [] odata; sz = n;&#125;template &lt;class T&gt;void Array_data&lt;T&gt;::copy(T* arr, unsigned n) &#123; for (int i = 0; i &lt; n; ++i) data[i] = arr[i];&#125;// another way of changing Array sizetemplate &lt;class T&gt; class Array &#123;public: void reverse(unsigned new_sz) &#123; if (new_sz &gt;= data-&gt;sz) data-&gt;grow(new_sz); &#125; //...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::grow(unsigned new_sz) &#123; unsigned nsz = sz; if (nsz == 0) nsz = 1; whiel (nsz &lt;= new_sz) nsz *= 2; resize(nsz);&#125; 实现对Array的复制和赋值使包含Array的Array有效 不允许对Array_data对象复制，故不定义operator=调用Array_data::operator= 1234567891011121314151617181920template &lt;class T&gt; class Array &#123;public: Array(const Array&amp; a): data(new Array_data&lt;T&gt;(a.data-&gt;sz)) &#123; data-&gt;copy(a.data-&gt;data, a.data-&gt;sz); &#125; Array&amp; operator=(const Array&amp; a) &#123; if (this != &amp;a) data-&gt;clone(*a.data, a.data-&gt;data); return *this; &#125; // ...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::clone(const Array_data&amp; a, unsigned n) &#123; delete [] data; data = new T[sz = a.sz]; copy(a.data, sz);&#125; 尚未完全消除指针的需求","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/模板（三）","date":"2017-03-08T04:10:41.256Z","updated":"2017-03-08T04:10:41.256Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/模板（三）/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/模板（三）/","excerpt":"","text":"模板（三）标签：C++ 迭代器 已经定义Array、Pointer和Ptr_to_const使得能部分确保安全性避免使用指针 进一步取代指针，需实现加法、减法和关系运算符 ‘’’C++void f() { int a[10]; int pa = a; int end = pa + 10; while (pa != end) *pa++ = 0;}‘’’ 基类及派生类都要定义这些操作 ‘’’C++template class Pointer: public Ptr_to_const {public: Pointer&amp; operator++() { ++sub; return *this; } Pointer&amp; operator--() { --sub; return *this; } Pointer&amp; operator++(int) { Pointer ret = *this; ++sub; return ret; } Pointer&amp; operator--(int) { Pointer ret = *this; --sub; return ret; } Pointer&amp; operator+=(int n) { sub += n; return *this; } Pointer&amp; operator-=(int n) { sub -= n; return *this; } // ... }; template Pointer operator+(const Pointer&amp; p, int n) { Pointer ret = p; return ret += n;} template Pointer operator+(int n, const Pointer&amp; p) { Pointer ret = p; return ret += n;} // subtration is similar‘’’ 两个指针当且仅当指向同一个Array的同一个元素(或都不指向任何Array)时才相等 ‘’’C++template int operator==(const Ptr_to_const&amp; op1, cosnt Ptr_to_const&amp; op2) { if (op1.ap != op2.ap) return 0; return (op1.sub == op2.sub);} template int operator&lt;(const Ptr_to_const&amp; op1, const Ptr_to_const&amp; op2) { if (op1.ap != op2.ap) throw “&lt; on different Arrays”; return op1.sub &lt; op2.sub;}‘’’ 迭代器能在不暴露容器内部结构的情况下访问容器的元素 删除元素 当元素不存在时的处理方法 禁止从容器中删除单个元素(可以删除整个容器) 在每个容器对象中保存一个有效迭代器的列表，删除一个元素则正好删除刚好指向这个被删除元素的迭代器 对容器中每个元素采用引用计数，删除任何一个元素都必须等到最后一个指向该元素的引用都不存在 让迭代器指向容器中元素与元素之间的位置上(难以实现；影响先有代码) 删除容器 容器本身已不存在，还有活动的迭代器的解决方法 删除操作延后到最后一个迭代器失效 采用处理删除单个元素的思想 用户确保一旦容器删除就不再使用迭代器 只要有活动迭代器存在就禁止删除容器本身","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/模板（一）","date":"2017-03-08T04:10:41.255Z","updated":"2017-03-08T04:10:41.255Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/模板（一）/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/模板（一）/","excerpt":"","text":"模板（一）标签：C++ 容器类设计容器：保存值的集合的数据结构 语言内建容器：数组、结构体 C++没有提供更多的内建容器：不将容器的设计限定到某种单一的方法上(可能不存在唯一正确的方法) 容器包含对象 复制容器意味复制存储在容器中的值(而不是容器本身) 函数传参数方式 void f(const Container&amp;)避免大对象的复制 区分读和写 operator[]只用于取数 用成员函数update(i, x)修改索引为i的元素为x 1234567891011121314151617template &lt;class T&gt; class Container &#123; // ...public: T operator[](Index) const; void update(Index, const T&amp;); // ...&#125;;Container&lt; Container&lt;int&gt; &gt;c;Index i, j;int k = c[i][j];// only way to modify the element in Container// c[i][j]void update(Index, const T&amp;);void update(Index, Index, const T&amp;);// hard to deal with much more dimension// c[i] return type T instead of T&amp;// c[i].update(j, new_value) does not work 获取容器的元素严格分清类型T(作右值)和类型T&amp;(作左值) 容器增长：按区块(chunk)增加容器大小的分配策略 容器操作容器数组：必须有缺省构造函数“顺序地”遍历容器中所有元素：先给元素强制规定顺序(解决方案：迭代器(iterator)) 容器元素的类型 类型为T的元素可以进行行为正确的复制、赋值和销毁T::T(const T&amp;) 可以判定两个元素是否相等operator==(const T&amp;, cosnt T&amp;) 为增加性能，有关于偏序关系或全序关系的定义(如set)operator&lt;(const T&amp;, const T&amp;) 考虑是否重载operator&lt;&lt;(ostream&amp;, const Container&amp;)兼顾不使用标准输入输出操作库或不用输入输出操作的用户，提供遍历整个容器的机制 容器不可通过继承关联起来1234567// if Container&lt;Airplane&gt; is derived from Container&lt;Vehicle&gt;Vehicle v;Container&lt;Airplane&gt; ca;Container&lt;Vehicle&gt;&amp; vp = ca;vp.insert(v);// that does not make any sence Demo : an array-like class 使用指针和使用下标的差别 12345678910111213// by indexint i;for (i = 0; i &lt; N; ++i) f(x[i]);// by pointerT* p;for (p = x; p &lt; x + N; ++p) f(*p);// a simplified versionT* p;while (p &lt; x + N) f(*p++); 区别： 下标值本身就有意义，与是否用作下标无关：通过下标进行元素访问的程序要另外知道正在使用的数组(才能访问整个数组) 要访问容器的元素没必要知道容器的标识，指针本身就包含所有的必要信息：程序只要拥有拥有一个指向数组元素的指针就能访问整个数组 这些影响设计，比”下标易于理解，指针效率高”的区别更为重要 禁止(数组)复制和赋值 使用operator[]存取元素 关于扩展：定长 缺省构造函数：可以创建包含数组的数组 123456789101112131415161718192021222324252627282930313233template&lt;class T&gt;class Array &#123;public: Array(): data(0), sz(0) &#123;&#125; Array(unsigned size): sz(size), data(new T(size)) &#123;&#125; ~Array() &#123; delete [] data; &#125; const T&amp; operator[](unsigned n) const &#123; if (n &gt;= sz || data == 0) throw \"Array subscript out of range\"; return data[n]; &#125; T&amp; operator[](unsigned n) &#123; if (n &gt;= sz || data == 0) throw \"Array subscript out of range\"; return data[n]; &#125; operator const T*() const &#123; return data; &#125; operator T*() &#123; return data; &#125;private: T* data; unsigned sz; Array(const Array* a); Array&amp; operator=(const Array&amp;);&#125;; 缺陷 (也存在于内建数组中)包含元素的Array消失后，它的元素地址还在 12345678void f() &#123; int *p; &#123; Array&lt;int&gt; x(20); p = &amp;x[10]; &#125; cout &lt;&lt; *p; // no exist&#125; 允许用户访问它的元素地址，透露太多内部运作的信息，违背了封装理念 允许Array被构造后改变长度会导致旧指针失效","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/句柄类(handle)","date":"2017-03-08T04:10:41.255Z","updated":"2017-03-08T04:10:41.255Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/句柄类(handle)/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/句柄类(handle)/","excerpt":"","text":"句柄类(handle)标签： C++ 创建代理会复制所代理的对象，如何避免复制(保持多态性的前提下避免复制对象的代价) 某些类应当避免复制： 对象很大，资源消耗多 每个对象代表一种不能被轻易复制的资源，如文件 其它数据结构已经存储对象的地址，把副本地址插入那些数据结构中代价会非常大 对象代表位于网络连接另一端的其他对象 多态性环境中只知对象基类类型而不知对象本身类型 避免使用指针复制对象： 使用对象指针比直接使用对象要困难 未初始化的指针非常危险且难以防范 管理内存的硬件总要检查被复制的指针是否真的指向程序所分配的内存位置上 复制未初始化指的针会导致硬件陷阱例如: 123456void f() &#123; // copy a pointer without initialization // would crash a program int* p; // without initialization int* q = p; // not being definited&#125; 多个指针指向同一个对象时应考虑何时删除此对象 handle classe(句柄类) 有时也称为smart pointer(智能指针) 绑定到所控制的类的对象上 简单示例类表示点平面坐标的类123456789class Point &#123;public: Point(): xval(0), yval(0) &#123;&#125; Point(int x, int y): xval(x), yval(y) &#123;&#125; int x() const &#123; return xval; &#125; int y() const &#123; return yval; &#125; Point&amp; x(int xv) &#123; xval = xv; return *this; &#125; Point&amp; y(int yv) &#123; yval = yv; return *this; &#125;&#125;; 使用一个无参构造函数和一个两个参数的构造函数而非一个缺省参数的构造函数Point(int x = 0, int y = 0): xval(x), yval(y) {}后者允许只用一个参数(另一个缺省为零)构造Point对象，而这几乎是错的 绑定到句柄将句柄h直接绑定到对象上Point p;Handle h(p); 删除p后应该使handle无效 handle应该控制它所绑定的对象(创建和销毁) 从效果上说handle就是一种只包含单个对象的容器 获取对象 handle行为上类似一个指针 应阻止使用者直接获得对象的实际地址 过多暴露内存分配策略，不利于改变分配的策略 隐蔽真正的对象地址，避免直接重载 operator-&gt;1234567class Handle &#123;public: Point* operator-&gt;(); // ...&#125;;Point* addr = h.operator-&gt;(); // get the object address // overloading operator-&gt; is to blame 引用计数型句柄(UPoint) 了解有多少句柄绑定在同一个对象上以确定何时删除对象 引用计数(use count)不能是句柄的一部分或对象的一部分 定义新的类容纳引用计数和Point对象 12345678910class UPoint &#123; // all the members are private friend class Handle; Point p; int u; UPoint(): u(1) &#123;&#125; UPoint(int x, int y): P(x, y), u(1) &#123;&#125; UPoint(const Point&amp; p0): p(p0), u(1) &#123;&#125;&#125;; 一个简单的Handle类实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Handle &#123;public: Handle(); Handle(int, int); Handle(const Point&amp;); Handle(const Handle&amp;); Handle&amp; operator=(const Handle&amp;); ~Handle(); int x() const; int y() const; Handle&amp; x(int); Handle&amp; y(int);private: Upoint * up;&#125;;Handle::Handle(): up(new UPoint) &#123;&#125;Handle::Handle(int x, int y): up(new UPoint(x, y)) &#123;&#125;Handle::Handle(const Point&amp; p): up(new UPoint(p)) &#123;&#125;Handle::~Handle() &#123; if (--up-&gt;u == 0) delete up;&#125;// just increase the use count by 1Handle::Handle(const Handle&amp; h): up(h.up) &#123; ++up-&gt;up; &#125;// make sure it works when two handles use the same UPoint objectHandle&amp; Handle::operator=(const Handle&amp; h) &#123; ++h.up-&gt;u; if (--up-&gt;u == 0) delete up; up = h.up; return *this;&#125;int Handle::x() const &#123; return up-&gt;p.x(); &#125;int Handle::y() const &#123; return up-&gt;p.y(); &#125; 写时复制(copy on write)handle改动性函数两种不同语义Handle h(3, 4);Handle h2 = h;h2.x(5);int n = h.x(); // 3 or 5 ? 句柄为指针语义，n = 5 handle表现像指针或引用，h和h2绑定到同一对象 12345678Handle&amp; Handle::x(int x0) &#123; up-&gt;p.x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; up-&gt;p.y(y0); return *this;&#125; 句柄为值语义，n = 3 改变h2的内容不该影响h的值 必须保证所改动的UPont对象不同时被其它Handle所引用，否则复制UPoint12345678910111213141516Handle&amp; Handle::x(int x0) &#123; if (up-&gt;u != 1) &#123; --up-&gt;u; up = new UPoint(up-&gt;p); &#125; up-&gt;p.x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; if (up-&gt;u != 1) &#123; --up-&gt;u; up = new UPoint(up-&gt;p); &#125; up-&gt;p.y(y0); return *this;&#125; if (up-&gt;u != 1) {--up-&gt;u;up = new UPoint(up-&gt;p);} 此代码片段需要在每个改变UPoint对象的成员函数中重复(可设计为Handle的私有成员函数) 写时复制优点：在绝对必要时才进行复制，额外开销小 句柄类的改进 前述实现的缺点：把句柄捆绑到类T的对象上必须先定义具有类型T的成员的新类 当捆绑句柄到继承自T的静态类型未知的类的对象上时难以实现 将应用计数从数据中分离出来作为独立的对象 抽象地表示应用计数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UseCount &#123;public: UseCount(); UseCount(const UseCount&amp;); ~UseCount(); // judge whether use count would become zero bool only(); // judge whether use count should be deleted bool reattach(const UseCount&amp;); // provide a method to make this handle to be the only one bool makeonly();private: int* p; // make assignment illegal UseCount&amp; operator=(const UseCount&amp;);&#125;;UseCount::UseCount(): p(new int(1)) &#123;&#125;UseCount::UseCount(const UseCount&amp; u): p(u.p) &#123; ++*p; &#125;UseCount::~UseCount() &#123; if (--*p == 0) delete p;&#125;bool UseCount::only() &#123; return *p == 1; &#125;bool UseCount::reattach(const UseCount&amp; u) &#123; // increase u.p first to make it work when self-assignment ++*u.p; if (--*p == 0) &#123; delete p; p = u.p; return true; &#125; p = u.p; return false;&#125;bool UseCount::makeonly() &#123; if (*p == 1) return false; --*p; p = new int(1); return true;&#125; 重写Handle类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Handle &#123;public: // the same with previous definition Handle(); Handle(int, int); Handle(const Point&amp;); Handle(const Handle&amp;); Handle&amp; operator=(const Handle&amp;); ~Handle(); int x() const; int y() const; Handle&amp; x(int); Handle&amp; y(int);private: Point* p; UseCount u;&#125;;Handle::Handle(): p(new Point) &#123;&#125;Handle::Handle(int x, int y): p(new Point(x, y)) &#123;&#125;Handle::Handle(const Point&amp; p0): p(new Point(p0)) &#123;&#125;Handle::Handle(const Handle&amp; h): u(h.u), p(h.p) &#123;&#125;Handle::~Handle() &#123; if (u.only()) delete p;&#125;Handle&amp; Handle::operator=(const Handle&amp; h) &#123; if (u.reattach(h.u)) delete p; p = h.p; return *this;&#125;int Handle::x() const () &#123; return p-&gt;x();&#125;int Handle::y() const () &#123; return p-&gt;y();&#125;Handle&amp; Handle::x(int x0) &#123; if (u.makeonly()) p = new Point(*P); p-&gt;x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; if (u.makeonly()) p = new Point(*P); p-&gt;y(y0); return *this;&#125; 总结 通过引入引用计数使得handle类能灵活地设计出来，而将引用计数抽象化表示使handle类能协同不同数据结构工作 UseCount类简化了实现中特定的子问题：接口设计只为简化引用计算句柄实现，而不为终端用户(end user)所用","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/代理类","date":"2017-03-08T04:10:41.253Z","updated":"2017-03-08T04:10:41.253Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/代理类/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/代理类/","excerpt":"","text":"代理类标签： C++ 如何设计C++容器，能够包含类型不同而彼此相关的对象如何将继承自同一父类的属于不同子类的对象装入同一个容器（如vector）之中？(将容器和继承运用在一起) 代理 surrogate允许将整个派生层次压缩在一个对象类型中 surrogate是handle(句柄)类中最简单的一种 一个表示不同交通工具的类派生层次1234567891011class Vehicle &#123;public: virtual double weight() const = 0; virtual void start() = 0; // pure virtual function // ...&#125;class RoadVehicle: public Vehicle &#123;/*...*/&#125;class AutoVehicle: public Vehicle &#123;/*...*/&#125;class Aircraft : public Vehicle &#123;/*...*/&#125;class Helicopter : public Vehicle &#123;/*...*/&#125; 一个容器123Vehicle parking_lot[1000]; // errorAutoVehicle x;parking_lot[num_vehicles++] = x; Vehicle是虚基类，不能实例化 子类对象转化为父类对象会丢失父类中没有的成员 parking_lot是Vehicle的集合而不是所有继承自Vehicle的对象的集合 间接层 indirection存储指针替代存储对象本身123Vehicle* parking_lot[1000];AutoVehicle x;parking_lot[num_vehicles++] = &amp;x; x是局部变量，释放之后parking_pot指向未知 存储副本的指针而非原对象的指针 12AutoVehicle x;parking_lot[num_vehicles++] = new AutoVehicle(x); 带来动态内存管理的负担 必须知道要放入parking_lot中的对象的静态类型1234if (p != q) &#123; delete parking_pot[p]; parking_pot[p] = new Vehicle(parking_pot[q]);&#125; // virtual base class has no instance 虚复制函数在Vehicle中增加合适的纯虚函数来复制编译时类型未知的对象12345678class Vehicle &#123;public: virtual double weight() const = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle() &#123;&#125; // virtual destructor // ...&#125; 在Vehicle的所有派生类中添加成员函数copy，若vp指向Vehicle不确定的子类的对象，vp-&gt;copy()返回指向该对象新建副本的指针。例如：123Vehicle* Trunk::copy() const &#123; return new Truck(*this);&#125; 定义代理类 用类表示概念避免显示处理内存分配且能保持父类在运行时绑定的属性 定义一个行为与Vehicle对象相似而又潜在地表示所有继承自Vehicle对象的东西 —— 代理（surrogate） 1234567891011121314class VehicleSurrogate &#123;public: VehicleSurrogate(); VehicleSurrogate(const Vehicle&amp;); ~VehicleSurrogate(); VehicleSurrogate(const VehicleSurrogate&amp;); VehicleSurrogate&amp; operator=(const VehicleSurrogate&amp;); // object fuctions of Vehicle double weight() const; void start(); // ...private: Vehicle* vp;&#125; 空代理(empty surrogate)的行为类似于空指针123456789101112131415161718192021222324252627282930VehicleSurrogate::VehicleSurrogate(): vp(0) &#123;&#125; // empty surrogateVehicleSurrogate::VehicleSurrogate(const Vehicle&amp; v): vp(v.copy()) &#123;&#125;VehicleSurrogate::~VehicleSurrogate() &#123; delete vp;&#125;VehicleSurrogate::VehicleSurrogate(const VehicleSurrogate&amp; v): vp(v.vp ? v.vp-&gt;copy() : 0) &#123;&#125;VehicleSurrogate&amp; VehicleSurrogate::operator=(const VehicleSurrogate&amp; v) &#123; if (this != &amp;v) &#123; delete vp; vp = (v.vp ? v.vp-&gt;copy() : 0); &#125; return *this;&#125;// call the corresponding object functionsdouble VehicleSurrogate::weight() const &#123; if (vp == 0) throw \"empty VehicleSurrogate.weight()\"; return vp-&gt;weight();&#125;void VehicleSurrogate::start() &#123; if (vp == 0) throw \"empty VehicleSurrogate.start()\"; vp-&gt;start();&#125; tip: 每次对copy的调用都是一个虚拟调用。类Vehicle的对象并不存在 赋值构造函数和赋值操作符中v.vp非零的检测是必需的 赋值操作符确保没有将代理赋值给自身 总结最开始的parking_pot容器可设计为：123VehicleSurrogate parking_lot[1000];Automobile x;parking_pot[num_vehicles++] = x; 将继承和容器共用需要处理两个问题： 控制内存分配 把不同类型的对象放进同一个容器中 采用基础C++技术，在现有的继承层次上加上一层抽象，合适地解决了这些问题。","categories":[],"tags":[]},{"title":"","slug":"Cplusplus_thinking/不应当使用虚函数的情况","date":"2017-03-08T04:10:41.252Z","updated":"2017-03-08T04:10:41.252Z","comments":true,"path":"2017/03/08/Cplusplus_thinking/不应当使用虚函数的情况/","link":"","permalink":"https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/不应当使用虚函数的情况/","excerpt":"","text":"不应当使用虚函数的情况标签： C++ 关于是否应该所有成员函数缺省为虚函数的争论 只有涉及继承时，才需要考虑与此相关的问题 适用的情况 基类派生出的子类需要重写(or 覆盖，override)，基类中相应的成员和函数应声明为虚函数 不适用的情况 虚函数代价并不是非常高，当时会带来一定的额外开销 有些情况下非虚函数能够正确运行而虚函数不能 有些类并非为继承而设计(设计时并不兼容被继承) 效率程序调用显式提供的对象的虚拟成员函数，优秀的编译器不带来额外的开销(与调用非虚函数相同)如：12T x;x.f(); 在这里，f是否虚函数应该没有影响；产生对T::f的直接调用 若所有对成员函数的调用都是通过显式指定的对象进行的则成员函数是否是虚函数就无关紧要了 一旦通过指针或引用进行调用就是有意义的 虚函数会产生额外的开销 用内存引用(memory reference)计数衡量大概的开销 随着微处理器的速度越来越快，内存应用耗时占比会越高，此项指标更精确；但高速缓存的更广泛更大量的使用也使得这项粗糙的估计更不准确；但在这儿这样估计是必要的。 如：12345int&amp; IntArray::operator[](unsigned n) &#123; if (n &gt;= arraysize) throw \"subscript out of range\"; return data[n];&#125; 设函数为内联函数，好的实现在直接通过对象使用operator[]时不引入新开销 通过指针或引用调用operator[]的开销与三个内存引用相关: 对指针本身 为此成员函数初始化this指针 用于调用返回序列 调用虚函数则通常需要多出另外的三个内存应用: 从对象取出描述对象类型的表的地址值 取出虚函数的地址 在可能的较大外围对象中，取出本对象的偏移量 成员函数很大时，这样的开销远小于函数执行所需开销，额外的开销不成问题 一个潜在开销很大的例子及改进策略：1234567891011121314151617181920212223242526272829303132333435363738class InputBuffer &#123;public: //... virtual int get(); //...&#125;;// all derived class of InputBuffer can override get()int countlines(InputBuffer&amp; b) &#123; int n = 0; int c; // get() would be called a lot of times while ((c = b.get()) != EOF) &#123; if (c == '\\n') ++n; &#125; return n;&#125;// imroved versionclass InputBuffer &#123;public: //... int get() &#123; // call a virtual function only in specified condition if (next &gt;= limit) return refill(); return *next++; &#125;protected: // read in plenty of characters virtual int refill();private: char* next; char* limit;&#125;; 行为当派生类并不严格扩展基类行为时，成员函数定义为虚函数会导致不正确的结果 123456789101112131415161718192021222324class IntArray &#123;public: IntArray(unsigned); int&amp; operator[] (unsigned); unsigned size() const; //...&#125;;class IntBlock: public Int Array &#123;public: IntBlock(int l, int h): low(l), high(h), IntArray(l &gt; h ? 0 : h - l + 1) &#123;&#125; int&amp; operator[](int n) &#123; return IntArray::operator[](n - low); &#125;private: int low, high;&#125;;int sum(IntArray&amp; x) &#123; int result = 0; for (int i = 0; i &lt; x.size(); ++i) result += x[i]; return result;&#125; 当将一个实际类型为IntBlock的对象传给sum()时，只有operator[]为非虚函数才有正确的行为 有些函数只为特定有限制的用途而设计 类的接口可以有两种用户：使用该类对象的人和从这个类派生新类的人 有的类会故意不考虑其他人如何通过继承改变它的行为 虚析构函数 有需要自定义的析构函数 存在此种情形：指向基类的指针或引用都有其静态类型，并实际上都指向派生类的对象","categories":[],"tags":[]}]