<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>chenfeng&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="chenfeng's blog">
<meta property="og:url" content="https://chenfeng.github.io/index.html">
<meta property="og:site_name" content="chenfeng's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chenfeng's blog">
  
    <link rel="alternate" href="/atom.xml" title="chenfeng&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">chenfeng&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chenfeng.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-computer_network_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/10/computer_network_1/" class="article-date">
  <time datetime="2017-03-10T14:49:29.201Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><hr>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>连接到因特网的设备：主机(host)或端系统(end system)</p>
<p>端系统通过通信链路(communication link)和分组交换机(parket switch)连接到一起</p>
<p>路由器(router) 链路层交换机(link-layer switch)</p>
<p>端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网</p>
<p>因特网部件运行一系列协议(protocol),协议控制因特网中信息的接受和发送</p>
<ol>
<li><p>Reliable Stream Transport Service:<br>Sends a large amount of data across a reliable “connection”</p>
</li>
<li><p>Connectionless Packet Delivery Service:<br>Routes small messages from one computer to another</p>
</li>
</ol>
<p>TCP(Transmission Control Protocol, 传输控制协议)</p>
<p>IP(Internet Protocol, 网际协议)定义在路由器和端系统之间发送和接受的分组格式</p>
<p>因特网标准(Internet standard)由因特网工程任务组(Internet Engineering task Force, IETF)研发</p>
<p>IETF标准文档称请求评论(Request For Comment, RFC)</p>
<p>分布式应用程序(distributed application)涉及多台相互交换数据的端系统</p>
<p>应用程序编程接口(Application Programming Interface, API)</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>主机(hosts) = 端系统: 客户(client)和服务器(server)</p>
<p>数据中心(data center)由许多服务器构成</p>
<p>接入网(access network)指将端系统连接到其边缘路由器(edge router)的物理链路</p>
<ol>
<li>residential access nets</li>
<li>institutional access networks (school, company)</li>
<li>mobile access networks</li>
</ol>
<p>bandwidth(bit per second, bps); shared / dedicated(专用)</p>
<p>数字用户线(Digital Subscriber Line, DSL): </p>
<ul>
<li>existing telephone line to central office DSLAM</li>
<li>&lt; 2.5 Mbps upstream transmission rate (typically &lt; 1 Mbps)</li>
<li>&lt; 24 Mbps downstream transmission rate (typically &lt; 10 Mbps)</li>
<li>frequency division multiplexing: different channels transmitted<br>in different frequency bands</li>
</ul>
<p>电缆因特网接入(cable Internet access) 有线电视</p>
<p>HFC: hybrid fiber coax</p>
<ul>
<li>asymmetric: up to 30Mbps downstream transmission rate, 2 Mbps upstream transmission rate</li>
</ul>
<p>以太网Ethernet</p>
<p>光纤到户(Fiber To The Home, FTTH)</p>
<ul>
<li>光纤分布体系结构：主动光纤网络(Active Optical Network, AON)和被动光纤网络(Passive Optical Network, PON)</li>
</ul>
<p>光纤网络端接器(Optical Network Terminator, ONT)</p>
<p>分配器(splitter)</p>
<p>光纤线路端接器(Optical Line Terminator, OLT)</p>
<p>wireless network</p>
<p>wireless LANs:</p>
<ul>
<li>within building (100 ft.)</li>
<li>802.11b/g/n (WiFi): 11, 54, 450 Mbps transmission rate</li>
</ul>
<p>wide-area wireless access</p>
<ul>
<li>provided by telco (cellular) operator, 10’s km</li>
<li>between 1 and 10 Mbps </li>
<li>3G, 4G: LTE</li>
</ul>
<p>host sending function:</p>
<ul>
<li>takes application message</li>
<li>breaks into smaller chunks, known as packets, of length L bits</li>
<li>transmits packet into access network at transmission rate R</li>
<li>link transmission rate, aka link capacity, aka link bandwidth</li>
</ul>
<ul>
<li>物理媒体(physical medium): 双绞铜线、同轴电缆、多模光纤缆、陆地无线电频谱、卫星无线电频谱</li>
</ul>
<ul>
<li>bit: propagates between transmitter/receiver pairs</li>
<li>physical link: what lies between transmitter &amp; receiver</li>
</ul>
<p>导引型媒体(guided media): </p>
<ul>
<li>signals propagate in solid media: copper, fiber, coax</li>
</ul>
<p>非导引型媒体(unguided media): </p>
<ul>
<li>signals propagate freely, e.g., radio</li>
</ul>
<p>双绞铜线 twisted pair (TP): </p>
<ul>
<li>two insulated copper wires</li>
<li>Category 5: 100 Mbps, 1 Gbps Ethernet</li>
<li>Category 6: 10Gbps</li>
</ul>
<p>两根隔离的铜线以规则的螺旋形式排列组成；两根线绞合起来以减少邻近类似双绞线的电气干扰</p>
<p>一对电线构成一个通信链路；通常许多双绞线捆扎在一起成电缆</p>
<p>无屏蔽双绞线(Unshielded Twisted Pair, UTP) 常用于建筑物内网络</p>
<p>同轴电缆 coaxial cable: </p>
<ul>
<li>two concentric copper conductors</li>
<li>bidirectional</li>
<li>broadband:</li>
<li>multiple channels on cable</li>
<li>HFC</li>
</ul>
<p>光纤 fiber optic cable: </p>
<ul>
<li>glass fiber carrying light pulses, each pulse a bit</li>
<li>high-speed operation:<br>high-speed point-to-point transmission (e.g., 10’s-100’s Gbps transmission rate)</li>
<li>low error rate: </li>
</ul>
<ol>
<li>repeaters spaced far apart </li>
<li>immune to electromagnetic noise(不受电磁干扰)</li>
</ol>
<p>单模光纤速率高，价格贵; 多模光纤速率低，价格便宜</p>
<p>电磁波 ratio</p>
<ul>
<li>signal carried in electromagnetic spectrum</li>
<li>no physical “wire”</li>
<li>bidirectional</li>
<li>propagation environment effects:</li>
</ul>
<ol>
<li>reflection </li>
<li>obstruction by objects</li>
<li>interference</li>
</ol>
<p>adio link types:</p>
<ul>
<li>terrestrial  microwave<br>e.g. up to 45 Mbps channels</li>
<li>LAN (e.g., WiFi)<br>54 Mbps</li>
<li>wide-area (e.g., cellular)<br>4G cellular: ~ 10 Mbps</li>
<li>satellite</li>
</ul>
<ol>
<li>Kbps to 45Mbps channel (or multiple smaller channels)</li>
<li>270 msec end-end delay</li>
<li>geosynchronous versus low altitude</li>
</ol>
<p>同步卫星(geostationary satellite); 近地轨道(Low-Earth Orbiting, LEO)卫星</p>
<h3 id="编码-encoding"><a href="#编码-encoding" class="headerlink" title="编码(encoding)"></a>编码(encoding)</h3><p>Non-return to Zero Inverted (NRZI):</p>
<ul>
<li>make a transition from current signal to encode a one; stay at current signal to encode a zero</li>
<li>solves the problem of consecutive ones</li>
</ul>
<p>经网络传输数据会产生时钟同步问题</p>
<p>Manchester: </p>
<ul>
<li>transmit XOR of the NRZ encoded data and the clock</li>
<li>only 50% efficient (bit rate = 1/2 baud rate)</li>
</ul>
<p>包含丰富的时钟信息</p>
<p>4B/5B: </p>
<ul>
<li>every 4 bits of data encoded in a 5-bit code</li>
<li>5-bit codes selected to have no more than one leading 0 and no more than two trailing 0s </li>
<li>thus,  never get more than three consecutive 0s</li>
<li>resulting 5-bit codes are transmitted using NRZI </li>
<li>achieves 80% efficiency</li>
</ul>
<h3 id="数据帧化Framing"><a href="#数据帧化Framing" class="headerlink" title="数据帧化Framing"></a>数据帧化Framing</h3><ul>
<li>Break sequence of bits into a frame</li>
<li>Typically implemented by network adaptor</li>
</ul>
<p>Sentinel-based: </p>
<ul>
<li>delineate frame with special pattern: 01111110</li>
<li>e.g., HDLC, SDLC, PPP</li>
</ul>
<p>Beginning sequence(8) + Header(16) + Body + CRC(16) + Ending sequence(8)</p>
<ul>
<li>problem: special pattern appears in the payload</li>
<li>solution: bit stuffing</li>
<li>sender: insert 0 after five consecutive 1s</li>
<li>receiver: delete 0 that follows five consecutive 1s</li>
</ul>
<p>Counter-based: </p>
<ul>
<li>include payload length in header</li>
<li>e.g., DDCMP</li>
</ul>
<p>SYN(8) + SYN(8) + Class(8) + Count(14) + Header(42) + Body + CRC(16)</p>
<ul>
<li>problem: count field corrupted</li>
<li>solution: catch when CRC fails</li>
</ul>
<p>Clock-based: </p>
<ul>
<li>each frame is 125us long</li>
<li>e.g., SONET: Synchronous Optical Network</li>
<li>STS-n (STS-1 = 51.84 Mbps)</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>Communication networks can be classified based on the way in which the nodes exchange information:</p>
<p>Communication Network: </p>
<ul>
<li><p>Broadcast Communication Network</p>
</li>
<li><p>Switched Communication Network</p>
</li>
</ul>
<ol>
<li><p>Circuit-Switched Communication Network</p>
</li>
<li><p>Packet-Switched Communication Network</p>
</li>
</ol>
<ul>
<li>Datagram Network</li>
<li>Virtual Circuit Network</li>
</ul>
<h3 id="Connection-Oriented-面向连接"><a href="#Connection-Oriented-面向连接" class="headerlink" title="Connection Oriented(面向连接)"></a>Connection Oriented(面向连接)</h3><p>Has connection establish and release procedures</p>
<ul>
<li>Similar to circuit switched</li>
</ul>
<p>Transmission in order</p>
<p>Bandwidth <em>may</em> be guaranteed</p>
<p>Flow control <em>may</em> exist</p>
<p>Error control <em>may</em> exist</p>
<h3 id="Connectionless-无连接"><a href="#Connectionless-无连接" class="headerlink" title="Connectionless(无连接)"></a>Connectionless(无连接)</h3><p>Each datagram may take a different path</p>
<p>Datagrams may arrive out of order</p>
<p>Link failures not a problem</p>
<ul>
<li><p>problem in a Generic Switch</p>
</li>
<li><p>incoming links : how to demultiplex</p>
</li>
<li><p>switch : how to switch</p>
</li>
<li><p>outgoing links : how to multiplex</p>
</li>
</ul>
<h3 id="Packet-Switching-分组交换"><a href="#Packet-Switching-分组交换" class="headerlink" title="Packet Switching(分组交换)"></a>Packet Switching(分组交换)</h3><p>各种网络应用中，端系统彼此交换报文(message)</p>
<p>分组(packet swicth): 源端系统像目的端系统发送报文，源将报文划分为较小的数据块</p>
<p>每个分组通过通信链路和分组交换机(packet switch)传送</p>
<ul>
<li>两类交换机: 路由器和链路层交换机</li>
</ul>
<p>packet-switching:<br>hosts break application-layer messages into packets</p>
<p>Data from any conversation can be transmitted at any given time</p>
<ul>
<li>A single conversation can use the entire link capacity if it is alone</li>
</ul>
<p>How to demultiplex?</p>
<ul>
<li>Use meta-data (header) to describe data</li>
</ul>
<p>Data are sent as formatted bit-sequences</p>
<ul>
<li>so-called packets.</li>
</ul>
<p>Packets have the following structure:</p>
<ul>
<li>Header + Data + Tailer</li>
<li>Header and Trailer carry control information</li>
<li>e.g., destination address, check sum</li>
</ul>
<p>Store-and-Forward Networks(存储转发传输): </p>
<ul>
<li>At each node the entire packet is received, stored briefly, and </li>
<li>then forwarded to the next node based on the header information </li>
<li>Allows statistical(统计的) multiplexing</li>
</ul>
<p>在接收完所有的比特后进行查错，无误在再进行转发</p>
<p>“热土豆”传输: 一边接收，一边转发</p>
<ul>
<li>适用于网络质量好，出错概率低的情况</li>
</ul>
<p>通过N条速率均为R的链路组成的路径(源和目的地之间有N-1台路由器)发送一个分组，端到端时延: </p>
<p>$$d_{EndToEnd} = N \frac{L}{R}$$</p>
<p>takes L/R seconds to transmit </p>
<ul>
<li>L-bit packet into link at R bps</li>
</ul>
<p>one-hop numerical example:</p>
<ul>
<li>L = 7.5 Mbits</li>
<li>R = 1.5 Mbps</li>
<li>one-hop transmission delay = 5 sec</li>
</ul>
<p>packet-switching</p>
<ul>
<li>forward packets from one router to the next</li>
<li>across links on path from source to destination</li>
<li>Each packet is independently switched</li>
<li>header contains destination address</li>
</ul>
<ul>
<li>Two key network-core functions</li>
</ul>
<ol>
<li>routing: determines source-destination route taken by packets</li>
</ol>
<ul>
<li>routing algorithms</li>
</ul>
<ol>
<li>forwarding: move packets from router’s input to appropriate router output</li>
</ol>
<p>输出缓存(output buffer)(输出队列 output queue):<br>用于存储路由器准备发往相连的链路的分组;</p>
<p>排队时延(queue delay):<br>到达的分组在链路忙于传输其他分组时必须在输出缓存中等待;</p>
<p>分组丢失(丢包 packet lost):<br>一个分组到达时缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃</p>
<p>queuing and loss: </p>
<ul>
<li>if arrival rate exceeds transmission rate of link for a period of time</li>
<li>packets will queue, wait to be transmitted on link </li>
<li>can be dropped (lost) if memory (buffer) fills up</li>
</ul>
<h3 id="Circuit-Switching-电路交换"><a href="#Circuit-Switching-电路交换" class="headerlink" title="Circuit Switching(电路交换)"></a>Circuit Switching(电路交换)</h3><p>两台主机通信时网络在两台主机之间创建一条专用的端到端连接(end-to-end connection)</p>
<p>频分复用(Frequency-Division Multiplexing, FDM):<br>链路的频谱由跨越链路创建的所有连接所共享; 在连接期间链路为每条连接专用一个频段</p>
<p>时分复用(Time-Division Multiplexing, TDM):<br>时间被划分为固定区间的帧(frame)，每帧划分为固定数量的时隙;<br>网络跨越一条链路创建一条连接时在每个帧中为该连接指定一个时隙(slot)</p>
<p>Time divided in frames and frames divided in slots</p>
<p>Relative slot <strong>position</strong> inside a frame determines which conversation the data belongs to </p>
<p>Needs <strong>synchronization</strong>(同步) between sender and receiver</p>
<p>If a conversation does not use its circuit the capacity is lost</p>
<p>Three phases(三个阶段)</p>
<ol>
<li>circuit establishment</li>
<li>data transfer</li>
<li>circuit termination</li>
</ol>
<p>If circuit not available: busy</p>
<p>Examples</p>
<ul>
<li>Telephone networks</li>
<li>ISDN (Integrated Services Digital Networks)(综合业务数字网)</li>
</ul>
<p>end-end resources allocated to, reserved for “call” between source &amp; dest</p>
<p>dedicated resources: no sharing</p>
<ul>
<li>circuit-like (guaranteed) performance</li>
</ul>
<p>circuit segment idle(闲置) if not used by call (no sharing)</p>
<h3 id="Packet-Switching-vs-Circuit-Switching"><a href="#Packet-Switching-vs-Circuit-Switching" class="headerlink" title="Packet-Switching vs. Circuit-Switching"></a>Packet-Switching vs. Circuit-Switching</h3><p>Most important advantage of packet-switching: </p>
<ul>
<li>Ability to exploit statistical multiplexing</li>
<li>More efficient bandwidth usage</li>
</ul>
<p>However, packet-switching needs to buffer and deal with congestion</p>
<ul>
<li>More complex switches</li>
<li>Harder to provide good network services (e.g., delay and bandwidth guarantees)</li>
</ul>
<p>packet switching allows more users to use network</p>
<p>example:</p>
<ul>
<li>1 Mb/s link<br>each user: </li>
<li>100 kb/s when “active”</li>
<li><p>active 10% of time</p>
</li>
<li><p>circuit-switching: 10 users</p>
</li>
<li>packet switching: with 35 users, probability &gt; 10 active at same time is less than .0004 *</li>
</ul>
<p>packet switching: </p>
<p>great for bursty data</p>
<ul>
<li>resource sharing</li>
<li>simpler, no call setup</li>
</ul>
<p>excessive congestion possible: </p>
<ul>
<li>packet delay and loss</li>
<li>protocols needed for reliable data transfer, congestion control</li>
</ul>
<p>Q: How to provide circuit-like behavior?</p>
<ul>
<li>bandwidth guarantees needed for audio/video apps</li>
</ul>
<h3 id="Virtual-Circuit-Packet-Switching-虚电路交换"><a href="#Virtual-Circuit-Packet-Switching-虚电路交换" class="headerlink" title="Virtual-Circuit Packet Switching(虚电路交换)"></a>Virtual-Circuit Packet Switching(虚电路交换)</h3><p>Hybrid of circuit switching and packet switching</p>
<ul>
<li>Data is transmitted as packets</li>
<li>All packets from one packet stream are sent along a pre-established path (=virtual circuit)</li>
<li>Guarantees in-sequence delivery of packets</li>
</ul>
<p>Packet header only contains local virtual circuit identifier (VCI)</p>
<p>Demultiplexing and switching based on VCI</p>
<ul>
<li>Note: packet headers don’t need to contain the full destination address of the packet </li>
</ul>
<p>Example: ATM networks</p>
<p>Communication with virtual circuits takes place in three phases </p>
<ol>
<li>VC establishment</li>
<li>data transfer</li>
<li>VC disconnect</li>
</ol>
<h3 id="Internet-structure-network-of-networks-网络的网络"><a href="#Internet-structure-network-of-networks-网络的网络" class="headerlink" title="Internet structure: network of networks(网络的网络)"></a>Internet structure: network of networks(网络的网络)</h3><p>End systems connect to Internet via access ISPs (Internet Service Providers)</p>
<ul>
<li>residential, company and university ISPs</li>
</ul>
<p>Access ISPs in turn must be interconnected. </p>
<ul>
<li>so that any two hosts can send packets to each other</li>
</ul>
<p>Resulting network of networks is very complex</p>
<ul>
<li>evolution was driven by economics and national policies</li>
</ul>
<p>Question: given millions of access ISPs, how to connect them together?<br>Option: connect each access ISP to every other access ISP?<br>Option: connect each access ISP to one global transit ISP? </p>
<ul>
<li>Customer and provider ISPs have economic agreement.</li>
</ul>
<p>at center: small # of well-connected large networks</p>
<ul>
<li>“tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), national &amp; international coverage</li>
<li>content provider network (e.g., Google): private network that connects it data centers to Internet, often bypassing tier-1, regional ISPs</li>
</ul>
<h2 id="分组交换网中的时延、丢包和吞吐量-delay-loss-throughput-in-networks"><a href="#分组交换网中的时延、丢包和吞吐量-delay-loss-throughput-in-networks" class="headerlink" title="分组交换网中的时延、丢包和吞吐量(delay, loss, throughput in networks)"></a>分组交换网中的时延、丢包和吞吐量(delay, loss, throughput in networks)</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>结点处理时延(nodal processing delay): 检查分组首部和决定出口链路、查错校验</p>
<p>排队时延(queuing delay): 分组在出口链路队列上等待传输</p>
<p>传输时延(transmission delay): L/R(分组长度/链路传输速率); 将所有分组比特推(传输)向链路所需时间</p>
<p>传播时延(propagation delay): d/s(距离/传播速率)，介质相关</p>
<p>结点总时延(total nodal delay)</p>
<p>$$d<em>{nodal} = d</em>{proc} + d<em>{queue} + d</em>{trans} + d_{prop}$$</p>
<p>How do loss and delay occur:<br>packets queue in router buffers </p>
<ul>
<li>packet arrival rate to link (temporarily) exceeds output link capacity</li>
<li>packets queue, wait for turn</li>
</ul>
<p>$d_{proc}$: nodal processing </p>
<ul>
<li>check bit errors</li>
<li>determine output link</li>
<li>typically &lt; msec</li>
</ul>
<p>$d_{queue}$: queueing delay</p>
<ul>
<li>time waiting at output link for transmission </li>
<li>depends on congestion level of router</li>
</ul>
<p>$d_{trans}$: transmission delay</p>
<ul>
<li>L: packet length (bits) </li>
<li>R: link bandwidth (bps)</li>
<li>$d_{trans} = L/R$</li>
</ul>
<p>$d_{prop}$: propagation delay</p>
<ul>
<li>d: length of physical link</li>
<li>s: propagation speed (~2x108 m/sec)</li>
<li>$d_{prop} = d/s$</li>
</ul>
<p>$d<em>{trans}$ and $d</em>{prop}$ are very different</p>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>流量强度(traffic intensity): La/R; </p>
<ul>
<li>a: 分组到达队列的平均速率(pkt/s)(a: average packet arrival rate)</li>
<li>R: link bandwidth (bps)</li>
<li><p>L: packet length (bits)</p>
</li>
<li><p>La/R ~ 0: avg. queueing delay small</p>
</li>
<li>La/R -&gt; 1: avg. queueing delay large</li>
<li>La/R &gt; 1: more “work” arriving<br> than can be serviced, average delay infinite!</li>
</ul>
<ul>
<li>设计系统时流量强度不能大于1</li>
</ul>
<p>随着流量强度接近于1，平均排队时延迅速增加</p>
<p>丢包: 分组到达时路由器链路队列已满，路由器丢弃(drop)该分组，该分组会丢失(lost)</p>
<ul>
<li>queue (aka buffer) preceding link in buffer has finite capacity</li>
<li>packet arriving to full queue dropped (aka lost)</li>
<li>lost packet may be retransmitted by previous node, by source end system, or not at all</li>
</ul>
<h3 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h3><p>瞬时吞吐量(instantaneous throughput): 主机接收到文件的速率(bps)</p>
<p>平均吞吐量(average throughput): F/T秒; 接收总共F比特用去T秒</p>
<p>瓶颈链路(bottleneck link): 系统中传输速率最小的链路</p>
<p>throughput: rate (bits/time unit) at which bits transferred between sender/receiver</p>
<ul>
<li>instantaneous: rate at given point in time</li>
<li>average: rate over longer period of time</li>
</ul>
<p>bottleneck link:<br>link on end-end path that constrains end-end throughput</p>
<h2 id="协议层次-服务模型-protocol-layers-service-models"><a href="#协议层次-服务模型-protocol-layers-service-models" class="headerlink" title="协议层次 服务模型(protocol layers, service models)"></a>协议层次 服务模型(protocol layers, service models)</h2><p>分层(layer)</p>
<p>layers: each layer implements a service</p>
<ul>
<li>via its own internal-layer actions</li>
<li>relying on services provided by layer below</li>
</ul>
<p>协议栈(protocol stack)</p>
<p>应用层(第七层): <http、smtp、ftp、dns...> 报文(message)</http、smtp、ftp、dns...></p>
<p>运输层(四层): <tcp udp=""> 报文段(segment)</tcp></p>
<p>网络层(三层): <ip>数据报(datagram)</ip></p>
<p>链路层(二层): 帧(frame)</p>
<p>物理层(一层): 将帧中的比特一个一个从一个结点移动到下一个结点</p>
<p>OSI(Open System Interconnect Reference Model, 开放系统互联参考模型)</p>
<p>表示层: 数据压缩、数据加密、数据描述</p>
<p>会话层: 数据交换定界、同步功能，建立检查点和恢复方案</p>
<p>Internet protocol stack: </p>
<p>application: supporting network applications</p>
<ul>
<li>FTP, SMTP, HTTP</li>
</ul>
<p>transport: process-process data transfer</p>
<ul>
<li>TCP, UDP</li>
</ul>
<p>network: routing of datagrams from source to destination</p>
<ul>
<li>IP, routing protocols</li>
</ul>
<p>link: data transfer between neighboring  network elements</p>
<ul>
<li>Ethernet, 802.111 (WiFi), PPP</li>
</ul>
<p>physical: bits “on the wire</p>
<p>ISO/OSI reference model: (two more layer)</p>
<ul>
<li><p>presentation: allow applications to interpret meaning of data, e.g., encryption, compression, machine-specific conventions</p>
</li>
<li><p>session: synchronization, checkpointing, recovery of data exchange<br>Internet stack “missing” these layers!</p>
</li>
<li><p>these services, if needed, must be implemented in application</p>
</li>
</ul>
<p>封装(encaosulation)</p>
<p>应用层报文(application-layer message) -&gt; 运输层报文段(transport-layer segment) -&gt; 网络层数据报(network-layer datagram) -&gt; 链路层帧(link-layer frame)</p>
<p>分组 : 首部字段 + 有效载荷字段(payload field)(来自上一层的分组)</p>
<h2 id="面对攻击的网络-networks-under-attack-security"><a href="#面对攻击的网络-networks-under-attack-security" class="headerlink" title="面对攻击的网络(networks under attack: security)"></a>面对攻击的网络(networks under attack: security)</h2><p>Internet not originally designed with (much) security in mind</p>
<ul>
<li>original vision: “a group of mutually trusting users attached to a transparent network” </li>
<li>Internet protocol designers playing “catch-up”</li>
<li>security considerations in all layers!</li>
</ul>
<p>恶意软件(malware)</p>
<p>僵尸网络(botnet)</p>
<p>病毒(virus): 需要某种形式的用户交互感染用户设备的恶意软件</p>
<p>蠕虫(worm): 无需任何明显用户交互就能进入设备的恶意软件</p>
<p>malware can get in host from:</p>
<ul>
<li>virus: self-replicating infection by receiving/executing object (e.g., e-mail attachment)</li>
<li>worm: self-replicating infection by passively receiving object that gets itself executed</li>
</ul>
<p><strong>spyware malware</strong> can record keystrokes, web sites visited, upload info to collection site</p>
<p>infected host can be enrolled in <strong>botnet</strong>, used for spam. DDoS attacks</p>
<p>拒绝服务攻击(Denial-of-Service (DoS) attack)</p>
<ul>
<li>弱点攻击: 向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</li>
<li>带宽洪泛: 向目标主机发送大量的分组使目标接入链路拥塞</li>
<li>连接洪泛: 在目标主机中创建大量半开或全开TCP连接</li>
</ul>
<p>分布式Dos(Distributed DoS, DDoS): 攻击者控制多个源向目标发送大量流量</p>
<p>Denial of Service(DoS): attackers make resources (server, bandwidth) unavailable to legitimate traffic by overwhelming resource with bogus traffic</p>
<ol>
<li><p>select target</p>
</li>
<li><p>break into hosts around the network (see botnet)</p>
</li>
<li><p>send packets to target from compromised hosts</p>
</li>
</ol>
<p>分组嗅探器(packet sniffer)</p>
<p>packet “sniffing”: </p>
<ul>
<li>broadcast media (shared Ethernet, wireless)</li>
<li>promiscuous network interface reads/records all packets (e.g., including passwords!) passing by</li>
<li>wireshark software is a (free) packet-sniffer</li>
</ul>
<p>IP哄骗(IP spooning)</p>
<p>IP spoofing: send packet with false source address</p>
<hr>
<p>~ history</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/10/computer_network_1/" data-id="cj04jtwcx000060q14fbxm6g9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-economics/经济学基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/economics/经济学基础知识/" class="article-date">
  <time datetime="2017-03-08T04:10:41.266Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="经济学基础知识"><a href="#经济学基础知识" class="headerlink" title="经济学基础知识"></a>经济学基础知识</h1><p>标签： 微观经济学</p>
<hr>
<p>研究一个社会如何利用<strong>稀缺</strong>资源生产有价值的物品和劳务并将它们在不同人中间进行分配。</p>
<ul>
<li>物品和资源是稀缺的</li>
<li>社会必须有效地加以利用</li>
</ul>
<p>稀缺(sarcity)：相对于需求，物品总是有限的</p>
<p>效率(efficiency)：最有效地使用社会资源以满足人类的愿望和需要</p>
<h3 id="经济学逻辑"><a href="#经济学逻辑" class="headerlink" title="经济学逻辑"></a>经济学逻辑</h3><ul>
<li><p>后此谬误(the post hoc fallacy)<br>仅仅因为一件事发生在另一件事之前就想当然地认为前者是后者的原因</p>
</li>
<li><p>不能保持其他条件不变(failure to hold other things constant)<br>考虑某一问题是没能保持其他相关条件不变</p>
</li>
<li><p>合成谬误(the fallacy of composition)<br>认为对局部成立的东西对总体也必然成立</p>
</li>
</ul>
<h3 id="经济组织三个经济问题"><a href="#经济组织三个经济问题" class="headerlink" title="经济组织三个经济问题"></a>经济组织三个经济问题</h3><p>基本经济问题：</p>
<p>生产什么(什么商品和多少)；</p>
<p>如何生产；</p>
<p>为谁生产(谁享用经济活动的成果)</p>
<p><em>实证经济学(positive economics)：讨论经济社会的事实</em><br><em>规范经济学(normative economics)：提出价值判断，涉及伦理信条(应当是什么)</em></p>
<ul>
<li>市场经济(market economy):<br>主要由个人和私人企业决定生产和消费的经济制度</li>
</ul>
<p>极端情况：自由放任(lasse-faire)经济</p>
<ul>
<li>指令经济(command economy):<br>由政府做出有关生产和分配的所有重大决策</li>
</ul>
<p>政府通过它的资源所有权和实施经济政策的权力解答基本的经济问题</p>
<ul>
<li>混合经济(mixed economy):<br>既带有市场经济的成分又带有指令经济的成分</li>
</ul>
<h3 id="社会的技术可能性"><a href="#社会的技术可能性" class="headerlink" title="社会的技术可能性"></a>社会的技术可能性</h3><ul>
<li>投入和产出<br>投入(inputs):指生产物品和劳务的过程中所使用的物品和劳务</li>
</ul>
<p>产出(outputs):指生产过程中创造的各种有用的物品和劳务，可用于消费或进一步生产</p>
<p>投入也称生产要素(factors of production)，划分成三大基本范畴</p>
<ol>
<li>土地(自然资源)，生产过程中大自然所赋予的</li>
<li>劳动，人们花费在生产过程中的时间和精力</li>
<li>资本资源，一个经济体为了生产其他的物品而生产出来的耐用品</li>
</ol>
<ul>
<li>生产可能性边界(production-possibility frontier, PPF)<br>表示在技术知识和可投入品数量既定的条件下，一个经济体所能得到的最大产量。</li>
</ul>
<p>PPF代表可供社会利用的物品和劳务的不同组合。</p>
<p>生产可能性边界说明许多基本的经济过程：</p>
<ol>
<li>经济增长将边界向外推移(生产潜能的增长)</li>
<li>贫穷的国家必须将其大部分资源用于生产食品；富裕的国家能生产出更多奢侈品</li>
<li>贫穷的国家仅仅能承担很少的公共品；随着经济增长公共品及环境质量占产出量的比重势必加大</li>
<li>通过牺牲现在消费和生产更多的资本品，一国经济能更快速增长使未来有可能生产出更多两种物品</li>
</ol>
<ul>
<li><p>机会成本(opportunity cost)<br>在存在稀缺的社会上，选择一种东西意味着需要放弃其他一些东西；<br>一项选择的机会成本是相应的所放弃的物品和劳务的价值。</p>
</li>
<li><p>效率</p>
</li>
</ul>
<p>有效率的生产(productive efficiency)必然位于生产可能性边界上；<br>经济体无法在不减少一种物品产量的前提下生产出更多的另一种产品。</p>
<p>生产可能性边界表示社会为人们提供的各种选择</p>
<ul>
<li>未利用资源和无效率</li>
</ul>
<p>经济体中存在着未利用的资源(失业的劳动者、闲置的工厂、废弃的土地等)时，<br>不可能处于生产可能性边界上，而是处于其边界之内的某个位置。</p>
<p>无资源的根源：商业周期(周期性经济危机)、罢工、政治动乱、革命等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/economics/经济学基础知识/" data-id="cj04jtwfl000d60q13gtpend6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-economics/现代经济中的市场和政府" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/economics/现代经济中的市场和政府/" class="article-date">
  <time datetime="2017-03-08T04:10:41.265Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="现代经济中的市场和政府"><a href="#现代经济中的市场和政府" class="headerlink" title="现代经济中的市场和政府"></a>现代经济中的市场和政府</h1><p>标签：微观经济学</p>
<hr>
<h3 id="什么是市场"><a href="#什么是市场" class="headerlink" title="什么是市场"></a>什么是市场</h3><ul>
<li><p>市场(market)是买者和卖者相互作用并共同决定商品和劳务的价格和交易数量的机制</p>
</li>
<li><p>在市场中，是价格在协调生产者和消费者的决策。较高的价格趋于抑制消费者购买，<br>同时会刺激生产；而较低的价格则鼓励消费，同时抑制生产。价格(price)在市场机制<br>中起着平衡的作用</p>
</li>
<li><p>市场不断地解决生产什么、如何生产和为谁生产的问题，当平衡了所有影响经济的力量<br>时，市场就达到了供给和需求的市场均衡(market equilibrium of supply and demand)。</p>
</li>
<li><p>市场均衡代表了所有不同的买者和卖者之间的一种平衡。在某一价格水平上，买者所愿<br>意购买的数量正好等于卖者所愿意出售的数量，这一价格就达成了供给和需求的均衡。</p>
</li>
<li><p>市场如何解决三大经济问题</p>
</li>
</ul>
<ol>
<li><p>生产什么商品和劳务取决于消费者的货币选票——每天的购买决策。企业会受到利润<br>(profit，净收益，等于总销售额和总成本之间的差额)最大化愿望的驱使。</p>
</li>
<li><p>如何生产取决于不同生产者之间的竞争。生产者的最佳方法是采用效率最高的生产<br>技术以将成本降到最低点。</p>
</li>
<li><p>为谁生产主要取决于生产要素市场上的供给与需求。要素市场决定了工资、地租、利<br>息和利润的水平(要素价格)。收入在消费者之间的分配取决于他们所拥有的要素的数量和<br>价格。</p>
</li>
</ol>
<ul>
<li><p>经济的核心控制者是偏好和技术。消费者根据自己先天或后天的偏好(并以其货币选票<br>加以表达)解决社会资源的最终用途，即在生产可能性边界上的各个点之间作决定。</p>
</li>
<li><p>可供利用的资源和技术对消费者的选择构成了一种基本的约束，经济不能超越于它的生<br>产可能性边界。经济资源与可供利用的科学技术加在一起，限定了消费者花钱消费的对象</p>
</li>
</ul>
<ul>
<li><p>追逐个人利益的结果，是经常地增进社会的利益，其效果要比真的想要增进社会的利益<br>时更好。(“看不见的手”在引导)(亚当·斯密《国富论》)</p>
</li>
<li><p>在一定条件下，完全竞争经济是有效率的(经济效率指的是无法在不损害其他人经济福<br>利的前提下增进某个人的经济福利)</p>
</li>
<li><p>市场不灵的一种情况是垄断以及其他形式的不完全竞争。</p>
</li>
<li><p>第二种不灵表现为市场的外溢效果或外部性：正面的外部性包括科学发现等，而负面的<br>外溢效果应包括环境污染。</p>
</li>
<li><p>市场的收入分配的后果在政治上或道义上时无法接受的。</p>
</li>
</ul>
<h3 id="贸易、货币和资本"><a href="#贸易、货币和资本" class="headerlink" title="贸易、货币和资本"></a>贸易、货币和资本</h3><ul>
<li><p>发达经济以细密的贸易网络(基于大量的专业化和精细的劳动分工)为特征</p>
</li>
<li><p>当今的经济都大量使用货币(支付手段)</p>
</li>
<li><p>现代工业技术依赖于大规模的资本运用: 精密的机器、大型的工厂和库存</p>
</li>
</ul>
<ul>
<li><p>贸易、专业化和劳动分工</p>
</li>
<li><p>专业化是指让个人或国家各自集中精力去完成某一种(或一系列)任务，使得每个人或<br>国家都能够发挥其特殊技能和资源优势</p>
</li>
<li><p>发达经济致力于专业化和劳动分工，因而能提高其资源的生产率。个人和国家用自己专<br>业化生产的物品自愿地交换其他人的产品，能极大地增加消费品的范围和数量，并提高每<br>个人的生活水平。</p>
</li>
</ul>
<ul>
<li><p>货币(money)是一种支付手段或交换媒介，即购物时所支付的现金和支票。</p>
</li>
<li><p>货币是供应适度是各国宏观经济政策的主要任务之一。</p>
</li>
</ul>
<ul>
<li><p>资本(capital)，一种被生产出来的要素，一种本身就是由经济过程产出的耐用的投<br>入品</p>
</li>
<li><p>三大生产要素：资本、土地和劳动。</p>
</li>
<li><p>基本生产要素：土地和劳动，其供给主要取决于非经济要素。</p>
</li>
<li><p>资本使用之前必须首先被生产出来。资本在本质上意味着时间的耗费和间接的生产手<br>段。</p>
</li>
<li><p>靠牺牲当前消费而获得的增长 许多经济活动都涉及到放弃现时消费以增加资本，提高<br>经济未来的生产率，进而增加未来的消费</p>
</li>
</ul>
<ul>
<li><p>资本和私有财产</p>
</li>
<li><p>在市场经济中资本主要归私人拥有，从投资中得到的收益也归个人所有</p>
</li>
<li><p>产权赋予资本使用者使用、交换、装修、挖掘、钻探等利用其资本品的权利</p>
</li>
<li><p>个人占有资本并能从中获取利润，是资本主义的实质之所在</p>
</li>
<li><p>最有价值的经济资源，即劳动，不能像私人财产那样成为可以买卖的商品。人不能自由<br>地卖出自己，只能在某个工资价位上将自己租借出去</p>
</li>
</ul>
<h3 id="政府的经济职能"><a href="#政府的经济职能" class="headerlink" title="政府的经济职能"></a>政府的经济职能</h3><ul>
<li><p>现实世界中还不曾有一种经济能够完全依照“看不见的手”的原则而顺利地运行</p>
</li>
<li><p>政府对市场经济主要行使三项职能：提高效率、增进公平以及促进宏观经济的稳定与<br>增长</p>
</li>
</ul>
<ol>
<li><p>政府通过促进竞争、控制诸如污染这类外部性问题，以及提供公共品等活动来提高经济<br>效率</p>
</li>
<li><p>政府通过财政税收和预算支出等手段，向某些团体进行有倾斜的收入再分配，从而增进<br>公平</p>
</li>
<li><p>政府通过财政政策和货币政策促进宏观经济的稳定和增长，在鼓励经济增长的同时减少<br>失业和降低通货膨胀</p>
</li>
</ol>
<ul>
<li><p>效率</p>
</li>
<li><p>只有在完全竞争成立时，市场机制的优点才能充分体现出来</p>
</li>
<li><p>完全竞争(perfect competition)指的是所有的物品和劳务都有一个价格并都在市场上<br>交易。意味着没有一家企业或一位消费者足以影响整个市场的价格</p>
</li>
<li><p>不完全竞争(imperfect competition)，当买者或卖者能够左右一种商品的价格时；<br>社会的产出将会从生产可能性边界上移至边界之内，物品的产出就会低于有效率的水平。</p>
</li>
<li><p>不完全竞争导致价格高于成本，消费者购买量低于效率水平。过高的价格和过低的产出<br>是伴随不完全竞争而来的非效率的标志</p>
</li>
<li><p>不完全竞争的极端情况是垄断，唯一的卖者独自决定某种物品或劳务的价格水平</p>
</li>
</ul>
<ul>
<li><p>外部性(溢出效应)</p>
</li>
<li><p>外部性(externalities)指的是企业或个人向市场之外的其他人所强加的成本或效益</p>
</li>
<li><p>一个行动可能在市场交易之外有助于或有损于其他人的利益，也即存在着根本不发生经<br>济支付的经济交易</p>
</li>
<li><p>负的外部性已逐渐由微小的麻烦变成巨大的威胁，是政府进行干预的地方。</p>
</li>
</ul>
<ul>
<li><p>公共品</p>
</li>
<li><p>正外部性的极端情况是公共品</p>
</li>
<li><p>公共品(public goods)指一类商品：将该商品的效用扩展与他人的成本为零(非相克<br>性)；无法排除他人参与共享(非相斥性)。</p>
</li>
<li><p>税收：政府对个人和公司的收入、工资、消费品销售额和其他项目所征收的税款。政府<br>的收入来源，以提供公共品和实施收入再分配计划</p>
</li>
</ul>
<ul>
<li><p>公平</p>
</li>
<li><p>市场并不必然能够带来公平的收入分配。市场经济可能会产生令人难以接受的收入水平<br>和消费水平的巨大差异</p>
</li>
<li><p>收入取决于一系列因素，包括努力程度、教育、继承权、要素价格和运气；由此导致的<br>收入分配可能会同公平的结果相悖</p>
</li>
<li><p>物品追随的是货币选票而不是最大满足</p>
</li>
<li><p>累进税</p>
</li>
<li><p>转移支付，帮助根本没有收入的人</p>
</li>
</ul>
<ul>
<li><p>宏观经济增长与稳定</p>
</li>
<li><p>资本主义自产生以来不时地受通货膨胀(价格上升)和萧条(高失业率)的周期性困扰。这<br>些波动被称为商业周期。</p>
</li>
<li><p>通过审慎地运用财政和货币政策，政府能够影响产出、就业和通货膨胀的水平</p>
</li>
<li><p>政府的财政政策是税收权力和预算支出权力</p>
</li>
<li><p>货币政策涉及到货币供应量和利率水平， 进而影响到资本品的投资和其他利率敏感性<br>的支出(影响利率和信贷条件)</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/economics/现代经济中的市场和政府/" data-id="cj04jtwf7000c60q129f9q7jf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-economics/宏观经济现象鸟瞰" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/economics/宏观经济现象鸟瞰/" class="article-date">
  <time datetime="2017-03-08T04:10:41.265Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="宏观经济现象鸟瞰"><a href="#宏观经济现象鸟瞰" class="headerlink" title="宏观经济现象鸟瞰"></a>宏观经济现象鸟瞰</h1><p>标签： 宏观经济学</p>
<hr>
<h2 id="三个重要的宏观经济变量"><a href="#三个重要的宏观经济变量" class="headerlink" title="三个重要的宏观经济变量"></a>三个重要的宏观经济变量</h2><ul>
<li><p>实际国内生产总值(real GDP<gross domestic="" product="">):<br>经济体内所有人的实际总收入。<br>人均国内生产总值(GDP per capita): 经济体内平均而言每个人的实际收入。</gross></p>
</li>
<li><p>通货膨胀率(inflation rate):<br>物价水平变动的百分比。(物价指数)<br>用消费者价格指数(consumer price index, CPI)或GDP缩减指数(GDP deflator index)<br>衡量。</p>
</li>
<li><p>失业率(unemployment rate):<br>经济体中没有工作当正在积极找工作的劳动力比重。</p>
</li>
</ul>
<h3 id="GDP：衡量经济活动创造的价值"><a href="#GDP：衡量经济活动创造的价值" class="headerlink" title="GDP：衡量经济活动创造的价值"></a>GDP：衡量经济活动创造的价值</h3><p>经济体在既定时期内生产的所有的最终产品和服务的当期市场总值</p>
<ul>
<li>核算GDP三种方法</li>
</ul>
<ul>
<li>生产法<br>把GDP作为经济体里当期所生产的最终产品与服务的总值</li>
<li>收入法<br>把GDP作为经济体中所有人的总收入<br>国内顾客的购买总值=企业的总收益=工资+资本所得+中间投入品的购买<br>最终消费=增加值=工资+资本所得<br>(in China)增加值=劳动者报酬+生产税净额+固定资产折旧+营业盈额</li>
<li>支出法<br>把GDP作为经济体里对产品与服务的总支出<br>Y=C+I+G(GDP、消费、投资、政府购买)<br>开放经济条件下Y=Cd+Id+Gd+EX<br>(国内产品和服务的消费、国内产品和服务的投资、国内产品和服务的政府采购、国内产品和服务的出口)<br>国外产品和服务的消费Cf=C-Cd<br>国外产品和服务的投资If=I-Id<br>国外产品和服务的政府采购Gf=G-Gd<br>国外产品和服务的进口IM=Cf+If+Gf<br>净出口(net export)NEX=EX-IM<br>国民经济核算表达式Y=C+I+G+NEX</li>
</ul>
<ul>
<li>国民生产总值(gross national product,GNP)<br>一国居民在一个既定时期内所获得的总收入<br>GNP=GDP+来自国外的生产要素收入-对国外的生产要素支付</li>
</ul>
<h3 id="物价水平：衡量生活费用"><a href="#物价水平：衡量生活费用" class="headerlink" title="物价水平：衡量生活费用"></a>物价水平：衡量生活费用</h3><p>通货膨胀：物价水平上升</p>
<ul>
<li>消费者价格指数(CPI)<br>最常用的度量物价水平的指标</li>
</ul>
<ol>
<li>选定一个开始时期(基期)</li>
<li>选定一个<em>典型消费者</em>所购买的一篮子产品和服务的种类和数量</li>
<li>计算每一期购买同样一篮子产品和服务的支出</li>
<li>计算每一期的CPI(CPI=当期与基期一篮子产品和服务支出的<strong>比值</strong>)</li>
</ol>
<p>通货膨胀率 = (CPI(后一期)-CPI(前一期))/CPI(前一期)</p>
<ul>
<li>生产者价格指数(producer price index, PPI)<br>度量物价水平的另一指标</li>
</ul>
<ul>
<li><em>典型生产者</em>购买的一篮子产品和服务</li>
</ul>
<ul>
<li>GDP缩减指数</li>
</ul>
<p>名义GDP(nominal GDP)：按照当期价格度量的GDP<br>实际GDP(real GDP)：按照不变价格度量的GDP(尽可能反映经济体生产能力的变化)</p>
<p>GDP缩减指数=名义GDP/实际GDP * 100%</p>
<p>名义GDP剔除通货膨胀的影响得到实际GDP</p>
<h3 id="失业率：度量经济体痛苦程度"><a href="#失业率：度量经济体痛苦程度" class="headerlink" title="失业率：度量经济体痛苦程度"></a>失业率：度量经济体痛苦程度</h3><p>就业：在一定年龄段的经济活动主体从事有报酬的活动</p>
<p>失业者：有劳动能力并愿意就业但找不到工作的经济活动主体</p>
<ul>
<li>劳动力人口 = 劳动年龄(16~65)人口 - 不在劳动力(not in labor force)人口</li>
<li>劳动参与率 = 劳动力人口 / 劳动年龄人口</li>
<li>失业率 = 失业人口 / 劳动力人口</li>
</ul>
<ul>
<li>测算失业人口两种方法</li>
</ul>
<ul>
<li>收集失业者在劳动行政部门申报的数据<br>大多数失业者有申报动机：失业申报可以领取失业救济金、获得再就业信息等</li>
<li>定期抽样调查估计失业人口</li>
</ul>
<h2 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a>数据查找</h2><ul>
<li>中国国家统计局网站 <a href="http://www.stats.gov.cn" target="_blank" rel="external">http://www.stats.gov.cn</a></li>
<li><p>中国经济学教育科研网 <a href="http://www.cenet.org.cn/cn/" target="_blank" rel="external">http://www.cenet.org.cn/cn/</a></p>
</li>
<li><p>美国 总统经济报告 www.access.gpo.gov/eop/</p>
</li>
<li><p>美国统计概要 www.census.gov/compendia/statab</p>
</li>
<li><p>经济合作与发展组织 www.oecd.org</p>
</li>
<li>宾夕法尼亚大学国际比较中心 <a href="http://pwt.econ.upenn.edu/" target="_blank" rel="external">http://pwt.econ.upenn.edu/</a></li>
<li>哈佛商学院宏观经济学资源网站 www.hbs.edu/units/bgie/internet</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/economics/宏观经济现象鸟瞰/" data-id="cj04jtwf5000b60q1853484ra" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-economics/宏观经济学鸟瞰" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/economics/宏观经济学鸟瞰/" class="article-date">
  <time datetime="2017-03-08T04:10:41.265Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="宏观经济学鸟瞰"><a href="#宏观经济学鸟瞰" class="headerlink" title="宏观经济学鸟瞰"></a>宏观经济学鸟瞰</h1><p>标签：宏观经济学</p>
<hr>
<ul>
<li><p>研究对象：整体经济行为</p>
</li>
<li><p>个体行为的总体成果</p>
</li>
<li><p>不是研究特定部门或特定经济活动主体的行为</p>
</li>
<li><p>经济生活中的重大问题</p>
</li>
<li><p>基本研究方法：考察经济的总体趋势</p>
</li>
<li><p>收集不同时期、不同国家有关收入、通货膨胀和失业等变量的数据，尝试构建有助于理解这些数据的一般理论</p>
</li>
</ul>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="凯恩斯革命"><a href="#凯恩斯革命" class="headerlink" title="凯恩斯革命"></a>凯恩斯革命</h3><ol>
<li><p>系统收集、处理总量数据，为宏观经济学的研究提供科学基础</p>
</li>
<li><p>对经济波动的系统研究</p>
</li>
<li><p>始于1929年的“大萧条”</p>
</li>
</ol>
<ul>
<li>凯恩斯《就业、利息和货币通论》(General Theory of Employment, Interest and Money)</li>
</ul>
<p>有效需求：总需求(aggregate demand)</p>
<ul>
<li>构成现代宏观经济学的要素</li>
</ul>
<ul>
<li><p>乘数，解释需求冲击如何被放大以及如何导致产出更大的变化</p>
</li>
<li><p>流动性偏好，凯恩斯对货币需求的称谓，解释货币政策如何影响利率和有效需求</p>
</li>
<li><p>预期在影响消费和投资方面的重要性，动物精神，即预期的变化是造成需求和产出变化的主要因素</p>
</li>
</ul>
<h3 id="凯恩斯主义的发展"><a href="#凯恩斯主义的发展" class="headerlink" title="凯恩斯主义的发展"></a>凯恩斯主义的发展</h3><ul>
<li>新古典综合(neoclassical synthesis)：整合凯恩斯思想和古典思想</li>
</ul>
<ul>
<li><p>IS-LM模型</p>
</li>
<li><p>用数学语言对凯恩斯的观点进行表述</p>
</li>
<li><p>预期没有起到任何作用</p>
</li>
<li><p>缺少对价格和工资的调整</p>
</li>
<li><p>消费理论：持久收入在消费决策中具有重要作用</p>
</li>
<li><p>投资理论</p>
</li>
<li><p>货币需求理论：基于流动性、投资报酬率和风险发展不同资产之间的选择理论</p>
</li>
</ul>
<h3 id="凯恩斯主义和货币主义-争论"><a href="#凯恩斯主义和货币主义-争论" class="headerlink" title="凯恩斯主义和货币主义(争论)"></a>凯恩斯主义和货币主义(争论)</h3><ul>
<li><p>货币政策和财政政策(的效果)</p>
</li>
<li><p>凯恩斯强调，治理经济衰退中财政政策优于货币政策，IS曲线非常陡峭，推论货币政策作用不大</p>
</li>
<li><p>弗里德曼、施瓦茨考察货币史发现货币政策非常有效，可以解释大多数产出波动</p>
</li>
<li><p>IS曲线并没有想象的那样陡峭，财政政策和货币政策都会产生效果</p>
</li>
</ul>
<ul>
<li><p>菲利普斯曲线</p>
</li>
<li><p>失业和通胀之间存在可靠的交替关系</p>
</li>
<li><p>失业和通胀之间并不存在长期的交替关系：违背基本的经济规律</p>
</li>
</ul>
<ul>
<li><p>宏观经济管理模式(的作用)</p>
</li>
<li><p>凯恩斯主义：政府在宏观经济管理上要相机决策；经济学知识可用以稳定经济，政策制定者能够做正确的事情</p>
</li>
<li><p>弗里德曼质疑政府的良好初衷未必能可信地做正确的事情，建议政府在宏观经济管理上采取固定法则</p>
</li>
</ul>
<h3 id="理性预期批判"><a href="#理性预期批判" class="headerlink" title="理性预期批判"></a>理性预期批判</h3><ul>
<li>危机(20世纪70年代)</li>
</ul>
<ol>
<li>经济生活中发生石油危机</li>
</ol>
<ul>
<li><p>滞涨(stagflation): 高失业和高通胀同时存在</p>
</li>
<li><p>石油危机是一次不利的供给冲击</p>
</li>
</ul>
<ol>
<li>一部分经济学家开始从理论上质疑凯恩斯主义</li>
</ol>
<ul>
<li><p>凯恩斯主义经济学在石油危机中所表现出的漏洞：忽略预期影响经济活动主体行为的全面含义</p>
</li>
<li><p>解决办法：人们基于目前所有的信息理性地做出预期</p>
</li>
</ul>
<ul>
<li>凯恩斯主义经济学遭到严重破坏(经济活动主体是理性的，其预期也是理性的)</li>
</ul>
<ol>
<li>卢卡斯批判(Lucas Critique)</li>
</ol>
<p>如果政策发生变化，人们会基于新的政策形成预期，其行为也会发生变化，从而导致原先<br>的宏观经济(计量)模型可能会对在新政策下将要发生的事情做出糟糕的指导。</p>
<p>如20世纪70年代初期的菲利普斯曲线</p>
<ol>
<li>理性预期与菲利普斯曲线</li>
</ol>
<p>凯恩斯模型中，由于价格和工资将沿着菲利普斯曲线缓慢调整，产出是缓慢而不是迅速调整<br>到潜在产出水平。</p>
<ul>
<li>卢卡斯：供给和价格的调整很大程度上取决于工资制定者对通胀的预期方式，一旦我们<br>假定工资制定是理性预期的，调整可能快得多</li>
</ul>
<ol>
<li>最优控制与博弈论</li>
</ol>
<ul>
<li><p>凯恩斯主义采用的(宏观经济政策)分析工具，最优控制等，忽视了宏观经济政策制定者<br>与经济活动主体之间的互动</p>
</li>
<li><p>理性预期的第三个含义：如果经济活动主体是理性预期的，那么政策通常是政策制定者<br>与经济活动主体之间的博弈</p>
</li>
<li><p>采用博弈论研究宏观经济政策</p>
</li>
</ul>
<h3 id="理性预期的整合-20世纪70年代和80年代"><a href="#理性预期的整合-20世纪70年代和80年代" class="headerlink" title="理性预期的整合(20世纪70年代和80年代)"></a>理性预期的整合(20世纪70年代和80年代)</h3><ul>
<li>消费随机游走假说(Random-Walk Model of Consumption)</li>
</ul>
<p>理性预期引入到消费研究领域：如果消费者是理性预期的且非常有远见，那么对于下一年<br>消费的最好预测就是今天的消费</p>
<p>消费的变化难以预测：消费者只有得知有关将来的新信息后才会改变消费行为，但将来的<br>新信息是不可预测的</p>
<ul>
<li>工资与价格的交错调整(staggered price adjustment)</li>
</ul>
<p>工资和价格的调整过程不会出现突然的同步调整，而是交错调整，可能是缓慢的</p>
<p>即使经济活动主体是理性预期的，产出也是缓慢调整到其潜在产出水平的</p>
<p>政府有效需求管理的有效性并不依赖于理性预期的假定，而是依赖于市场瞬时出清的假定</p>
<ul>
<li>政策理论</li>
</ul>
<p>博弈不仅存在于政策制定者和经济活动主体之间，也存在与政策制定者(政党、央行和<br>中央政府，或不同国家政府)之间</p>
<h3 id="当前发展"><a href="#当前发展" class="headerlink" title="当前发展"></a>当前发展</h3><ul>
<li><p>新古典主义，新凯恩斯主义，新增长理论</p>
</li>
<li><p>实际商业周期理论(real business cycle, RBC)：经济体的产出通常处于其潜在水平，<br>因此所有波动都是源于潜在产出水平自身的变动，而不是源于对潜在产出水平的偏离。</p>
</li>
<li><p>RBC强调经济波动的根源是技术进步</p>
</li>
</ul>
<ul>
<li>新凯恩斯主义(New Keynesians)</li>
</ul>
<p>以最大化行为和理性预期为基础构建严密可信的工资、价格粘性模型</p>
<p>研究方向主要集中在劳动力市场的工资决定、信用市场的不完全以及名义刚性(nominal rigidities)</p>
<p>由于工资和价格决策的交错，产出会偏离潜在水平很长一段时间；</p>
<p>菜单成本理论(menu cost): 即使改变价格的成本很小也会导致交错的价格调整，产生名义价格刚性</p>
<ul>
<li>新经济增长理论(new growth theory)</li>
</ul>
<p>经济体增长速度取决于技术进步速度，决定技术进步的因素</p>
<p>规模报酬递增在增长中的作用，有效地分析框架</p>
<h2 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h2><h3 id="经济学家如何思考"><a href="#经济学家如何思考" class="headerlink" title="经济学家如何思考"></a>经济学家如何思考</h3><ul>
<li><p>经济学家最基本的工具：数据、术语、思考问题的方式；利用这些工具构建模型(model)，<br>用数学术语清晰地说明变量之间的关系。</p>
</li>
<li><p>外生变量(exogenous variables)：模型中给定的变量</p>
</li>
<li>内生变量(endogenous variables)：模型要解释的变量</li>
<li>模型界定外生变量如何影响内生变量</li>
</ul>
<h3 id="供求模型"><a href="#供求模型" class="headerlink" title="供求模型"></a>供求模型</h3><p>某种商品的竞争性市场，市场需求曲线单调下降，市场供给曲线单调上升，交点为市场均衡点。</p>
<ul>
<li><p>内生变量：对应价格为均衡价格，对应商品数量为均衡交易数量</p>
</li>
<li><p>外生变量：消费习惯、原材料来源、技术水平、政治法律等的变化，市场规模或居民收入水平变化等</p>
</li>
<li><p>需求膨胀：需求方购买商品的愿望和能力增强，商品的需求量在每个价格水平上都有所增加；<br>需求曲线向右平移，会导致市场均衡点上升，均衡价格和均衡交易量同时上升</p>
</li>
<li><p>需求收缩：需求方购买商品的愿望和能力减弱，商品的需求量在每个价格水平上都有所下降；<br>需求曲线向左平移，会导致市场均衡点下降，均衡价格和均衡交易量同时下降</p>
</li>
<li><p>供给膨胀：供给方出售商品的愿望增强，商品的供给量在每个价格水平上都有所增加;<br>供给曲线向右平移，市场均衡点下降，均衡价格下降，均衡交易量上升</p>
</li>
<li><p>供给收缩：供给方出售商品的愿望减弱，商品的供给量在每个价格水平上都有所减少；<br>供给曲线向左平移，市场均衡点上升，均衡价格上升，均衡交易量下降</p>
</li>
</ul>
<h3 id="从微观到宏观"><a href="#从微观到宏观" class="headerlink" title="从微观到宏观"></a>从微观到宏观</h3><p>宏观经济理论必须与微观经济活动主体的基本行为一致</p>
<ol>
<li><p>试图在理论水平上理解单个家庭和企业的决策过程</p>
</li>
<li><p>试图通过<strong>加总</strong>经济体中微观主体的所有决定来解释整体经济行为</p>
</li>
<li><p>通过手机分析数据，实证检验宏观经济学模型是否与现实一致</p>
</li>
</ol>
<h3 id="基本假定"><a href="#基本假定" class="headerlink" title="基本假定"></a>基本假定</h3><p>一种产品或服务的价格可以迅速调整；市场可以自动走向供求均衡，市场迅速出清</p>
<p>现实中存在工资和价格缓慢调整的情况，价格黏性</p>
<ul>
<li>价格并不总是黏性的，最终会随着供求的变动而变动；这一假定可以描述经济体的长期趋势</li>
</ul>
<h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><ul>
<li><p>总需求(aggregate demand, AD)：在货币政策、财政政策以及消费者信心不变的情况下，<br>每给定一个价格水平，产品市场和货币市场同时处于均衡状态时的产量水平</p>
</li>
<li><p>总需求函数(aggregate demand function)：Y = D(P)，经济体中价格水平P，总需求量Y</p>
</li>
<li><p>总需求曲线(aggregate deamnd curve)</p>
</li>
</ul>
<p>其它条件不变(ceteris paribus)：除价格水平之外其它与经济体的总需求相关的条件都保持不变</p>
<ul>
<li><p>总供给(aggregate supply)：在经济体中，对于每一既定价格水平，厂商愿意提供的产量</p>
</li>
<li><p>总供给函数(aggregate supply function)：Y = S(P)</p>
</li>
<li><p>长期总供给曲线是垂直的。其它条件发生变化(技术进步等)，生产能力提高时总供给曲线向右平移</p>
</li>
<li><p>在短期，价格是黏性的，总供给曲线是水平线</p>
</li>
<li><p>通常情况下，短期总供给曲线是向右上方倾斜</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/economics/宏观经济学鸟瞰/" data-id="cj04jtwf3000a60q1vnnl09lg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-economics/供给与需求的基本原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/economics/供给与需求的基本原理/" class="article-date">
  <time datetime="2017-03-08T04:10:41.264Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="供给与需求的基本原理"><a href="#供给与需求的基本原理" class="headerlink" title="供给与需求的基本原理"></a>供给与需求的基本原理</h1><p>标签：微观经济学</p>
<hr>
<h3 id="需求表"><a href="#需求表" class="headerlink" title="需求表"></a>需求表</h3><ul>
<li><p>在其他条件相同时，一种物品的价格越高，人们愿意购买的数量就越少；而市场价格越低，人们愿意购买的数量就越多</p>
</li>
<li><p>价格与需求之间的关系可以用一张需求表(demand schedule)或一条需求曲线(demand curve)表示</p>
</li>
</ul>
<ul>
<li><p>需求曲线：数量和价格呈反比关系</p>
</li>
<li><p>需求向下倾斜规律(law of downward-sloping demand): 当一种商品的价格上升时(同时其他条件保持不变)，购买者便会趋向于购买更少的数量；当价格下降、其他条件保持不变时，需求量会增加</p>
</li>
<li><p>替代效应(substitution effect): 当一种物品的价格上升时，人们会用其他类似的物品替代它</p>
</li>
<li><p>收入效应(income effect): 当价格上升时，人们会发现自己比以前穷了一些</p>
</li>
</ul>
<ul>
<li><p>市场需求</p>
</li>
<li><p>市场需求曲线是将在每一价格水平下所有个人的需求量加总而得到的</p>
</li>
<li><p>市场需求曲线符合需求向下倾斜规律</p>
</li>
</ul>
<ul>
<li><p>需求曲线背后的因素</p>
</li>
<li><p>消费者的平均收入是需求的重要决定因素。个人收入上升，即使价格不变，人们也会倾向于购买更多数量的几乎任何物品。</p>
</li>
<li><p>市场规模(用人口衡量)影响市场需求曲线</p>
</li>
<li><p>相关物品的价格及其可获得性会影响对该物品的需求，尤其是替代品之间存在着重要的联系</p>
</li>
<li><p>爱好或偏好的主观因素。代表文化、历史因素，反映心理、生理需要或人为造成的需要或者传统、宗教的因素</p>
</li>
<li><p>其他特殊的因素</p>
</li>
</ul>
<ul>
<li><p>需求的移动：除物品价格以外的其他因素(非价格变量)发生了变化</p>
</li>
<li><p>需求变动：商品价格之外的因素变化引起购买数量发生变化</p>
</li>
<li><p>需求增加，需求曲线向右移动，每一价格水平人们会购买更多物品</p>
</li>
<li><p>需求减少，需求曲线向左移动，每一价格水平人们会购买更少物品</p>
</li>
</ul>
<h3 id="供给表"><a href="#供给表" class="headerlink" title="供给表"></a>供给表</h3><ul>
<li><p>一种商品的供给表(supply schedule)或供给曲线(supply curve)体现在其它条件下，该商品的市场价格与生产者愿意生产和销售的数量之间的关系</p>
</li>
<li><p>应当保持不变的条件包括生产成本、相关物品的价格和政府政策</p>
</li>
</ul>
<ul>
<li><p>供给曲线</p>
</li>
<li><p>供给曲线向上倾斜的重要原因之一是边际收益递减规律：每一个新增加的劳动(要素)所增添的数量是递减的</p>
</li>
</ul>
<ul>
<li><p>供给曲线背后的因素</p>
</li>
<li><p>一个关键因素是生产成本</p>
</li>
<li><p>生产成本主要取决于投入品(劳动、能源或机器等)价格和技术进步(降低生产同量产出<br>所需的投入品数量的变化)(从应用科学突破到现有技术的更新与挖潜、生产流程的重新组织)</p>
</li>
<li><p>供给受相关物品价格的影响</p>
</li>
<li><p>一种替代品的价格上升，另一种替代品的供给就会下降</p>
</li>
<li><p>政府政策会对供给曲线产生重大影响</p>
</li>
<li><p>特殊因素(气候条件之类)也会影响供给曲线</p>
</li>
</ul>
<ul>
<li><p>供给的移动：价格之外的其他因素发生变动而引起供给数量发生变动</p>
</li>
<li><p>在市场的每一价格水平，当供给的数量都增加(或减少)时，供给增加(或减少)</p>
</li>
</ul>
<h3 id="供给和需求的平衡"><a href="#供给和需求的平衡" class="headerlink" title="供给和需求的平衡"></a>供给和需求的平衡</h3><ul>
<li><p>市场均衡(market equilibrium)：供给和需求的力量相互作用，产生均衡的价格和均衡<br>的数量。</p>
</li>
<li><p>在该点买者所愿意购买的数量正好等于卖者所愿意出售的数量。</p>
</li>
<li><p>当供求力量平衡时，只要其他条件保持不变，价格就没有理由继续波动</p>
</li>
<li><p>市场出清价格(market-clearing price)：需求量与供给量相等的价格水平(均衡价格)</p>
</li>
</ul>
<ul>
<li><p>供给曲线与需求曲线的均衡</p>
</li>
<li><p>均衡价格与均衡数量发生在愿意供给的数量等于愿意购买的数量的水平上</p>
</li>
<li><p>在竞争市场上，均衡发生在供给曲线与需求曲线的交点</p>
</li>
<li><p>在均衡价格水平上，市场上不存在短缺或过剩</p>
</li>
</ul>
<ul>
<li><p>供给或需求的移动对均衡的影响</p>
</li>
<li><p>当影响需求或供给的诸因素发生变化时就会导致需求或供给发生变动，并引起市场上的均衡价格和均衡数量也发生变动</p>
</li>
</ul>
<ul>
<li>解释价格和数量的变动：供给变化或需求变化；需求变化或沿着需求曲线移动</li>
</ul>
<ul>
<li>供给、需求和移民：移民对于当地劳工市场影响微弱;人口流动性强，新移民流向最可能找到工作的城市，迁入城市对劳工需求已经上升;移民迁入，当地居民迁出，劳动总供给实际上没变动</li>
</ul>
<ul>
<li><p>通过价格进行分配</p>
</li>
<li><p>用钱包进行配给(rationing by the purse)：市场通过供求的相互作用决定所有投入<br>和产出的均衡价格和均衡数量，将社会的稀缺品配置或配给到各种用途中</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/economics/供给与需求的基本原理/" data-id="cj04jtwf0000960q1bpmjzgbl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cplusplus_thinking/面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/Cplusplus_thinking/面向对象编程/" class="article-date">
  <time datetime="2017-03-08T04:10:41.260Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>标签： C++</p>
<hr>
<p><strong>一个面向对象程序范例</strong></p>
<p>面向对象对象编程三要素：</p>
<ol>
<li>数据抽象</li>
<li>继承</li>
<li>动态绑定</li>
</ol>
<p><strong>适用于大型程序</strong></p>
<h3 id="以算术表达式树形表示的面向对象解决方案为例"><a href="#以算术表达式树形表示的面向对象解决方案为例" class="headerlink" title="以算术表达式树形表示的面向对象解决方案为例"></a>以算术表达式树形表示的面向对象解决方案为例</h3><p>创建和打印表达式</p>
<ul>
<li><p>定义表达式树节点类<br>每个节点可能有一到三个子节点，可用一个联合加上一个指示节点类型的专门字段表示节点</p>
</li>
<li><p>三种节点：</p>
</li>
</ul>
<ol>
<li>包含一个整数值，无子节点</li>
<li>包含一个操作符，一个子节点</li>
<li>包含一个操作符，两个子节点</li>
</ol>
<blockquote>
<p>当需要用到一个类型字段时可以考虑定义一系列类并用继承组织起来能否更有效</p>
</blockquote>
<ul>
<li>用一个类表示“节点”概念</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Expr_node &#123;</div><div class="line">    <span class="comment">// print the expression</span></div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr_node&amp;);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> ~Expr_node() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> Expr_node&amp; e) &#123;</div><div class="line">    e.print(o);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>用继承声明具体类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// save first node-type</span></div><div class="line"><span class="keyword">class</span> Int_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    Int_node(<span class="keyword">int</span> k): n(k) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123; o &lt;&lt; n &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// svae second type</span></div><div class="line"><span class="keyword">class</span> Unary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr_node* opnd;</div><div class="line"></div><div class="line">    Unary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr_node* b): op(a), opnd(b) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; op &lt;&lt; *opnd &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// save third type</span></div><div class="line"><span class="keyword">class</span> Binary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr_node* left;</div><div class="line">    Expr_node* right;</div><div class="line"></div><div class="line">    Binary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr_node* b, Expr_node* c):</div><div class="line">        op(a), left(b), right(c) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; *left &lt;&lt; op &lt;&lt; *right &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>用句柄类管理指针避免使用者管理内存的麻烦<br>使用者关心的只是树和子树而非单个节点，定义句柄类Expr隐藏Expr_node继承层次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Expr &#123;</div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line"></div><div class="line">    Expr_node* p;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Expr(<span class="keyword">int</span>);</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, Expr);</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, Expr, Expr);</div><div class="line">    Expr(<span class="keyword">const</span> Expr&amp;);</div><div class="line">    Expr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expr&amp;);</div><div class="line">    ~Expr() &#123; <span class="keyword">delete</span> p; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Expr::Expr(<span class="keyword">int</span> n) &#123;</div><div class="line">    p = <span class="keyword">new</span> Int_node(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Expr::Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr t) &#123;</div><div class="line">    p = <span class="keyword">new</span> Unary_node(op, t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Expr::Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr left, Expr right) &#123;</div><div class="line">    p = <span class="keyword">new</span> Binary_node(op, left, right);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>改进</p>
</li>
</ul>
<ul>
<li>可在Expr_node派生层次加入虚函数copy</li>
<li>加入引用计数避免复制下层Expr_node会更有效率<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Expr_node &#123;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="comment">// add a use count</span></div><div class="line">    <span class="keyword">int</span> use;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Expr_node(): use(<span class="number">1</span>) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> ~Expr_node() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Expr &#123;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line"></div><div class="line">    Expr_node* p;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Expr(<span class="keyword">int</span> n) &#123;</div><div class="line">        p = <span class="keyword">new</span> Int_node(n);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr t) &#123;</div><div class="line">        p = <span class="keyword">new</span> Unary_node(op, t);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr left, Expr right) &#123;</div><div class="line">        p = <span class="keyword">new</span> Binary_node(op, left, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Expr(<span class="keyword">const</span> Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125;</div><div class="line">    ~Expr() &#123; <span class="keyword">if</span> (--p-&gt;use == <span class="number">0</span>) <span class="keyword">delete</span> p; &#125;</div><div class="line">    Expr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expr&amp;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// assignment operator increase use count of the right object</span></div><div class="line">Expr&amp; Expr::<span class="keyword">operator</span>=(<span class="keyword">const</span> Expr&amp; rhs) &#123;</div><div class="line">    rhs.p-&gt;use++;</div><div class="line">    <span class="keyword">if</span> (--p-&gt;use == <span class="number">0</span>)</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    p = rhs.p;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> Expr&amp; t) &#123;</div><div class="line">    t.p-&gt;print(o);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// save first type</span></div><div class="line"><span class="keyword">class</span> Int_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    Int_node(<span class="keyword">int</span> k): n(k) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123; o &lt;&lt; n &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// svae second type</span></div><div class="line"><span class="keyword">class</span> Unary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr opnd;</div><div class="line"></div><div class="line">    Unary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr b): op(a), opnd(b) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; op &lt;&lt; opnd &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// save third type</span></div><div class="line"><span class="keyword">class</span> Binary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr left;</div><div class="line">    Expr right;</div><div class="line"></div><div class="line">    Binary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr b, Expr c):</div><div class="line">        op(a), left(b), right(c) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="扩展新操作：表达式求值"><a href="#扩展新操作：表达式求值" class="headerlink" title="扩展新操作：表达式求值"></a>扩展新操作：表达式求值</h3><p>方法和打印表达式相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Expr_node &#123;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> use;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Expr_node(): use(<span class="number">1</span>) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="keyword">virtual</span> ~Expr_node() &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// add a pure virtual function</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Expr &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr_node;</div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line"></div><div class="line">    Expr_node* p;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Expr(<span class="keyword">int</span> n) &#123;</div><div class="line">        p = <span class="keyword">new</span> Int_node(n);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr t) &#123;</div><div class="line">        p = <span class="keyword">new</span> Unary_node(op, t);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr left, Expr right) &#123;</div><div class="line">        p = <span class="keyword">new</span> Binary_node(op, left, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Expr(<span class="keyword">const</span> Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125;</div><div class="line">    ~Expr() &#123; <span class="keyword">if</span> (--p-&gt;use == <span class="number">0</span>) <span class="keyword">delete</span> p; &#125;</div><div class="line">    Expr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expr&amp; t);</div><div class="line"></div><div class="line">    <span class="comment">// new function: calculate the evaluation</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p-&gt;eval(); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// save first type</span></div><div class="line"><span class="keyword">class</span> Int_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    Int_node(<span class="keyword">int</span> k): n(k) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123; o &lt;&lt; n &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// new function</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// svae second type</span></div><div class="line"><span class="keyword">class</span> Unary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr opnd;</div><div class="line"></div><div class="line">    Unary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr b): op(a), opnd(b) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; op &lt;&lt; opnd &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// new function</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Unary_node::eval() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="comment">// only consider certain operands</span></div><div class="line">    <span class="keyword">if</span> (op == <span class="string">"-"</span>)</div><div class="line">        <span class="keyword">return</span> -opnd.eval();</div><div class="line">    <span class="keyword">throw</span> <span class="string">"error, bad op "</span> + op + <span class="string">" int UnaryNode"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// save third type</span></div><div class="line"><span class="keyword">class</span> Binary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr left;</div><div class="line">    Expr right;</div><div class="line"></div><div class="line">    Binary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr b, Expr c):</div><div class="line">        op(a), left(b), right(c) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// new function</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Binary_node::eval() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">int</span> op1 = left.eval();</div><div class="line">    <span class="keyword">int</span> op2 = right.eval();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (op == <span class="string">"-"</span>) <span class="keyword">return</span> op1 - op2;</div><div class="line">    <span class="keyword">if</span> (op == <span class="string">"+"</span>) <span class="keyword">return</span> op1 + op2;</div><div class="line">    <span class="keyword">if</span> (op == <span class="string">"*"</span>) <span class="keyword">return</span> op1 * op2;</div><div class="line">    <span class="keyword">if</span> (op == <span class="string">"/"</span> &amp;&amp; op2 != <span class="number">0</span>) <span class="keyword">return</span> op1 / op2;</div><div class="line"></div><div class="line">    <span class="keyword">throw</span> <span class="string">"error, bad op "</span> + op + <span class="string">"in BinaryNode"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>类的抽象对算术表达式进行了精确建模</li>
<li>扩展程序以计算表达式所需要增加的代码较少</li>
</ul>
<h3 id="扩展增加新节点类型"><a href="#扩展增加新节点类型" class="headerlink" title="扩展增加新节点类型"></a>扩展增加新节点类型</h3><p>如增加Ternary_node表示三元操作符(?:)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Ternary_node: <span class="keyword">public</span> Expr_node &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr;</div><div class="line"></div><div class="line">    <span class="built_in">string</span> op;</div><div class="line">    Expr left;</div><div class="line">    Expr middle;</div><div class="line">    Expr right;</div><div class="line"></div><div class="line">    Ternary_node(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, Expr b, Expr c, Expr d):</div><div class="line">        op(a), left(b), middle(c), right(d) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; o)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        o &lt;&lt; <span class="string">"("</span> &lt;&lt; left &lt;&lt; <span class="string">" ? "</span> &lt;&lt; middle &lt;&lt; <span class="string">" : "</span> &lt;&lt; right &lt;&lt; <span class="string">")"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// new function</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Ternary_node::eval() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">if</span> (left.eval())</div><div class="line">        <span class="keyword">return</span> middle.eval();</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        <span class="keyword">return</span> right.eval();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// add a constructor for Ternary_node in Expr</span></div><div class="line"><span class="keyword">class</span> Expr &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Expr_node;</div><div class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> Expr&amp;);</div><div class="line"></div><div class="line">    Expr_node* p;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Expr(<span class="keyword">int</span> n) &#123;</div><div class="line">        p = <span class="keyword">new</span> Int_node(n);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr t) &#123;</div><div class="line">        p = <span class="keyword">new</span> Unary_node(op, t);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>&amp; op, Expr left, Expr right) &#123;</div><div class="line">        p = <span class="keyword">new</span> Binary_node(op, left, right);</div><div class="line">    &#125;</div><div class="line">    Expr(<span class="keyword">const</span> <span class="built_in">string</span>* op, Expr left, Expr middle, Expr right) &#123;</div><div class="line">        p = <span class="keyword">new</span> Ternary_node(op, left, middle, right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Expr(<span class="keyword">const</span> Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125;</div><div class="line">    ~Expr() &#123; <span class="keyword">if</span> (--p-&gt;use == <span class="number">0</span>) <span class="keyword">delete</span> p; &#125;</div><div class="line">    Expr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expr&amp; t);</div><div class="line"></div><div class="line">    <span class="comment">// new function: calculate the evaluation</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p-&gt;eval(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向对象编程能简化程序的设计和更新过程</p>
<ul>
<li>对下层系统中的对象进行建模</li>
<li>保证修改时耦合度低</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/面向对象编程/" data-id="cj04jtwez000860q1g2cjupwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cplusplus_thinking/类设计者的核查表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/Cplusplus_thinking/类设计者的核查表/" class="article-date">
  <time datetime="2017-03-08T04:10:41.259Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类设计者的核查表"><a href="#类设计者的核查表" class="headerlink" title="类设计者的核查表"></a>类设计者的核查表</h1><p>标签：C++</p>
<hr>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>简单的类 结构就是接口 不需要构造函数</p>
<h2 id="数据成员私有"><a href="#数据成员私有" class="headerlink" title="数据成员私有"></a>数据成员私有</h2><p>阻止类的使用者私自改动<br>提供相应接口 供使用者执行修改或访问等操作</p>
<h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><p>声明对象数组必需</p>
<h2 id="初始化数据成员"><a href="#初始化数据成员" class="headerlink" title="初始化数据成员"></a>初始化数据成员</h2><p>每个构造函数都要负责为所有的数据成员设置经过明确定义的值<br>除非该数据成员在类的对象存在一定时间后才有意义或其它特殊情况</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>该类分配了不会被成员函数自动释放的资源（动态内存）时必需</p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>(类B派生的子类D，若可能对D类型对象的B*指针执行delete表达式时必需)<br>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B &#123;</div><div class="line">    <span class="built_in">string</span> t;</div><div class="line">    <span class="comment">// virtual ~B() &#123;&#125;;</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    B* bp = <span class="keyword">new</span> D; <span class="comment">// no problem</span></div><div class="line">    <span class="keyword">delete</span> bp;     <span class="comment">// unless B has a virtual destructor</span></div><div class="line">                   <span class="comment">// or the wrong dstructor would be called</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>当复制类的对象并非复制其数据成员和基类对象时必需</p>
<ul>
<li>若不想使用者能够复制类的对象，就声明复制构造函数(赋值操作符)为私有的</li>
</ul>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>当赋值类的对象并非复制其数据成员和基类对象时必需</p>
<ul>
<li><p>考虑赋值给对象本身的情况<br>例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> String &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;s);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> *data;</div><div class="line">&#125;;</div><div class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s) &#123;</div><div class="line">    <span class="keyword">if</span> (&amp;s != <span class="keyword">this</span>) &#123; <span class="comment">// do nothing with self-assignment</span></div><div class="line">        <span class="keyword">delete</span> [] data; <span class="comment">// delete old array</span></div><div class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.data) + <span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(data, s.data);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>若不想使用者能够设置类中的对象，就将赋值操作符私有化</p>
</li>
<li><p>析构函数、拷贝构造函数、赋值操作符= 通常为同时必需的</p>
</li>
</ul>
<p>关系操作符<br>类逻辑上支持相等操作则提供 operator== 和 operator!=<br>类具有某种排序关系则提供余下的关系操作符(&lt; &gt; &lt;= &gt;=)</p>
<h2 id="拷贝构造函数和赋值操作符的参数类型加上const"><a href="#拷贝构造函数和赋值操作符的参数类型加上const" class="headerlink" title="拷贝构造函数和赋值操作符的参数类型加上const"></a>拷贝构造函数和赋值操作符的参数类型加上const</h2><p>like X::X(const X&amp;) X::operator=(const X&amp;)</p>
<h2 id="函数的const引用参数"><a href="#函数的const引用参数" class="headerlink" title="函数的const引用参数"></a>函数的const引用参数</h2><p>除非函数用来改变参数的值否则应为const引用<br>例如:<br>    Complex operator+(const Complex&amp; x, const Complex&amp; y);</p>
<h2 id="适当声明成员函数为const"><a href="#适当声明成员函数为const" class="headerlink" title="适当声明成员函数为const"></a>适当声明成员函数为const</h2><p>成员函数不用修改它的对象时</p>
<ul>
<li>const对象只能使用声明为const的函数</li>
</ul>
<h1 id="设计理念："><a href="#设计理念：" class="headerlink" title="设计理念："></a>设计理念：</h1><p>C++不可能自动处理所有这些事情(难以保证做得对)<br>始终加入的话增加太多的额外负担，开销过大<br>如给所有类自动添加一个虚析构函数，当类较小时开销明显<br>作为变通方法，让编译器指出什么时候类该有什么必需的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/类设计者的核查表/" data-id="cj04jtweu000760q139x12rlm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cplusplus_thinking/模板（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/Cplusplus_thinking/模板（二）/" class="article-date">
  <time datetime="2017-03-08T04:10:41.258Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板（二）"><a href="#模板（二）" class="headerlink" title="模板（二）"></a>模板（二）</h1><p>标签：C++</p>
<hr>
<h2 id="访问容器中的元素"><a href="#访问容器中的元素" class="headerlink" title="访问容器中的元素"></a>访问容器中的元素</h2><p>保留Array<t>和一个指向T的指针之间的密切关系要付出一定的代价</t></p>
<ol>
<li><p>用户能够轻易得到一个指向Array内部的指针，即使Array本身不存在了，这个指针仍被保留</p>
</li>
<li><p>不得不暴露类的内部机制，一旦内存变化肯定导致用户错误；resize之类的扩展有诸多潜在错误</p>
</li>
</ol>
<ul>
<li>增加防止出错的中间层</li>
</ul>
<h3 id="模拟指针"><a href="#模拟指针" class="headerlink" title="模拟指针"></a>模拟指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Pointer &#123;</div><div class="line"><span class="keyword">public</span>：</div><div class="line">    Pointer(Array&lt;T&gt;&amp; a, <span class="keyword">unsigned</span> n = <span class="number">0</span>): ap(&amp;a), sub(n) &#123;&#125;</div><div class="line">    Pointer(): ap(<span class="number">0</span>), sub(<span class="number">0</span>) &#123;&#125;</div><div class="line">    <span class="comment">// Array&lt;T&gt; cann't be default: reference should bind a object</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array&lt;T&gt;* ap;</div><div class="line">    <span class="keyword">unsigned</span> sub;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>复制一个Pointer之后，原Pointer和其副本都指向一个位置</li>
</ul>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul>
<li><p>最直接的方法会面临上述问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Pointer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Pointer"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>另一种解决方案会带来赋值不方便的新问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Pointer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Pointer"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// "t = *p" is allowed but "*p = t" is forbidden</span></div><div class="line"><span class="comment">// the point is that it is hard to implement "*p = t"</span></div><div class="line"><span class="comment">// while "T* tp = &amp;*p" is allowed</span></div></pre></td></tr></table></figure>
</li>
<li><p>引进update操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Pointer &#123;</div><div class="line"><span class="keyword">public</span>：</div><div class="line">    Pointer(Array&lt;T&gt;&amp; a, <span class="keyword">unsigned</span> n = <span class="number">0</span>): ap(&amp;a), sub(n) &#123;&#125;</div><div class="line">    Pointer(): ap(<span class="number">0</span>), sub(<span class="number">0</span>) &#123;&#125;</div><div class="line">    </div><div class="line">    T <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Pointer"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"update of unbound Pointer"</span>;</div><div class="line">        (*ap)[sub] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array&lt;T&gt;* ap;</div><div class="line">    <span class="keyword">unsigned</span> sub;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>相应地，Array类使用update操作，但会带来无法实现包含Array的Array的功能的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> n) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (n &gt;= sz)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Array suubscript out of range"</span>;</div><div class="line">        <span class="keyword">return</span> data[n];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> n, <span class="keyword">const</span> T&amp; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &gt;= sz)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Array subscript out of range"</span>;</div><div class="line">        data[n] = t;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>方便性和安全性之间的权衡问题</li>
</ul>
<blockquote>
<p>选择何种方法取决于类会被确切地怎样使用</p>
</blockquote>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ul>
<li>如果Array不存在了还可能存在一个指向它的空悬Pointer</li>
</ul>
<blockquote>
<p>“软件工程基本定理”(though it isn’t a real theory): 通过引进一个额外的中间层能够解决任何问题。’</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array_data &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Array&lt;T&gt;;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Pointer&lt;T&gt;;</div><div class="line"></div><div class="line">    Array_data(<span class="keyword">unsigned</span> size = <span class="number">0</span>): data(<span class="keyword">new</span> T[size]), sz(size), use(<span class="number">1</span>) &#123;&#125;</div><div class="line">    ~Array_data() &#123; <span class="keyword">delete</span> [] data; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> n) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (n &gt;= sz)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Array subscript out of range"</span>;</div><div class="line">        <span class="keyword">return</span> data[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> n) &#123;</div><div class="line">        <span class="keyword">if</span> (n &gt;= sz)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Array subscript out of range"</span>;</div><div class="line">        <span class="keyword">return</span> data[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// no implement that copy is no allowed</span></div><div class="line">    Array_data(<span class="keyword">const</span> Array_data&amp;);</div><div class="line">    Array_data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array_data&amp;);</div><div class="line"></div><div class="line">    T* data;</div><div class="line">    <span class="keyword">unsigned</span> sz;</div><div class="line">    <span class="keyword">int</span> use;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Pointer&lt;T&gt;;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Array(<span class="keyword">unsigned</span> size): data(<span class="keyword">new</span> Array_data&lt;T&gt;(size)) &#123;&#125;</div><div class="line">    ~Array() &#123;</div><div class="line">        <span class="keyword">if</span> (--data-&gt;use == <span class="number">0</span>)</div><div class="line">            <span class="keyword">delete</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> n) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> (*data)[n];</div><div class="line">    &#125;</div><div class="line">    T* <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> n) &#123;</div><div class="line">        <span class="keyword">return</span> (*data)[n];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array(<span class="keyword">const</span> Array&amp;);</div><div class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp;);</div><div class="line">    Array_data&lt;T&gt;* data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Poiter: <span class="keyword">public</span> Ptr_to_const&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Pointer(Array&lt;T&gt;&amp; a, <span class="keyword">unsigned</span> n = <span class="number">0</span>): ap(a.data), sub(n) &#123;</div><div class="line">        ++ap-&gt;use;</div><div class="line">    &#125;</div><div class="line">    Pointer(): ap(<span class="number">0</span>), sub(<span class="number">0</span>) &#123;&#125;</div><div class="line">    Pointer(<span class="keyword">const</span> Pointer&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123;</div><div class="line">        <span class="keyword">if</span> (ap)</div><div class="line">            ++ap-&gt;use;</div><div class="line">    &#125;</div><div class="line">    ~Pointer() &#123;</div><div class="line">        <span class="keyword">if</span> (ap &amp;&amp; --ap-&gt;use == <span class="number">0</span>)</div><div class="line">            <span class="keyword">delete</span> ap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Pointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Pointer&lt;T&gt;&amp; p) &#123;</div><div class="line">        <span class="keyword">if</span> (p.ap)</div><div class="line">            ++p.ap-&gt;use;</div><div class="line">        <span class="keyword">if</span> (ap &amp;&amp; --ap-&gt;use == <span class="number">0</span>)</div><div class="line">            <span class="keyword">delete</span> ap;</div><div class="line">        ap = p.ap;</div><div class="line">        sub = p.sub;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Ptr_to_const"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array_data&lt;T&gt;* ap;</div><div class="line">    <span class="keyword">unsigned</span> sub;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// the following code does work</span></div><div class="line">Array&lt;<span class="keyword">int</span>&gt;* ap = <span class="keyword">new</span> Array&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</div><div class="line">Pointer&lt;<span class="keyword">int</span>&gt; p(*ap, <span class="number">5</span>);</div><div class="line"><span class="keyword">delete</span> ap;</div><div class="line">*p = <span class="number">42</span>;</div></pre></td></tr></table></figure>
<h3 id="指向const-Array的Pointer"><a href="#指向const-Array的Pointer" class="headerlink" title="指向const Array的Pointer"></a>指向const Array的Pointer</h3><ul>
<li>还无法使Pointer指向const Array的元素</li>
</ul>
<p>const Array的实际对象很少，但通过引用传递Array参数(const Array&amp;)时还是有用的</p>
<ul>
<li><p>定义独立的类，提供类型转换操作符给这个类，通过继承获得两种类型间的相似性</p>
</li>
<li><p>类Pointer从Ptr_to_const继承而来，即使对象不是const类型也能把指针保存在Array_data中</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Ptr_to_const &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// catch a argument const Array&lt;T&gt;&amp; instead of Array&lt;T&gt;&amp;</span></div><div class="line">    Ptr_to_const(<span class="keyword">const</span> Array&lt;T&gt;&amp; a, <span class="keyword">unsigned</span> n = <span class="number">0</span>): ap(a.data), sub(n) &#123;</div><div class="line">        ++ap-&gt;use;</div><div class="line">    &#125;</div><div class="line">    Ptr_to_const(): ap(<span class="number">0</span>), sub(<span class="number">0</span>) &#123;&#125;</div><div class="line">    Ptr_to_const(<span class="keyword">const</span> Ptr_to_const&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123;</div><div class="line">        <span class="keyword">if</span> (ap)</div><div class="line">            ++ap-&gt;use;</div><div class="line">    &#125;</div><div class="line">    ~Ptr_to_const() &#123;</div><div class="line">        <span class="keyword">if</span> (ap &amp;&amp; --ap-&gt;use == <span class="number">0</span>)</div><div class="line">            <span class="keyword">delete</span> ap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Ptr_to_const&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr_to_const&lt;T&gt;&amp; p) &#123;</div><div class="line">        <span class="keyword">if</span> (p.ap)</div><div class="line">            ++p.ap-&gt;use;</div><div class="line">        <span class="keyword">if</span> (ap &amp;&amp; --ap-&gt;use == <span class="number">0</span>)</div><div class="line">            <span class="keyword">delete</span> ap;</div><div class="line">        ap = p.ap;</div><div class="line">        sub = p.sub;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Ptr_to_const"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array_data&lt;T&gt;* ap;</div><div class="line">    <span class="keyword">unsigned</span> sub;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// redefine class Pointer to keep something about constant</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Poiter: <span class="keyword">public</span> Ptr_to_const&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Pointer(Array&lt;T&gt;&amp; a, <span class="keyword">unsigned</span> n = <span class="number">0</span>): Ptr_to_const&lt;T&gt;(a, n) &#123;&#125;</div><div class="line">    Pointer() &#123;&#125;</div><div class="line"></div><div class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (ap == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="string">"* of unbound Ptr_to_const"</span>;</div><div class="line">        <span class="keyword">return</span> (*ap)[sub];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="增强操作"><a href="#增强操作" class="headerlink" title="增强操作"></a>增强操作</h3><p>重新设置Array大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// Array_data do the real operation</span></div><div class="line">        data-&gt;resize(n);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">void</span> Array_data&lt;T&gt;::resize(<span class="keyword">unsigned</span> n) &#123;</div><div class="line">    <span class="keyword">if</span> (n == sz) <span class="keyword">return</span> ;</div><div class="line">    T* odata = data;</div><div class="line">    data = <span class="keyword">new</span> T[n];</div><div class="line">    copy(odata, sz &gt; n ? n : sz);</div><div class="line">    <span class="keyword">delete</span> [] odata;</div><div class="line">    sz = n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">void</span> Array_data&lt;T&gt;::copy(T* arr, <span class="keyword">unsigned</span> n) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        data[i] = arr[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// another way of changing Array size</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">unsigned</span> new_sz)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (new_sz &gt;= data-&gt;sz)</div><div class="line">            data-&gt;grow(new_sz);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">void</span> Array_data&lt;T&gt;::grow(<span class="keyword">unsigned</span> new_sz) &#123;</div><div class="line">    <span class="keyword">unsigned</span> nsz = sz;</div><div class="line">    <span class="keyword">if</span> (nsz == <span class="number">0</span>)</div><div class="line">        nsz = <span class="number">1</span>;</div><div class="line">    whiel (nsz &lt;= new_sz)</div><div class="line">        nsz *= <span class="number">2</span>;</div><div class="line">    resize(nsz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>实现对Array的复制和赋值使包含Array的Array有效</p>
</li>
<li><p>不允许对Array_data对象复制，故不定义operator=调用Array_data::operator=</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Array &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Array(<span class="keyword">const</span> Array&amp; a): data(<span class="keyword">new</span> Array_data&lt;T&gt;(a.data-&gt;sz)) &#123;</div><div class="line">        data-&gt;copy(a.data-&gt;data, a.data-&gt;sz);</div><div class="line">    &#125;</div><div class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; a) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a)</div><div class="line">            data-&gt;clone(*a.data, a.data-&gt;data);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">void</span> Array_data&lt;T&gt;::clone(<span class="keyword">const</span> Array_data&amp; a, <span class="keyword">unsigned</span> n) &#123;</div><div class="line">    <span class="keyword">delete</span> [] data;</div><div class="line">    data = <span class="keyword">new</span> T[sz = a.sz];</div><div class="line">    copy(a.data, sz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>尚未完全消除指针的需求</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/模板（二）/" data-id="cj04jtwes000660q1yf7lexhm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cplusplus_thinking/模板（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/Cplusplus_thinking/模板（三）/" class="article-date">
  <time datetime="2017-03-08T04:10:41.256Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板（三）"><a href="#模板（三）" class="headerlink" title="模板（三）"></a>模板（三）</h1><p>标签：C++</p>
<hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li><p>已经定义Array<t>、Pointer<t>和Ptr_to_const<t>使得能部分确保安全性避免使用<br>指针</t></t></t></p>
</li>
<li><p>进一步取代指针，需实现加法、减法和关系运算符</p>
</li>
</ul>
<p>‘’’C++<br>void f() {<br>    int a[10];<br>    int<em> pa = a;<br>    int</em> end = pa + 10;<br>    while (pa != end)<br>        *pa++ = 0;<br>}<br>‘’’</p>
<ul>
<li>基类及派生类都要定义这些操作</li>
</ul>
<p>‘’’C++<br>template <class t=""> class Pointer: public Ptr_to_const<t> {<br>public:<br>    Pointer&amp; operator++() {<br>        ++sub;<br>        return *this;<br>    }</t></class></p>
<pre><code>Pointer&amp; operator--() {
    --sub;
    return *this;
}

Pointer&amp; operator++(int) {
    Pointer ret = *this;
    ++sub;
    return ret;
}

Pointer&amp; operator--(int) {
    Pointer ret = *this;
    --sub;
    return ret;
}

Pointer&amp; operator+=(int n) {
    sub += n;
    return *this;
}

Pointer&amp; operator-=(int n) {
    sub -= n;
    return *this;
}
// ...
</code></pre><p>};</p>
<p>template <class t=""> Pointer<t> operator+(const Pointer<t>&amp; p, int n) {<br>    Pointer<t> ret = p;<br>    return ret += n;<br>}</t></t></t></class></p>
<p>template <class t=""> Pointer<t> operator+(int n, const Pointer<t>&amp; p) {<br>    Pointer<t> ret = p;<br>    return ret += n;<br>}</t></t></t></class></p>
<p>// subtration is similar<br>‘’’</p>
<ul>
<li>两个指针当且仅当指向同一个Array的同一个元素(或都不指向任何Array)时才相等</li>
</ul>
<p>‘’’C++<br>template <class t=""><br>int operator==(const Ptr_to_const<t>&amp; op1, cosnt Ptr_to_const<t>&amp; op2) {<br>    if (op1.ap != op2.ap)<br>        return 0;<br>    return (op1.sub == op2.sub);<br>}</t></t></class></p>
<p>template <class t=""><br>int operator&lt;(const Ptr_to_const<t>&amp; op1, const Ptr_to_const<t>&amp; op2) {<br>    if (op1.ap != op2.ap)<br>        throw “&lt; on different Arrays”;<br>    return op1.sub &lt; op2.sub;<br>}<br>‘’’</t></t></class></p>
<ul>
<li>迭代器能在不暴露容器内部结构的情况下访问容器的元素</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li><p>当元素不存在时的处理方法</p>
</li>
<li><p>禁止从容器中删除单个元素(可以删除整个容器)</p>
</li>
<li><p>在每个容器对象中保存一个有效迭代器的列表，删除一个元素则正好删除刚好指向这个<br>被删除元素的迭代器</p>
</li>
<li><p>对容器中每个元素采用引用计数，删除任何一个元素都必须等到最后一个指向该元素的<br>引用都不存在</p>
</li>
<li><p>让迭代器指向容器中元素与元素之间的位置上(难以实现；影响先有代码)</p>
</li>
</ul>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul>
<li><p>容器本身已不存在，还有活动的迭代器的解决方法</p>
</li>
<li><p>删除操作延后到最后一个迭代器失效</p>
</li>
<li><p>采用处理删除单个元素的思想</p>
</li>
<li><p>用户确保一旦容器删除就不再使用迭代器</p>
</li>
<li><p>只要有活动迭代器存在就禁止删除容器本身</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfeng.github.io/2017/03/08/Cplusplus_thinking/模板（三）/" data-id="cj04jtwep000560q16l5p9bbz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/10/computer_network_1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/08/economics/经济学基础知识/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/08/economics/现代经济中的市场和政府/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/08/economics/宏观经济现象鸟瞰/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/08/economics/宏观经济学鸟瞰/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 chenxf<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>