[{"title":"应用层 Application Layer","slug":"computer_network/computer_network_2","date":"2017-04-18T16:00:00.000Z","updated":"2017-04-22T13:08:04.484Z","comments":true,"path":"2017/04/19/computer_network/computer_network_2/","link":"","permalink":"https://chenfeng.github.io/2017/04/19/computer_network/computer_network_2/","excerpt":"应用层协议原理 principles of network applications网络应用体系结构(application architecture): 客户-服务器体系结构(client-server architecture) server: always-on host permanent IP address data centers for scaling","text":"应用层协议原理 principles of network applications网络应用体系结构(application architecture): 客户-服务器体系结构(client-server architecture) server: always-on host permanent IP address data centers for scaling clients: communicate with server may be intermittently connected may have dynamic IP addresses do not communicate directly with each other P2P体系结构(P2P architecture): peer-to-peer no always-on server arbitrary end systems directly communicate peers request service from other peers, provide service in return to other peers: self scalability – new peers bring new service capacity, as well as new service demands 自扩展性(self-scalability) peers are intermittently connected and change IP addresses:complex management 进程(process)通信process: program running within a host within same host, two processes communicate using inter-process communication(defined by OS) processes in different hosts communicate by exchanging messages 客户和服务器进程:在一对进程之间的通信会话场景中，发起通信(即在该会话中开始时发起与其他进程的联系)的进程被标识为客户，在会话开始时等待联系的进程是服务器 client process: process that initiates communication server process: process that waits to be contacted aside: applications with P2P architectures have client processes &amp; server processes 进程与计算机网络之间的接口：应用程序编程接口(Application Programming Interface, API) 套接字(socket) process sends/receives messages to/from its socket socket analogous to door: sending process shoves message out door sending process relies on transport infrastructure on other side of door to deliver message to socket at receiving process 应用程序开发者对运输层的控制仅限于 选择运输层协议 设定运输层参数如最大缓存和最大报文段长度等 进程寻址： 主机地址：IP地址(IP address) 目的主机宏接受进程的标识符：端口号(port number) to receive messages, process must have identifier host device has unique 32-bit IP address Q: does IP address of host on which process runs suffice for identifying the process? A: no, many processes can be running on same host identifier includes both IP address and port numbers associated with process on host. example port numbers: HTTP server: 80 mail server: 25 应用程序可用运输服务 可靠数据传输(reliable data transfer) 容忍丢失的应用(loss-tolerant application) 吞吐量 带宽敏感的应用(bandwidth-sensitive application) 弹性应用(elastic application) 定时 安全性 data integrity some apps (e.g., file transfer, web transactions) require 100% reliable data transfer other apps (e.g., audio) can tolerate some loss throughput some apps (e.g., multimedia) require minimum amount of throughput to be “effective” other apps (“elastic apps”) make use of whatever throughput they get timing some apps (e.g., Internet telephony, interactive games) require low delay to be “effective” security encryption, data integrity 因特网提供的运输服务QoS: Quantity of Service TCP服务：面向连接服务和可靠数据传输 TCP service: reliable transport between sending and receiving process flow control: sender won’t overwhelm receiver congestion control: throttle sender when network overloaded does not provide: timing, minimum throughput guarantee, security connection-oriented: setup required between client and server processes UDP服务：不提供不必要服务的轻量级运输协议，无连接的 UDP service: unreliable data transfer between sending and receiving process does not provide: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup, 安全套接字层(Secure Sockets Layer, SSL): TCP的加强版本，增加安全性服务 TCP &amp; UDP: no encryption cleartext passwds sent into socket traverse Internet in cleartext SSL: provides encrypted TCP connection data integrity end-point authentication SSL is at app layer apps use SSL libraries, that “talk” to TCP SSL socket API cleartext passwords sent into socket traverse Internet encrypted 应用层协议(application-layer protocol) 交换的报文类型 报文类型的语法 字段的语义 进程何时及如何发送报文，对报文响应的规则 types of messages exchanged, e.g., request, response message syntax: what fields in messages &amp; how fields are delineated message semantics meaning of information in fields exchange rules for when and how processes send &amp; respond to messages open protocols: defined in RFCs allows for interoperability e.g., HTTP, SMTP proprietary protocols: e.g., Skype Telnet TELNET Protocol Offers three basic services: Defines network virtual terminal (NVT) Basic terminal operations standard interface Allows client and server negotiate options Treats both ends symmetrically No force on client; it can be arbitrary program Network Virtual Terminal: Different OS’s, different keys : Ctrl-c &lt;–&gt; ESC different End of line : CR, LF, CR-LF TELNET defines standard 7 bit US ASCII their interpretation of control(e.g., CR-13,LF-10) End of line is CR-LF Some 8 bit octets for control functions RLOGIN(REMOTE LOGIN)rlogin – understands Unix environment better Passes some terminal parameters automatically Trusted machines do not require password The Rlogin process uses the TCP port 513 文件传输协议: FTPFTP使用两个TCP连接传输文件 控制连接(control connection) 两主机之间传递控制信息：用户标识、口令、改变远程目录和’put’/‘get’等 带外传送(out-of-band) 数据连接(data connection) FTP命令和回答：7比特ASCII格式在控制连接上传送，每个命令跟回车换行符(区分命令) 每个命令4个大写字母ASCII字符，部分具有可选参数 e.g. USER username、PASS password、LIST、RETR filename、STOR filename 等 回答是一个3位数字，后跟可选信息e.g. 230 User login, OK、331 Uername OK, Password require、125 Data connection already open; transfer starting、425 Can’t open data connection、452 Error writing file 等 TFTP(Trivial File Transfer Protocol)TFTP is intended for application with simple needs: Simple file transfer w/o authentication Software is much smaller than FTP Small size of software is importante.g., in ROM for booting diskless workstations Uses UDP instead of TCP Less reliable Using timeout and retransmission TFTP Reliability: Minimal error handling Most errors result in termination Web和HTTP web page consists of objects object can be HTML file, JPEG image, Java applet, audio file,… web page consists of base HTML-file which includes several referenced objects each object is addressable by a URL web的应用层协议：超文本传输协议(HyperText Transfer Protocol, HTTP) HTTP: hypertext transfer protocol – Web’s application layer protocol client/server model client: browser that requests, receives, (using HTTP protocol) and “displays” Web objects server: Web server sends (using HTTP protocol) objects in response to requests uses TCP: client initiates TCP connection (creates socket) to server, port 80 server accepts TCP connection from client HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server) TCP connection closed 无状态协议(stateless protocol) HTTP is “stateless”:server maintains no information about past client requests protocols that maintain “state” are complex! past history (state) must be maintained if server/client crashes, their views of “state” may be inconsistent, must be reconciled 非持续连接(non-persistent connection): 每一个请求/响应对是经一个单独的TCP连接发送，如HTTP1.0 non-persistent HTTP: at most one object sent over TCP connection, connection then closed downloading multiple objects required multiple connections suppose user enters URL: www.someSchool.edu/someDepartment/home.index (contains text, references to 10 jpeg images) 1a. HTTP client initiates TCP connection to HTTP server (process) at www.someSchool.edu on port 80 1b. HTTP server at host www.someSchool.edu waiting for TCP connection at port 80. “accepts” connection, notifying client HTTP client sends HTTP request message (containing URL) into TCP connection socket. Message indicates that client wants object someDepartment/home.index HTTP server receives request message, forms response message containing requested object, and sends message into its socket HTTP server closes TCP connection. HTTP client receives response message containing html file, displays html. Parsing html file, finds 10 referenced jpeg objects Steps 1-5 repeated for each of 10 jpeg objects 持续连接(persistent connection): 所有的请求及其响应经相同的TCP连接发送，如HTTP1.1 persistent HTTP: multiple objects can be sent over single TCP connection between client, server response time往返时间(Round-Trip Time, RTT): 一个短分组从客户到服务器然后在返回客户的时间 RTT (definition): time for a small packet to travel from client to server and back HTTP response time: one RTT to initiate TCP connection one RTT for HTTP request and first few bytes of HTTP response to return file transmission time non-persistent HTTP response time = 2RTT+ file transmission time non-persistent HTTP issues: requires 2 RTTs per object OS overhead for each TCP connection browsers often open parallel TCP connections to fetch referenced objects persistent HTTP: server leaves connection open after sending response subsequent HTTP messages between same client/server sent over open connection client sends requests as soon as it encounters a referenced object as little as one RTT for all the referenced objects HTTP报文格式two types of HTTP messages: request, response HTTP request message: ASCII (human-readable format) 请求报文 请求行(request line): 方法字段、URL字段、HTTP版本字段 首部行(header line)(多个) 实体体(entity body)(POST方法才使用实体体) POST method: web page often includes form input input is uploaded to server in entity body URL method: uses GET method input is uploaded in URL field of request line: www.somesite.com/animalsearch?monkeys&amp;banana HTTP/1.0: GET / POST / HEAD(asks server to leave requested object out of response) HTTP/1.1: GET, POST, HEAD PUT(uploads file in entity body to path specified in URL field) DELETE(deletes file specified in the URL field) 响应报文 初始状态行(status line): 协议版本字段、状态码、相应状态信息 首部行(多个) 实体体(entity body) status code appears in 1st line in server-to-client response message. some sample codes: 200 OK(request succeeded, requested object later in this msg) 301 Moved Permanently(requested object moved, new location specified later in this msg (Location:)) 400 Bad Request(request msg not understood by server) 404 Not Found(requested document not found on this server) 505 HTTP Version Not Supported Trying out HTTP (client side) for yourself: 用户和服务器的交互: cookiecookie技术有四个组件: 在HTTP响应报文中的一个cookie首部行 在HTTP请求报文中的一个cookie首部行 在用户端系统中保留有一个cookie文件，由浏览器进行管理 位于Web站点的一个后端数据库 many Web sites use cookiesfour components: 1) cookie header line of HTTP response message2) cookie header line in next HTTP request message3) cookie file kept on user’s host, managed by user’s browser4) back-end database at Web site example: Susan always access Internet from PC visits specific e-commerce site for first time when initial HTTP requests arrives at site, site creates: unique ID entry in backend database for ID what cookies can be used for: authorization shopping carts recommendations user session state (Web e-mail) how to keep “state”: protocol endpoints: maintain state at sender/receiver over multiple transactions cookies: http messages carry state cookies and privacy: cookies permit sites to learn a lot about you you may supply name and e-mail to sites Web缓存Web缓存器(web cache)/代理服务器(proxy server): 代表初始Web服务器满足HTTP请求的网络实体 Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时。 Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。 goal: satisfy client request without involving origin server user sets browser: Web accesses via cache browser sends all HTTP requests to cache object in cache: cache returns object else cache requests object from origin server, then returns object to client cache acts as both client and server server for original requesting client client to origin server typically cache is installed by ISP (university, company, residential ISP) why Web caching: reduce response time for client request reduce traffic on an institution’s access link Internet dense with caches: enables “poor” content providers to effectively deliver content (so too does P2P file sharing) example: assumptions: avg object size: 100K bits avg request rate from browsers to origin servers:15/sec avg data rate to browsers: 1.50 Mbps RTT from institutional router to any origin server: 2 sec access link rate: 1.54 Mbps consequences: LAN utilization: 0.15% access link utilization = 99% total delay = Internet delay + access delay + LAN delay = 2 sec + minutes + usecs example: fatter access link raise access link rate to 154 Mbps access link utilization will change to 0.99% total delay will be 2sec and msecs and usecs example: install local cache Calculating access link utilization, delay with cache: suppose cache hit rate is 0.4; 40% requests satisfied at cache, 60% requests satisfied at origin access link utilization: 60% of requests use access link data rate to browsers over access link = 0.6*1.50 Mbps = .9 Mbps; utilization = 0.9/1.54 = .58 total delay = 0.6 (delay from origin servers) + 0.4 (delay when satisfied at cache) = 0.6 (2.01) + 0.4 (~msecs) = ~ 1.2 secs less than with 154 Mbps link (and cheaper too!) 内容分发网络(Content Distribution Network, CDN): 地理上分散的Web缓存器 条件GET方法conditional GET方法: HTTP协议允许缓存器证实它的对象是最新的的一种机制 请求报文使用GET方法，并且请求报文中包含一个”If-Modified-Since:”首部行 Goal: don’t send object if cache has up-to-date cached version no object transmission delay lower link utilization cache: specify date of cached copy in HTTP request If-modified-since: server: response contains no object if cached copy is up-to-date: HTTP/1.0 304 Not Modified 因特网中的电子邮件(Electronic mail)3个主要组成部分: 用户代理(user agent)、邮件服务器(mail server)、简单邮件传输协议(Simple Mail Transfer Protocol, SMTP) 邮箱(mailbox) User Agent a.k.a. “mail reader” composing, editing, reading mail messages; e.g., Outlook, Thunderbird, iPhone mail client outgoing, incoming messages stored on server mail servers: mailbox contains incoming messages for user message queue of outgoing (to be sent) mail messages SMTP protocol between mail servers to send email messages client: sending mail server “server”: receiving mail server SMTP限制所有邮件报文的体部分职能采用7比特ASCII码表示 HTTP是一个拉协议(pull protocol): 某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息 SMTP是一个推协议(push protocol): 发送邮件服务器把文件推向接受邮件服务器 SMTP [RFC 2821]: uses TCP to reliably transfer email message from client to server, port 25 direct transfer: sending server to receiving server three phases of transfer handshaking (greeting) transfer of messages closure command/response interaction (like HTTP) commands: ASCII text response: status code and phrase messages must be in 7-bit ASCII SMTP uses persistent connections SMTP requires message (header &amp; body) to be in 7-bit ASCII SMTP server uses CRLF.CRLF to determine end of message comparison with HTTP: HTTP: pull vs SMTP: push both have ASCII command/response interaction, status codes HTTP: each object encapsulated in its own response message vs SMTP: multiple objects sent in multipart message 邮件报文格式(Mail message format)和MIMEFrom: 首部行、To: 首部行、Subject: 首部行 SMTP: protocol for exchanging email messages RFC 822: standard for text message format: header lines, e.g., To: From: Subject: different from SMTP MAIL FROM, RCPT TO: commands!Body: the “message” ASCII characters only 邮件访问协议不能使用SMTP取回报文，取报文是一个拉操作而SMTP协议是一个推协议 SMTP: delivery/storage to receiver’s server mail access protocol: retrieval from server POP: Post Office Protocol [RFC 1939]: authorization, download IMAP: Internet Mail Access Protocol [RFC 1730]: more features, including manipulation of stored messages on server HTTP: gmail, Hotmail, Yahoo! Mail, etc. 第三版邮局协议(Post Office Protocol-Version 3, POP3) 三个阶段: 特许(authorization): 用户代理以明文形式发送用户名和口令以鉴别用户 事务处理: 用户代理取回报文，对报文做删除标记，取消报文删除标记，获取邮件的统计信息 更新: 客户发出quit命令退出POP3会话；邮件服务器删除被标记为删除的报文 邮件服务器回答: +OK正常 -ERR错误 authorization phaseclient commands: user: declare username pass: passwordserver responses +OK -ERRtransaction phase, client: list: list message numbers retr: retrieve message by number dele: delete quit more about POP3: POP3 “download-and-keep”: copies of messages on different clients POP3 is stateless across sessions 因特网邮件访问协议(Internet Mail Access Protocol, IMAP) keeps all messages in one place: at server allows user to organize messages in folders keeps user state across sessions: names of folders and mappings between message IDs and folder name DNS: 因特网的目录服务主机使用IP地址(IP address)进行标识 域名系统(Domain Name System, DNS)将主机名解析为IP地址 Internet hosts, routers: IP address (32 bit) - used for addressing datagrams “name”, e.g., www.yahoo.com - used by humans Q: how to map between IP address and name, and vice versa ? Domain Name System: distributed database implemented in hierarchy of many name servers application-layer protocol: hosts, name servers communicate to resolve names (address/name translation) note: core Internet function, implemented as application-layer protocol complexity at network’s “edge DNS是一个由分层的DNS服务器(DNS Server)实现的分布式数据库 DNS是一个使得主机能够查询分布式数据库应用层协议，运行在UDP之上，使用53号端口 主机别名(host aliasing): 通常规范主机名(canonical hostname)较为复杂 邮件服务器别名(mail server aliasing) 负载分配(load distribution): 冗余的服务器(e.g. Web服务器) DNS services: hostname to IP address translation host aliasing(canonical, alias names) mail server aliasing load distribution(replicated Web servers: many IP addresses correspond to one name) 单一DNS服务器(集中式设计)的问题(why not centralize DNS?): 单点故障(a single point of failure): DNS服务器崩溃会导致整个互联网瘫痪 通信容量(traffic volume): DNS查询体量极其大 远距离集中式数据库(distant centralized database) 维护(maintenance) 分布式设计方案(分布式层次数据库)根DNS服务器(13个)顶级域DNS服务器(一般域名 国家顶级域名 反向域名)权威DNS服务器 top-level domain (TLD) servers: responsible for com, org, net, edu, aero, jobs, museums, and all top-level country domains, e.g.: uk, fr, ca, jp Network Solutions maintains servers for .com TLD Educause for .edu TLD Top-Level Domain(TLD): Generic domains:.COM – commercial organizations.EDU – educational institutions.GOV – federal government institutions.MIL – United States military.NET – major network support centers.ORG – other organizations.INT – international organizations New Top Level Domains:| TLD | Spd/Unspd | Purpose || ——– | :——: | :—-: || .aero | spd | Air-transport industry || .biz | Unspd | Businesses || .coop | spd | Cooperatives || .info | Unspd | Unrestricted use || .museum | spd | Museums || .name | Unspd | For registration by individuals || .pro | Unspd | Accountants, lawyers, physicians, and other professionals | Country Domains: Inverse domain: authoritative DNS servers: organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts can be maintained by organization or service provider Zones and domains: Zone A primary server loads all information from the disk file; the secondary server loads all information from the primary server. When the primary downloads information from the secondary, it is called zone transfer. Authoritative Server Configuration(example): 本地DNS服务器(local DNS server): 严格上不属于DNS层次结构，但很重要 does not strictly belong to hierarchy each ISP (residential ISP, company, university) has one(also called “default name server”) when host makes DNS query, query is sent to its local DNS server has local cache of recent name-to-address translation pairs (but may be out of date!) acts as proxy, forwards query into hierarchy Name Resolution: Resolvers use UDP (single name) or TCP (whole group of names) Knowing the address of the root server is sufficient Resolvers use recursive query. Servers use iterative query. e.g.: client wants IP for www.amazon.com; 1st approximation: client queries root server to find com DNS server client queries .com DNS server to get amazon.com DNS server client queries amazon.com DNS server to get IP address for www.amazon.com contacted by local name server that can not resolve name root name server: contacts authoritative name server if name mapping not known gets mapping returns mapping to local name server 迭代查询(iterative query): 查询结果返回给请求者 contacted server replies with name of server to contact “I don’t know this name, but ask this server” host at cis.poly.edu wants IP address for gaia.cs.umass.edu: 递归查询(recusive query): 转发查询请求 puts burden of name resolution on contacted name server heavy load at upper levels of hierarchy? DNS Optimization: Spatial Locality: Local computers referenced more often than remoteTemporal Locality: Same set of domains referenced repeatedly -&gt; CachingCaching: each entry has a time to live (TTL)Replication: Multiple servers. Multiple roots. Ask the geographically closest server. DNS缓存(DNS caching): 改善时延性能并减少在因特网上到处传输的DNS报文数量 once (any) name server learns mapping, it caches mapping cache entries timeout (disappear) after some time (TTL) TLD servers typically cached in local name servers, thus root name servers not often visited cached entries may be out-of-date (best effort name-to-address translation!) if name host changes IP address, may not be known Internet-wide until all TTLs expire update/notify mechanisms proposed IETF standard, RFC 2136 DNS: distributed database storing resource records (RR, 提供主机名到IP地址的映射) RR format: (name, type, value, ttl) type=A name is hostname value is IP address type=NS name is domain (e.g., foo.com) value is hostname of authoritative name server for this domain type=CNAME name is alias name for some “canonical” (the real) name www.ibm.com is really servereast.backup2.ibm.com value is canonical name type=MX value is name of mailserver associated with name Resource Record Types:| Type | Meaning || —- | :——-: || A | Host Address || CNAME | Canonical Name (alias) || HINFO | CPU and O/S || MINFO | Mailbox Info || MX | Mail Exchanger || NS | Authoritative name server for a domain || PTR | Pointer to a domain name (link) || RP | Responsible person || SOA | Start of zone authority (Which part of naming hierarchy implemented) || TXT | Arbitrary Text | Inserting records into DNS: example: new startup “Network Utopia” register name networkutopia.com at DNS registrar (e.g., Network Solutions) provide names, IP addresses of authoritative name server (primary and secondary) register inserts two RRs into .com TLD server: (networkutopia.com, NS, dns1.networkutopia.com) (dns1.networkutopia.com, A, 212.212.212.1) create authoritative server type A record for www.networkuptopia.com; type MX record for networkutopia.com DNS报文: DNS查询和回答报文(query and reply both with same message format) message header: dentification: 16 bit # for query, reply to query uses same # flags: query or reply recursion desired recursion available reply is authoritative Domain names stored as series of labels 1 octet length (n) (top two bits of length are 00) n octet label Zero length marks end of name Attacking DNSDDoS attacks bombard root servers with traffic not successful to date traffic filtering local DNS servers cache IPs of TLD servers, allowing root server bypass bombard TLD servers potentially more dangerous redirect attacks man-in-middle Intercept queries DNS poisoning Send bogus relies to DNS server, which caches exploit DNS for DDoS send queries with spoofed source address: target IP requires amplification P2P应用Objectives of P2P: Share the resources (storage and bandwidth) of individual clients to improve scalability/ robustness Bypass DNS to find clients with resources! examples: instant messaging, skype Pure P2P architecture no always-on server arbitrary end systems directly communicate peers are intermittently connected and change IP addresses 40-70% of total traffic in many networks P2P Examples: File Sharing: BitTorrent, LimeWire Streaming: PPLive, PPStream, Zatto, … Research systems Collaborative computing: SETI@Home project Human genome mapping Intel NetBatch: 10,000 computers in 25 worldwide sites for simulations File distribution: client-server vs P2P:how much time to distribute file (size F) from one server to N peers peer upload/download capacity is limited resource client-server: server transmission: must sequentially send (upload) N file copies: time to send one copy: $F/u_s$ time to send N copies: $NF/u_s$ client: each client must download file copy $d_{min}$ = min client download rate min client download time: $F/d_{min}$ time to distribute F to N clients using client-server approach(increases linearly in N):$D_{c-s}$ &gt; max{$NF/us, F/d{min}$} P2P: server transmission: must upload at least one copy time to send one copy: $F/u_s$ client: each client must download file copy min client download time: $F/d_{min}$ time to distribute F to N clients using P2P approach(increases linearly in N, but so does this, as each peer brings service capacity):$D_{P2P}$ &gt; max{$F/us, F/d{min}, NF/(u_s + \\sum u_i)$} Napster(Centralized Database)Program for sharing music over the Internet Application-level, client-server protocol over TCP A centralized index system that maps files (songs) to machines that are alive and with files Steps: Connect to Napster server Upload your list of files (push) to server Give server keywords to search the full list Select “best” of hosts with answers Napster Architecture Napster Publish Napster Search Summary of features: a hybrid design control: client-server (aka special DNS) for files data: peer to peer Advantages: simplicity, easy to implement sophisticated search engines on top of the index system Disadvantages: application specific (compared with DNS) lack of robustness, scalability: central search server single point of bottleneck/failure easy to sue ! BitTorrent A P2P file sharing protocol Created by Bram Cohen in 2004 A peer can download pieces concurrently from multiple locations A global central index server is replaced by one tracker per file (called a swarm), reduces centralization; but needs other means to locate trackers The bandwidth scalability management technique is more interesting torrent(洪流): 参与一个特定文件分发的所有对等方(peer)的集合 追踪器(tracer) Metadata File Structure: Meta info contains information necessary to contact the tracker and describes the files in the torrent announce URL of tracker file name file length piece length (typically 256KB) SHA-1 hashes of pieces for verification also creation date, comment, creator, … Tracker Protocol: Communicates with clients via HTTP/HTTPS Client GET request info_hash: uniquely identifies the file peer_id: chosen by and uniquely identifies the client client IP and port numwant: how many peers to return (defaults to 50) stats: e.g., bytes uploaded, downloaded Tracker GET response interval: how often to contact the tracker list of peers, containing peer id, IP and port stats Robustness: A swarming protocol Peers exchange info about other peers in the system Peers exchange piece availability and request blocks from peers 块(chunk) Peer Protocol: Over TCP Unchoke: indicate if A allows B to download Interest/request: indicate which block to send from B to A incentive Periodically (typically every 10 seconds) calculate data-receiving rates from all peers Upload to (unchoke) the fastest constant number (4) of unchoking slots partition upload bw equally among unchoked commonly referred to as “tit-for-tat” strategy(一报还一报) Optimistic Unchoking Periodically select a peer at random and upload to it typically every 3 unchoking rounds (30 seconds) Multi-purpose mechanism allow bootstrapping of new clients continuously look for the fastest peers (exploitation vs exploration) Block Availability Request (local) rarest first(最稀缺优先) achieves the fastest replication of rare pieces obtain something of value Revisions When downloading starts (first 4 pieces): choose at random and request them from the peers get pieces as quickly as possible obtain something to offer to others Endgame mode defense against the “last-block problem”: cannot finish because missing a few last pieces send requests for missing sub-pieces to all peers in our peer list send cancel messages upon receipt of a sub-piece Summary Very widely used mainline: written in Python Azureus and μTorrent: the most popular Other popular clients: ABC, BitComet, BitLord, BitTornado, Opera browser Many explorations, e.g., BitThief BitTyrant Better understanding is needed Gnutella文件共享网络 Decentralized Flooding: Gnutella On startup, client contacts other servents (server + client) in network to form interconnection/peering relationships servent interconnection used to forward control (queries, hits, etc) How to find a resource record: decentralized flooding send requests to neighbors neighbors recursively forward the requests Each node forwards the query to its neighbors other than the one who forwards it the query Each node should keep track of forwarded queries to avoid loop: nodes keep state (which will time out—soft state) carry the state in the query, i.e. carry a list of visited nodes Basic message header: Unique ID, TTL, Hops Message types: Ping : probes network for other servents Pong : response to ping, contains IP addr, # of files, etc. Query : search criteria + speed requirement of servent QueryHit : successful response to Query, contains addr + port to transfer from, speed of servent, etc. Ping, Queries are flooded QueryHit, Pong: reverse path of previous message Advantages: totally decentralized, highly robust Disadvantages: not scalable; the entire network can be swamped with flood requests: especially hard on slow clients; at some point broadcast traffic on Gnutella exceeded 56 kbps to alleviate this problem, each request has a TTL to limit the scopeeach query has an initial TTL, and each node forwarding it reduces it by one; if TTL reaches 0, the query is dropped (consequence?) Flooding: FastTrack (aka Kazaa) Modifies the Gnutella protocol into two-level hierarchy Supernodes Nodes that have better connection to Internet Act as temporary indexing servers for other nodes Help improve the stability of the networkStandard nodes Connect to supernodes and report list of filesSearch Broadcast (Gnutella-style) search across supernodesDisadvantagesKept a centralized registration -&gt; prone to law suits 分布式散列表(Distributed Hash Table, DHT)DHT Overview Abstraction: a distributed “hash-table” (DHT) data structure put(key, value) and get(key) -&gt; value DHT imposes no structure/meaning on keys one can build complex data structures using DHT Implementation: nodes in system form an interconnection network: ring, zone, tree, hypercube, butterfly network, … DHT Applications File sharing and backup [CFS, Ivy, OceanStore, PAST, Pastiche …] Web cache and replica [Squirrel, Croquet Media Player] Censor-resistant stores [Eternity] DB query and indexing [PIER, Place Lab, VPN Index] Event notification [Scribe] Naming systems [ChordDNS, Twine, INS, HIP] Communication primitives [I3, …] Host mobility [DTN Tetherless Architecture] Key Issues in Understanding a DHT Design: How does the design map keys to internal representation (typically a metric space)? Which space is a node responsible? How are the nodes linked? e.g. … Content Addressable Network(CAN)Abstraction map a key to a “point” in a multi-dimensional Cartesian space a node “owns” a zone in the overall space route from one “point” to another CAN Example: Two Dimensional Space Space divided among nodes Each node covers either a square or a rectangular area of ratios 1:2 or 2:1 CAN Insert Example:node I::insert(K,V) (1) a = hx(K) b = hy(K) (2) route(K,V) -&gt; (a,b) Routing: A node maintains state only for its immediate neighboring nodes Forward to neighbor which is closest to the target point a type of greedy, local routing scheme (3) (K,V) is stored at (a,b) CAN Retrieve Example:node J::retrieve(K) (1) a = hx(K) b = hy(K) (2) route “retrieve(K)” to (a,b) CAN Insert: Join CAN Evaluations Guarantee to find an item if in the network Load balancing hashing achieves some load balancing overloaded node replicates popular entries at neighbors Scalability for a uniform (regularly) partitioned space with n nodes and d dimensions storage: per node, number of neighbors is 2d a fixed d can scale the network without increasing per-node state routing average routing path is $(dn^{1/d})/3$ hops (due to Manhattan distance routing, expected hops in each dimension is dimension length * 1/3) Chord: search by routing/consistent hashing Space is a ring Consistent hashing: m bit identifier space for both keys and nodes key identifier = SHA-1(key), where SHA-1() is a popular hash function: Key=“Matrix3” -&gt; ID=60 node identifier = SHA-1(IP address) IP=“198.10.10.1” -&gt; ID=123 Chord: Storage using a Ring A key is stored at its successor: node with next higher or equal ID how to Search(One Extreme) Every node knows of every other node Routing tables are large O(N) Lookups are fast O(1) how to Search(the Other Extreme) Every node knows its successor in the ring Routing tables are small O(1) Lookups are slow O(N) Chord Solution: “finger tables” Node K knows the node that is maintaining K + 2i, increase distance exponentially Joining the Ring use a contact node to obtain info transfer keys from successor node to new node updating fingers of existing nodes DHT: Chord Node Join Assume an identifier space [0..8] Node n1 joins Node n2 joins Node n6 joins Node n0 joined DHT: Chord Insert Items Nodes: n1, n2, n0, n6 Items: f7, f1 Upon receiving a query for item id, a node: checks whether stores the item locally if not, forwards the query to the largest node in its successor table that does not exceed id Chord/CAN Summary Each node “owns” some portion of the key-space in CAN, it is a multi-dimensional “zone” in Chord, it is the key-id-space between two nodes in 1-D ring Files and nodes are assigned random locations in key-space provides some load balancing probabilistically equal division of keys to nodes Routing/search is local (distributed) and greedy node X does not know of a path to a key Z but if it appears that node Y is the closest to Z among all of the nodes known to X so route to Y video streaming and content distribution networks (CDNs)(流式视频和内容分发网络)Multimedia: video video: sequence of images displayed at constant rate e.g., 24 images/sec digital image: array of pixels each pixel represented by bits coding: use redundancy within and between images to decrease # bits used to encode image spatial (within image) spatial coding example: instead of sending N values of same color, send only two values: color value and number of repeated values (N) temporal (from one image to next) temporal coding example: instead of sending complete frame at i+1, send only differences from frame i CBR: (constant bit rate): video encoding rate fixed VBR: (variable bit rate): video encoding rate changes as amount of spatial, temporal coding changes examples: MPEG 1 (CD-ROM) 1.5 Mbps MPEG2 (DVD) 3-6 Mbps MPEG4 (often used in Internet, &lt; 1 Mbps) Streaming stored video(流式存储视频) simple scenario: video server(stored video) -&gt; Internet -&gt; client challenge: heterogeneity different users have different capabilities (e.g., wired versus mobile; bandwidth rich versus bandwidth poor) Streaming multimedia: DASH(Dynamic Adaptive Streaming over HTTP) server: divides video file into multiple chunks each chunk stored, encoded at different rates manifest file(文件清单): provides URLs for different chunks client: periodically measures server-to-client bandwidth consulting manifest, requests one chunk at a time chooses maximum coding rate sustainable given current bandwidth can choose different coding rates at different points in time (depending on available bandwidth at time) “intelligence” at client: client determines when to request chunk (so that buffer starvation, or overflow does not occur) what encoding rate to request (higher quality when more bandwidth available) where to request chunk (can request from URL server that is “close” to client or has high available bandwidth) Content distribution networks(CDN, 内容分发网络)video traffic: major consumer of Internet bandwidth challenge: how to stream content (selected from millions of videos) to hundreds of thousands of simultaneous users? option 1: single, large “mega-server” single point of failure point of network congestion long path to distant clients multiple copies of video sent over outgoing link quite simply: this solution doesn’t scale option 2: store/serve multiple copies of videos at multiple geographically distributed sites (CDN) enter deep: push CDN servers deep into many access networks close to users used by Akamai, 1700 locations bring home: smaller number (10’s) of larger clusters in POPs near (but not within) access networks used by Limelight CDN: stores copies of content at CDN nodes e.g. Netflix stores copies of MadMen subscriber requests content from CDN directed to nearby copy, retrieves content may choose different copy if network path congested OTT(over the top) challenges: coping with a congested Internet from which CDN node to retrieve content? viewer behavior in presence of congestion? what content to place in which CDN node? Caching explicit(明确的) transparent (hijacking connections)Replication server farms(服务器群) geographically dispersed(分散)(CDN) Traditional: Performance move content closer to the clients avoid server bottlenecksNew: DDoS Protection dissipate attack over massive resources multiplicatively raise level of resources needed to attack Denial of Service Attacks (DoS) Distributed DoS (DDoS) Redirection Overlay TechniquesDNS one name maps onto many addresses works for both servers and reverse proxiesHTTP requires an extra round tripRouter one address, select a server (reverse proxy) content-based routing (near client)URL Rewriting embedded links RidirectionHashing Schemes: Modulo Easy to compute Evenly distributed Good for fixed number of servers Many mapping changes after a single server change Consistent Hashing (CHash) Hash server, then URL Closest match Only local mapping changes after adding or removing servers Used by State-of-the-art CDNs Highest Random Weight (HRW) Hash(url, svrAddr) Deterministic order of access set of servers Different order for different URLs Load evenly distributed after server changes Redirection Strategies Random (Rand) Requests randomly sent to cooperating servers Baseline case, no pathological behavior Replicated Consistent Hashing (R-CHash) Each URL hashed to a fixed # of server replicas For each request, randomly select one replica Replicated Highest Random Weight (R-HRW) Similar to R-CHash, but use HRW hashing Less likely two URLs have same set of replicas Coarse(粗略) Dynamic Replication (CDR) Using HRW hashing to generate ordered server list Walk through server list to find a lightly loaded one of replicas for each URL dynamically adjusted Coarse grained server load information Fine Dynamic Replication (FDR) Bookkeeping min # of replicas of URL (popularity) Let more popular URL use more replicas Keep less popular URL from extra replication ReplicationWhy Replicate? Performance keep copy close to remote users caching is a special case Survive Failures availability: provide service during temporary failure fault tolerance: provide service despite catastrophic failure Fault Models Crashed failed device doesn’t do anything (i.e., fails silently) Fail-Stop failed device tells you that it has failed Byzantine(拜占庭将军问题,Byzantine Generals Problem) failed device can do anything adversary playing a game against an evil opponent opponent knows what you’re doing and tries to fool you usually some limit on opponent’s actions (e.g. at most k failures) 拜占庭将军问题 (Byzantine Generals Problem)，是由莱斯利兰伯特提出的点对点通信中的基本问题。 在分布式计算上，不同的计算机透过讯息交换，尝试达成共识；但有时候，系统上协调计算机 (Coordinator / Commander) 或成员计算机 (Member / Lieutanent) 可能因系统错误并交换错的讯息，导致影响最终的系统一致性。拜占庭将军问题就根据错误计算机的数量，寻找可能的解决办法 (但无法找到一个绝对的答案，只可以用来验证一个机制的有效程度)。 Synchrony Assumptions concerning boundedness of component execution or network transmissions Synchronous always performs function in a finite &amp; known time bound Asynchronous no such bound Famous Result: A group of processes cannot agree on a value in an asynchronous system given a single crash failure Network Partitions Can’t tell the difference between a crashed process and a process that’s inaccessible due to a network failure. Network Partition: network failure that cuts processes into two or more groups full communication within each group no communication between groups danger: each group thinks everyone else is dead Mirroring Goal: service up to K failures Approach: keep K+1 copies of everything Clients do operations on “primary” copy Primary makes sure other copies do operations too Advantage: simple Disadvantages: do every operation K times use K times more storage than necessary Mirroring Details Optimization: contact one replica to read What if a replica fails? get up-to-date data from primary after recovering What if primary fails? elect a new primary Election Problem When algorithm terminates, all non-failed processes agree on which replica is the primary Algorithm works despite arbitrary failures and recoveries during the election If there are no more failures and recoveries, the algorithm must eventually terminate Bully Algorithm Use fixed “pecking order” among processes e.g., use network addresses Idea: choose the “biggest” non-failed machine as primary Correctness proof is difficult Bully Algorithm Details Process starts an election whenever it recovers or whenever primary has failed how to know primary has failed?(一段时间无响应) To start an election, send election messages to all machines bigger than yourself if somebody responds with an ACK, give up if nobody ACKs, declare yourself the primary On receiving election message, reply with ACK and start an election yourself (unless in progress) Quorums Quorum(法人): a set of server machines Define what constitutes a “read quorum” and a “write quorum” To write acquire locks on all members of some write quorum do writes on all locked servers release locks To read: similar, but use read quorum Correctness requirements any two write quorums must share a member any read quorum and any write quorum must share a member (read quorums need not overlap(覆盖)) Locking ensures that at most one write happening at a time never have a write and a read happening at the same time Defining Quorums Many alternatives Example write quorum must contain all replicas read quorum may contain any one replica Consequence writes are slow, reads are fast can write only if all replicas are available can read if any one replica is available Example: Majority Quorum write quorum: any set with more than half the replicas read quorum: any set with more than half the replicas Consequences modest(适度) performance for read and write can proceed(进行) as long as more than half the replicas are available Quorums &amp; Version Numbers Write operation writes only a subset of the servers some servers are out-of-date Remedy(纠正方法) put version number stamp on each item in each replica when acquiring locks, get current version number from each replica quorum overlap rules ensure that one member of your quorum has the latest version When reading, get the data from the latest version number in your quorum When writing, set version number of all replicas you wrote equal to 1 + (max version number in your quorum beforehand) Guarantees correctness even if no recovery action is taken when replica recovers from a crash Quorums and Partitions One group has a write quorum (and thus usually a read quorum); that group can do anything other groups are frozen No group has a write quorum, but some groups have a read quorum some groups can read no groups can write No group contains any quorum everyone is frozen socket programming with UDP and TCPWhat is “socket” A socket is a virtual connection between two applications Using a socket, two processes can communicate with each other The socket is the major communication tool for Internet applications A socket is bi-directional (full-duplex) transmission A socket can be created dynamically Socket as a virtual connection between two processes Socket as a client/server model Port: a logical connecting point at the transport-layer protocol. Socket programmingTwo socket types for two transport services: UDP: unreliable datagram TCP: reliable, byte stream-oriented Application Example: client reads a line of characters (data) from its keyboard and sends data to server server receives the data and converts characters to uppercase server sends modified data to client client receives modified data and displays line on its screen Socket programming with TCP client must contact server server process must first be running server must have created socket (door) that welcomes client’s contact client contacts server by: Creating TCP socket, specifying IP address, port number of server process when client creates socket: client TCP establishes connection to server TCP when contacted by client, server TCP creates new socket for server process to communicate with that particular client allows server to talk with multiple clients source port numbers used to distinguish clients application viewpoint:TCP provides reliable, in-order, byte-stream transfer (“pipe”) between client and server Client/Server Process Organization Unix Socket Programming Technical Details Unix TCP server(1) create socket: socket_id = socket (AF_INET, SOCK_STREM, DEFAULT_PROTOCOL);(2) bind socket: bind (socket_id, server_addr, server_len);(3) listen to socket: listen (socket_id, number_of_connection);(4) accept a connection: accept (socket_id, &amp;client_addr, &amp;client_len);(5) read (receive) data: read (socket_id, buffer, buffer_len);(6) write (send) data: write (socket_id, buffer, buffer_len);(7) close socket: close(socket_id); Unix TCP client(1) create socket: same as server socket_id = socket (AF_INET, SOCK_STREM, DEFAULT_PROTOCOL);(2) connect socket: connect (socket_id, serverINETaddress, server_len);(3) write (send) data: write (socket_id, buffer, buffer_len);(4) read (receive) data: read (socket_id, buffer, buffer_len);(5) close socket: same as server close(socket_id); Step 1: socket(…) call It declares a socket to be used.Prepare data structure to manage socketOS is responsible for this Step 2: bind(…) call It connects a process to a specific portPort = A logical connecting point at a host for two communicating processes using socketPort Numbers:0~1023: System ReservedPort 21: FTPPort 23: telnetPort 80: HTTP1024 and above: available to users Step 3: listen(…) call listen() system call: prepare memory buffer for incoming connectionslisten (socket_id, number_of_connection) -&gt; We need to specify how many connection requests should be held in the buffer when SERVER is busy (can’t accept a request). Step 4 - Part 1: accept(…) call The server process accepts a request from a clientaccept() function is a blocking function Step 4 - Part 2: accept(…) call The accept(_) call returns another port number and establish another connection Step 5: read( ) and write( ) call The server and client communicate using the second socket Step 6: close ( ) call Close the second socket and leave the first socket for next client Step 7: Go back to accept(…) call The server process goes back to the accept call Winsock Programming Technical Details Initialize Winsock Step 1: Define your socketStep 2: Initialize your socketStep 3: Start using it 1234567891011void main (void)&#123; /* The following two lines needed for Window's socket */ // Winsock version 2.2 WORD wVersionRequested = MAKEWORD(2,2); /* Stuff for WSA functions */ WSADATA wsaData; /* Stuff for WSA functions */ /* This stuff initializes winsock*/ WSAStartup(wVersionRequested, &amp;wsaData); /* Create a socket */ My_SocketID = socket ( ….. ); socket ( ) function : Returns socket ID on success unsigned int socket_id = socket (AF_INET, SOCK_STREAM, 0); bind ( ) function : Return code (&lt; 0 if error) int status = bind (socket_id, (struct sockaddr_in *) my_addr, sizeof(my_addr)); The sockaddr_in structure to specify port # and IP address of this machine (server machine) The “sock_addr” structureStep 1: You instantiate the structureStep 2: Fill up the components 123456struct sockaddr_in my_addr; /* My (client) Internet address *//* Set My(client's) IP Address ---------------------------------------- */my_addr.sin_family = AF_INET; /* Address Family To Be Used */ my_addr.sin_port = htons (MY_PORT_NUM); /* Port number to use */ my_addr.sin_addr.s_addr = htonl (INADDR_ANY); /* My IP address */ listen ( ) function : Return code (&lt; 0 if error) int status = listen (socket_id, 3); The size of the connection request buffer(3) accept ( ) function : duplicated socket ID (&lt; 0 if error) unsingned int child_sock = accept (socket_id, (struct sockaddr_in *) client_addr, sizeof (client_addr); recv ( ) function : On success, the number of bytes received; Return code (&lt; 0 if error) int status = recv (child_sock, in_buffer, MAX_BUFFER_SIZE, 0); The input (receive) buffer as a character string Example: char in_buffer [MAX_BUFFER] send ( ) function : On success, the number of bytes actually sent; Return code (&lt; 0 if error) int status = send (child_sock, out_buffer, MAX_BUFFER_SIZE, 0); closesocket ( ) function : Return code (&lt; 0 if error) int status = closesocket (child_sock); Clear winsockAfter you call “closesocket” function but before your program is terminated 12/* This stuff cleans-up winsock */WSACleanup( ); How to specify your destination in socket? Each destination for a socket connection is determined by &lt; IP address + Port# &gt; sockaddr_in structure is used to define your destination The sockaddr_in structure is defined in C/C++ struct The sockaddr_in structure is defined in windows.h header file 1234567struct sockaddr_in &#123; u_char sin_len; /* Length of this structure */ u_char sin_family; /* Network protocol used*/ u_short sin_port; /* Port number */ struct in_addr sin_addr; /* Pointer to an IP address */ char sin_zero[8]; /* Extra information */&#125;; 123struct in_addr &#123; u_long s_addr; /* Actual IP address */&#125;; How can I set the IP address and the port number of my destination? STEP #1: Instantiate a sockaddr_in structure: STEP #2: Set your destination IP address: Case 1: by “32-bit IP address”: server_address.sin_addr.s_addr = inet_addr(“146.163.147.59”); Case 2: by a host name: server_address.sin_addr.s_addr = inet_aton(“cougar.siue.edu”); Case 3: by a system-defined parameter: server_address.sin_addr.s_addr = htonl(INADDR_ANY); STEP #3: Set your destination port number: server_address.sin_port = htons(80); Python Programming Technical Details Python TCPClient:12345678910from socket import * #include Python’s socket libraryserverName = ’servername’serverPort = 12000clientSocket = socket(AF_INET, SOCK_STREAM) create TCP socket for server, remote port 12000clientSocket.connect((serverName,serverPort))sentence = raw_input(‘Input lowercase sentence:’)clientSocket.send(sentence.encode()) # No need to attach server name, port modifiedSentence = clientSocket.recv(1024)print (‘From Server:’, modifiedSentence.decode())clientSocket.close() Python TCPServer:1234567891011121314151617 from socket import *serverPort = 12000serverSocket = socket(AF_INET,SOCK_STREAM) # create TCP welcoming socketserverSocket.bind((‘’,serverPort))serverSocket.listen(1) # server begins listening for incoming TCP requestsprint ‘The server is ready to receive’while True: # loop forever # server waits on accept() for incoming requests, new socket created on return connectionSocket, addr = serverSocket.accept() # read bytes from socket (but not address as in UDP) sentence = connectionSocket.recv(1024).decode() capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence.encode()) # close connection to this client (but not welcoming socket) connectionSocket.close() Socket programming with UDP UDP: no “connection” between client &amp; server no handshaking before sending data sender explicitly attaches IP destination address and port # to each packet receiver extracts sender IP address and port# from received packet UDP: transmitted data may be lost or received out-of-order Application viewpoint: UDP provides unreliable transfer of groups of bytes (“datagrams”) between client and server Client/server socket interaction: UDP Python UDPClient1234567891011121314from socket import *serverName = ‘hostname’serverPort = 12000# create UDP socket for serverclientSocket = socket(AF_INET, SOCK_DGRAM)# get user keyboard inputmessage = raw_input(’Input lowercase sentence:’)# Attach server name, port to message; send into socketclientSocket.sendto(message.encode(), (serverName, serverPort))# read reply characters from socket into stringmodifiedMessage, serverAddress = clientSocket.recvfrom(2048)# print out received string and close socketprint modifiedMessage.decode()clientSocket.close() 12345678910111213from socket import *serverPort = 12000# create UDP socketserverSocket = socket(AF_INET, SOCK_DGRAM)# bind socket to local port number 12000serverSocket.bind(('', serverPort))print (“The server is ready to receive”)while True: # loop forever # Read from UDP socket into message, getting client’s address (client IP and port) message, clientAddress = serverSocket.recvfrom(2048) modifiedMessage = message.decode().upper() # send upper case string back to this client serverSocket.sendto(modifiedMessage.encode(), clientAddress)","categories":[],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://chenfeng.github.io/tags/computer-network/"}]},{"title":"数值计算中的并行算法","slug":"parellel_and_distributed_computing/paralell_compute8","date":"2017-04-17T16:00:00.000Z","updated":"2017-04-23T12:51:35.879Z","comments":true,"path":"2017/04/18/parellel_and_distributed_computing/paralell_compute8/","link":"","permalink":"https://chenfeng.github.io/2017/04/18/parellel_and_distributed_computing/paralell_compute8/","excerpt":"(并行与分布式计算七) Arithmetic Computations 线性递推式(linear recurrences)m阶线性递推式(linear recurrece of order m):$yi$由$ y{i-1}, y{i-2}, …, y{i-m} $的线性组合生成 多项式求值A = ($ a_0, a_1, …, a_n $)是多项式$ p(x) = a_0x^n + a1x^{n-1 + … + a{n-1}x} + a_n $的系数数组，给定点$x_0$计算$p(x_0)$ Horner’s algorithm(多项式求值的经典算法: 使用n次乘法和n次加法)$$ p(x_0) = (…((a_0x_0 +a_1)x_0 + a_2)x0 + … + a{n-1})x_0 + a_n $$","text":"(并行与分布式计算七) Arithmetic Computations 线性递推式(linear recurrences)m阶线性递推式(linear recurrece of order m):$yi$由$ y{i-1}, y{i-2}, …, y{i-m} $的线性组合生成 多项式求值A = ($ a_0, a_1, …, a_n $)是多项式$ p(x) = a_0x^n + a1x^{n-1 + … + a{n-1}x} + a_n $的系数数组，给定点$x_0$计算$p(x_0)$ Horner’s algorithm(多项式求值的经典算法: 使用n次乘法和n次加法)$$ p(x_0) = (…((a_0x_0 +a_1)x_0 + a_2)x0 + … + a{n-1})x_0 + a_n $$ $ y_1 = a_0x_0 + a_1 $$ y_2 = y_1x_0 + a_2 $$ . $$ . $$ . $$ p(x_0) = yn = y{n-1}x_0 + a_n $ 即如下一阶递推式:$ y_0 = a_0 $$ y_i = y_ix_0 + a_i, 1 \\leq i \\leq n $ 三对角线矩阵的LDU分解(LDU Factorization of a Tridiagonal Matrix) n*n 非奇异(nonsingular)三对角线矩阵A$$ A =\\left[\\begin{matrix} b_1 &amp; c_1 &amp; &amp; &amp; &amp; \\ a_2 &amp; b_2 &amp; c_2 &amp; &amp; &amp; \\&amp; a_3 &amp; b_3 &amp; c_3 &amp; &amp; \\\\ &amp; . &amp; . &amp; . &amp; &amp; \\\\ &amp; &amp; . &amp; . &amp; . &amp; \\\\ &amp; &amp; &amp; a_{n-1} &amp; b_{n-1} &amp; c_{n-1}\\\\ &amp; &amp; &amp; &amp; a_n &amp; b_n \\end{matrix}\\right]$$ A的LDU分解: 单位下三角矩阵L, 对角矩阵D和单位上三角矩阵U; A = LDU 易证三个矩阵形式如下$$ L =\\left[\\begin{matrix} 1 &amp; &amp; &amp; &amp; &amp; \\ l_2 &amp; 1 &amp; &amp; &amp; &amp; \\ &amp; l_3 &amp; 1 &amp; &amp; &amp; \\\\ &amp; &amp; . &amp; . &amp; &amp; \\\\ &amp; &amp; &amp; . &amp; . &amp; \\\\ &amp; &amp; &amp; &amp; . &amp; . \\\\ &amp; &amp; &amp; &amp; l_n &amp; 1 \\end{matrix}\\right]$$$$ U =\\left[\\begin{matrix} 1 &amp; u_1 &amp; &amp; &amp; &amp; \\ &amp; 1 &amp; u_2 &amp; &amp; &amp; \\\\ &amp; &amp; 1 &amp; u_3 &amp; &amp; \\\\ &amp; &amp; &amp; . &amp; . &amp; \\\\ &amp; &amp; &amp; &amp; . &amp; u_{n-1} \\\\ &amp; &amp; &amp; &amp; &amp; 1 \\end{matrix}\\right]$$$$ D =\\left[\\begin{matrix} d_1 &amp; &amp; &amp; &amp; &amp; \\ &amp; d_2 &amp; &amp; &amp; &amp; \\\\ &amp; &amp; . &amp; &amp; &amp; \\\\ &amp; &amp; &amp; . &amp; &amp; \\\\ &amp; &amp; &amp; &amp; . &amp; \\\\ &amp; &amp; &amp; &amp; &amp; d_n \\end{matrix}\\right]$$其中$ d_1 = b_1 $$ d_j = b_j - ajc{j-1}/d_{j-1}, 2 \\leq j \\leq n $$ l_j = aj/d{j-1}, 2 \\leq j \\leq n $$ u_j = c_j/d_j, 1 \\leq j \\leq n - 1 $ $l_j$和$u_j$的值可以有$d_j$快速得到 使$d_j = wj/w{j-1}, w_0 = 1, w_1 = b_1$ $w_j$可由下列二阶递推式计算:$w_0 = 1$$w_1 = b_1$$w_j = bjw{j-1} - (ajc{j-1})w_{j-2}, 2 \\leq j \\leq n$ 三对角线矩阵A的LDU分解转化成求解二阶线性递推式 带状三角线性系统(Banded Triangular Linear Systems)n*n 下三角矩阵A, 其中所有非零元在主对角线或者其下的m-1对角线上(m &lt; n) e.g. (m = 3):$$ A =\\left[\\begin{matrix} a{11} &amp; 0 &amp; 0 &amp; 0 &amp; … &amp; … &amp; 0 \\ a{21} &amp; a{22} &amp; 0 &amp; 0 &amp; … &amp; … &amp; 0 \\ a{31} &amp; a{32} &amp; a{33} &amp; 0 &amp; . &amp; . &amp; . \\ 0 &amp; a{42} &amp; a{43} &amp; a_{44} &amp; &amp; &amp; \\ &amp; &amp; . &amp; . &amp; . &amp; . &amp; . \\\\ &amp; &amp; &amp; . &amp; . &amp; . &amp; 0\\\\ &amp; &amp; &amp; &amp; a_{n,n-2} &amp; a_{n, n-1} &amp; a_{nn} \\end{matrix}\\right]$$ 线性系统$ Ax = b $的解可以表示为:$ x_1 = \\frac{b1}{a{11}} $$ xi = -(\\sum{j=i-m+1}^{i-1}\\frac{a{ij}}{a{i1}}x_j) - \\frac{bi}{a{i1}}, 2 \\leq i \\leq n $ 该解是一个m-1阶线性递推式 一阶线性递推式(first-order linear recurrences)$ y_1 = b_1 $$ y_i = aiy{i-1} + b_i, 2 \\leq i \\leq n $ 基本思想： 类似于前缀和的计算(若对所有i有$a_i = 1$，则为前缀和计算) 用平衡树方法 不妨设$n = 2^k$，i($2\\leq i \\leq n$)为偶数，则$y_i = ai(a{i-1}y{i-2} + b{i-1}) + b_i$，即$y_i = aia{i-1}y_{i-2} + aib{i-1} + b_i$ 这是对偶数下标i的一阶线性递推式(size: n/2) 使$ai^{‘} = a{2i}a_{2i-1}$和$bi^{‘} = a{2i}b{2i-1} + b{2i}$, $1 \\leq i \\leq \\frac{n}{2}$, 同时使$zi = y{2i}$, 则得到下列递推式:$ z_1 = b_1^{‘} $$ z_i = ai^{‘}z{i-1} + b_i^{‘}, 2 \\leq i \\leq n/2 $ Algorithm 8.11234567891011121314(First-Order linear Recurrence)Input: Two arrays B = (b_1, b_2, ..., b_n) and A = (a_1 = 0, a_2, ..., a_n) representing the first-order linear recurrence y_1 = b_1 and y_i = a_iy_&#123;i-1&#125; + b_i, (2 &lt;= i &lt;= n); n is assumed to be a power of 2.Output: The values of all the y_i terms.begin1. if n = 1 then &#123;set y_1 := b_1, exit&#125;2. for 1 &lt;= i &lt;= n/2 pardo Set a_i^&#123;&apos;&#125; := a_&#123;2i&#125;a_&#123;2i-1&#125; Set b_i^&#123;&apos;&#125; := a_&#123;2i&#125;b_&#123;2i-1&#125; + b_&#123;2i&#125;3. Recursively, solve the first-order linear recurrence defined by z_1 = b_1^&#123;&apos;&#125; and z_i = a_i^&#123;&apos;&#125;z_&#123;i-1&#125; + b_i^&#123;&apos;&#125;, where 2 &lt;= i &lt;= n/2.4. for 1 &lt;= i &lt;= n pardo i even : Set y_i := z_&#123;i/2&#125; i = 1 : Set y_1 := b_1 i odd &gt; 1 : Set y_i = a_iz_&#123;(i-1)/2&#125; + b_iend $ T(n) = T(n/2) + O(1) $ $ W(n) = W(n/2) + O(n) $ 并行复杂度: T(n) = O(logn), W(n) = O(n) 高维(一阶)线性递推式((first-order)higher-demensional linear recurrences) m维向量$b_i(1 \\leq i \\leq n)$, mm矩阵$A_i(2 \\leq i \\leq n)$, 递推式如下:$ y_1 = b_1 $*$ y_i = Aiy{i-1} + b_i $, $2 \\leq i \\leq n$ 将问题规约为通过计算$Ai^{‘} = A{2i}A_{2i-1}$和$bi^{‘} = A{2i}b{2i-1} + b{2i}, 1 \\leq i \\leq n/2$求解$y_2, y_4, …, y_n$ $y_2i = Ai^{‘}y{2(i-1)} + b_i^{‘}$; 偶数下标y值得出后容易通过定义算得奇数下标y值 将Algorithm8.1中相应元素换为矩阵和向量即可 两个mm 矩阵乘积的可以在O(logm)的时间复杂度内用O(M(m))计算量复杂度求得，其中M(m)是计算mm矩阵乘积所需要的数学操作数量的时序约束(sequential bound)，目前可知的最好上界是$M(m) = O(m^2.376)$(over a ring) 并行复杂度: T(n) = O(lognlogm); W(n) = O(nM(m)) 三角线性方程组(Triangular Linear Systems) 高斯消元法(Gaussian elimination scheme)可以将任意的线性方程组化简为三角矩阵 再用标准前向替换法(standard forward substitution algorithm)可以求解 单位下三角矩阵及其线性方程线性方程组$Ax = b$, 其中$x$和$b是n维向量$, A是n*n 单位下三角矩阵:$$ A = \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; … &amp; 0 \\ a{21} &amp; 1 &amp; 0 &amp; … &amp; 0 \\ a{31} &amp; a{32} &amp; 1 &amp; … &amp; 0 \\ . &amp; . &amp; . &amp; . &amp; . \\ a{n1} &amp; a{n2} &amp; … &amp; a{n,n-1} &amp; 1 \\end{matrix} \\right]$$ 对任意矩阵，通过将每行元素除以$a{ii}(a{ii} \\not= 1, 1 \\leq i \\leq n)$可得到以上形式的矩阵 简单方法: $x_i = bi - \\sum{j=1}^{i-1}a_{ij}x_j$; 需要O(n^2)的计算量, 但无法求得并行算法 快速矩阵求逆并行算法用分治策略求出矩阵$A$的逆$A^{-1}$，则$x = A^{-1}b$能在$O(logn)$时间内用$O(n^2)$计算量求得 矩阵分块: 将矩阵$A$分成(n/2) * (n/2)的块(不妨设n是2的幂)$$ A =\\left[\\begin{matrix} A_1 &amp; 0 \\ A_2 &amp; A_3\\end{matrix}\\right]$$ $A_1$和$A_3$是非奇异下三角矩阵 非奇异矩阵: 行列式不为零(存在逆矩阵)$$ A^{-1} =\\left[\\begin{matrix} A_1^{-1} &amp; 0 \\ -A_3^{-1}A_2A_1^{-1} &amp; A_3^{-1}\\end{matrix}\\right]$$ n*n 三角线性方程组可以在$O(log^2n)$时间复杂度，O(M(n))的计算量内求解 $T(n) = O(log^2n) = O(logn) * O(log^n)$: O(logn) (分治)迭代; O(logn) 维数&lt;=(n/2)的矩阵乘法 $W(n) = 2W(n/2) + 2M(n/2)$: 假设$M(n) \\geq 4M(n/2)$可得$W(n) \\leq M(n)$ 带状三角形线性方程组e.g.(n = 6, m = 3)$$ A = \\left[ \\begin{matrix} a{11} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ a{21} &amp; a{22} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ a{31} &amp; a{32} &amp; a{33} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; a{42} &amp; a{43} &amp; a{44} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; a{53} &amp; a{54} &amp; a{55} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; a{64} &amp; a{65} &amp; a_{66} \\end{matrix} \\right]$$ 不失一般性假设主对角线元等于1，$Ax = b$的解可以表示为$ x_1 = b_1 $$ xi = (-\\sum{j=i-m+1}^{i-1}a_{ij}x_j) + b_i, 2 \\leq i \\leq n $ 不妨设m能整除n，将A分成m*m 的块$A{i,j}, 1 \\leq i,j \\leq n/m$; $A{i,i}$是下三角矩阵，$A_{i,i-1}$是上三角矩阵e.g.: 设D为如下子矩阵:$$ D =\\left[\\begin{matrix}A{1,1} &amp; &amp; &amp; \\&amp; A{2,2} &amp; &amp; \\&amp; &amp; . &amp; \\ &amp; &amp; &amp; A_{\\frac{n}{m},\\frac{n}{m}}\\end{matrix}\\right]$$ 使$A^{} = D^{-1}A$, 使$d = D^{-1}b$; $Ax = b$的解同$D_{-1}Ax = D^{-1}b$, 即$A^{}x = b$, $A^{}$如下:$$ A =\\left[\\begin{matrix}Im &amp; &amp; &amp; &amp; \\A{2,1}^{} &amp; Im &amp; &amp; &amp; \\&amp; A{3,2}^{} &amp; Im &amp; &amp; \\&amp; &amp; . &amp; . &amp; \\ &amp; &amp; &amp; A{\\frac{n}{m},\\frac{n}{m}-1}^{} &amp; I_m\\end{matrix}\\right]$$ $A{i,i-1}^{*} = A{i,i}^{-1}A{i,i-1}, 2 \\leq i \\leq n/m$; $A^{}$的计算需要对(n/m)-1个独立的mm矩阵求逆得到${A{i,i}^{-1}}{i=2}^{n/m}$，再通过(n/m)-1个独立的m*m矩阵相乘得到${A{i,i}^{-1}A{i,i-1}}{i=2}^{n/m}$ 运用对下三角矩阵求逆的并行算法，可以在$O(log^2m)$时间内用$O((n/m)M(m))$计算量求出$A{i,i}^{-1}, 1 \\leq i \\leq n/m$; (n/m)-1矩阵乘法与$d = D{-1}b$的计算显然在这个上界之内 将x和d分成m维子向量$x = (x_1, x2, …, x{n/m})$和$d = (d_1, d2, …, d{n/m})$, $Ax = d$的解可表示为$x_1 = d_1$$xi = -A{i,i-1}^{}x_{i-1} + d_i, 2 \\leq i \\leq n/m$ $x_i$的计算可以在O(log(n/m)logm)的时间复杂度内，用O((n/m)M(m))的计算量 $T(n) = O(lognlogm)$; W(n) = O((n/m)M(m)) 离散傅氏变换(Discrete fourier transform)定义在复数域上的离散傅氏变换DFT 定义复数$ \\omega = e^{i\\frac{2\\pi}{n}} = \\cos\\frac{2\\pi}{n} + i\\sin\\frac{2\\pi}{n} $，其中$i = \\sqrt{-1}$ $\\omega^{n} = e^{2\\pi i} = 1$; $1, \\omega, \\omega^2, …, \\omega^{n-1}$是复数域上(相异的)第n单位根(root of unity); $\\omega$被称为第n本原单位根(primitive root of unity) 使n*n矩阵$W_n(j,k) = \\omega^{jk}, 0 \\leq j,k \\leq n-1$, n维列向量$x$的DFT定义为列向量$y = W_nx$ $yj = \\sum{k=0}^{n-1}\\omega^{jk}x_k, 0 \\leq j \\leq n-1$ e.g. 快速傅氏变换用分治策略计算DFT $y = W_nx$(假设n是2的幂) 使j为偶数: $j = 2l, 0 \\leq l \\leq \\frac{n}{2} - 1$ $yj = y{2l} = \\sum_{k=0}^{n-1}\\omega^{2lk}xk$, 故有$ y{2l} = x_0 + \\omega^{2l}x_1 + \\omega^{4l}x2 + … + \\omega^{2l(\\frac{n}{2}-1)}x{\\frac{n}{2}-1} + x{\\frac{n}{2}} + \\omega^{2l}x{\\frac{n}{2}+1} + \\omega^{4l}x{\\frac{n}{2}+2} + … + \\omega^{2l(\\frac{n}{2}-1)}x{n-1} $ $ y_{2l} = (x0 + x{\\frac{n}{2}}) + \\omega^{2l}(x1 + x{\\frac{n}{2}+1}) + \\omega^{4l}(x2 + x{\\frac{n}{2}+2}) + … + \\omega^{2l(\\frac{n}{2}-1)}(x{\\frac{n}{2}-1} + x{n-1}) $ 显然$\\omega^2 = e^{i\\frac{2\\pi}{\\frac{n}{2}}}$, 故$\\omega^2$是第(n/2)本原单位根 $z^{(1)} = [y_0, y2, …, y{n-2}]^{T}$是向量$[x0 + x{\\frac{n}{2}}, x1 + x{\\frac{n}{2}+1}, …, x{\\frac{n}{2}-1} + x{n-1}]^{T}$的离散傅氏变换 如果j为奇数: $j = 2l + 1$, 类似地有$ y_{2l+1} = (x0 + \\omega^{\\frac{n}{2}})x{\\frac{n}{2}} + \\omega^{2l}(\\omega x1 + \\omega^{\\frac{n}{2}+1}x{\\frac{n}{2}+1}) + … + \\omega^{2l(\\frac{n}{2}-1)}(\\omega^{\\frac{n}{2}-1}x{\\frac{n}{2}-1} + \\omega^{n-1}x{n-1}) $ $\\omega^{\\frac{n}{2}} = e^{i\\pi} = -1$, 故$ y_{2l+1} = (x0 - x{\\frac{n}{2}}) + \\omega^{2l}\\omega (x1 - x{\\frac{n}{2}+1}) + \\omega^{4l}\\omega^2(x2 - x{\\frac{n}{2}+2}) + … + \\omega^{2l(\\frac{n}{2}-1)}\\omega^{\\frac{n}{2}-1}(x{\\frac{n}{2}-1} - x{n-1}) $ $z^{(2)} = [y_1, y3, …, y{n-1}]^{T}$是向量$[x0 - x{\\frac{n}{2}}, \\omega (x1 - x{\\frac{n}{2}+1}), …, \\omega^{\\frac{n}{2}-1}(x{\\frac{n}{2}-1} - x{n-1})]^{T}$的离散傅氏变换 algorithm 8.212345678910111213(Fast Fourier Transform)Input: An n-dimensional vector x whose entries are complex numbers, and \\omega = e^&#123;i\\frac&#123;2\\pi&#125;&#123;n&#125;&#125;, where n is assumed to be a power of 2.Output: The vector y that is the DFT of x.begin1. if n = 2 then &#123;Set y_1 := x_1 + x_2, y_2 := x_1 - x_2, exit&#125;2. for 0 &lt;= l &lt;= n/2-1 pardo Set u_l := x_l + x_&#123;n/2+l&#125; Set v_l := \\omega^l (x_l - x_&#123;n/2+l&#125;)3. Recurrsively, compute the DFT of the two vectors [u_0, u_1, ..., u_&#123;n/2-1&#125;] and [v_0, v_1, ..., v_&#123;n/2-1&#125;], and store the results in vetors z^(1) = [z_0^(1), z_1^(1), ..., z_&#123;n/2-1&#125;^(1)] and z^(2) = [z_0^(2), z_1^(2), ..., z_&#123;n/2-1&#125;^(2)], respectively.4. for 0 &lt;= j &lt;= n-1 pardo j even : Set y_j := z_&#123;j/2&#125;^(1) j odd : Set y_j := z_&#123;(j-1)/2&#125;^(2)end $ T(n) = T(n/2) + O(1) $ $ W(n) = 2W(n/2) + O(n) $ T(n) = O(logn); W(n) = O(nlogn) 离散傅里叶逆变换(inverse discrete Fourier transform, IDFT): 矩阵$W_n$的逆$W_n^{-1}(j,k) = \\frac{1}{n}\\omega^{-jk}, 0 \\leq j,k \\leq n-1$, 向量x的离散傅氏逆变换是向量$y = W_n^{-1}x$ 类似地，T = O(logn), W = O(n logn) 多项式乘法和卷积多项式$p(x) = \\sum_{k=0}^{n-1}a_kx^k$可由系数列表唯一表示$(a_0, a1, …, a{n-1})$; 给定点$x_i$, $y_i = p(x_j)$值唯一 多项式乘法 两个多项式$ p(x) = \\sum_{k=0}^{n-1}akx^k $,$ q(x) = \\sum{k=0}^{m-1}bkx^k $,其积为$ r(x) = p(x)q(x) = \\sum{k=0}^{n+m-2}c_kx^k $,使得$ ck = \\sum{j=0}^{k}ajb{k-j} $ (下标越界的a、b值为0) Polynomial multiplication using the FFT algorithm 设l为2的幂且使得$n+m-2 &lt; l \\leq 2(n+m-2)$; $a = [a0, …, a{l-1}]^{T}, a_j = 0$ for j &gt; n-1, $b = [b0, …, b{l-1}]^{T}, b_k = 0$ for k &gt; m-1 计算系数列表${c_k}$的算法如下( 多项式乘法的并行算法): 用F快速傅里叶变换算法计算 $y = W_la$ 和 $z = W_lb$ , 得到p(x)和q(x)在点x = 1, $\\omega, \\omega^2, …, \\omega^{l-1}$的值，其中$\\omega$是第l本原单位根，$y_j = p(\\omega^j), z_j = q(\\omega^j), 0 \\leq j \\leq l-1$ 计算 $u_j = y_jz_j$ , for $0 \\leq j \\leq l-1$。显然 $u_j = p(\\omega^j)q(\\omega^j) = r(\\omega^j)$, 故能得到多项式$r(x)$在l个相异单位根的值 计算向量$u = [u_0, u1, …, u{l-1}]^{T}$的傅里叶逆变换。向量前n+m-1个元和乘积$r(x)$的系数相同。 T(n) = O(log(n+m)); W(n) = O((n+m)log(n+m)) 用快速傅里叶变换算法计算卷积(Convolution)向量$a$和$b$的卷积，可以表示为$ a\\bigotimes b $ $a = [a0, …, a{n-1}]^{T}$; $b = [b0, …, b{m-1}]^{T}$ $a \\bigotimes b$定义为向量$c = [c0, …, c{m+n-1}]^{T}$, 使得$ck = \\sum{j=0}^kajb{k-j}$, 其中$a_j = 0, j &gt; n-1$, $b_j = 0, j &gt; m-1$ 除$c{n+m-1}$(总是为0)外，两个向量$a$和$b$的卷积和多项式$p(x) = \\sum{j=0}^{n-1}ajx^j$和$q(x) = \\sum{j=0}^{m-1}b_jx^j$的乘积的系数相同 计算n维向量x和m维向量y的卷积的并行算法的复杂度: T = O(log(n+m)); W((n+m)log(n+m)) Toeplitz矩阵(托普利茨矩阵)Toeplitz矩阵: n*n矩阵T满足$T(k,l) = T(k-1,l-1)$, for $2 \\leq l,k \\leq n$ 矩阵T同一对角线上的所有元素相等; 因此这类矩阵又出现在第一行和第一列的2n-1个元素唯一确定$$ T =\\left[\\begin{matrix}t{n-1} &amp; t{n-2} &amp; … &amp; &amp; t_2 &amp; t_1 &amp; t_0 \\tn &amp; t{n-1} &amp; t_{n-2} &amp; … &amp; &amp; t_2 &amp; t1 \\t{n+1} &amp; tn &amp; t{n-1} &amp; t_{n-2} &amp; … &amp; &amp; t2 \\. &amp; &amp; &amp; . &amp; . &amp; . &amp; . \\. &amp; &amp; &amp; &amp; . &amp; . &amp; . \\t{2n-3} &amp; t{2n-4} &amp; … &amp; &amp; &amp; t{n-1} &amp; t{n-2} \\t{2n-2} &amp; t{2n-3} &amp; … &amp; &amp; t{n+1} &amp; tn &amp; t{n-1}\\end{matrix}\\right]$$ $t = [t_0, t1, …, t{2n-2}]^{T}$确定了托普利茨矩阵T Toeplitz矩阵乘以向量 向量$a = [a_0, a1, …, a{n-1}]^{T}$, $d = Ta$, 其中T是n*n托普利茨矩阵 $t = [t_0, t1, …, t{2n-2}]^{T}$ 计算d的一般算法需要O(logn)的时间和O(n^2)的计算量 易证$dl = \\sum{j=0}^{n-1}ajt{n+l-j-1}, 0 \\leq l \\leq n-1$ 考察向量 $a$ 和 $t$ 的卷积c, $ck = \\sum{j=0}^kajt{k-j}$, 将k=n+l-1代入得$c{n+l-1} = \\sum{j=0}^{n+l-1}ajt{n+l-j-1} = \\sum_{j=0}^{n-1}ajt{n+l-j-1}$($j &gt; n-1 时 a_j = 0$) $dl = c{n+l-1}, 0 \\leq l \\leq n-1$ 乘积Ta可通过计算$a \\bigotimes t$, 令$dl = c{n+l-1}(0 \\leq l \\leq n-1)$得到 Toeplitz矩阵乘以向量的并行算法:$c = a \\bigotimes t$得到的c向量的元素$(c_{n-1}, cn, …, c{2n-2})$ T(n) = O(logn); W(n) = O(nlogn) 求下三角Toeplitz矩阵的逆矩阵-下三角托普利茨矩阵T分成n/2 * n/2的块:$$ T = \\left[ \\begin{matrix} T_1 &amp; 0 \\ T_2 &amp; T_1 \\end{matrix} \\right]$$ 不妨设n是2的幂 矩阵T的逆$T^{-1}$如下:$$ T^{-1} =\\left[\\begin{matrix}T_1^{-1} &amp; 0 \\-T_1^{-1}T_2T_1^{-1} &amp; T_1^{-1}\\end{matrix}\\right]$$ $T^{-1}$也是一个下三角托普利茨矩阵，由第一列元素唯一确定; 计算$T^{-1}$的算法: 递归地计算$T_1^{-1}$的第一列 计算$-T_1^{-1}T_2T_1^{-1}$的第一列 计算$-T_1^{-1}T_2T_1^{-1}$的第一列等价于计算$-T_1^{-1}T_2T_1^{-1}e$, 其中$e = [1, 0, …, 0]^{T}$ T(n) = T(n/2) + O(logn) W(n) = W(n/2) + O(nlogn) Toeplitz矩阵求逆算法的并行复杂度: $T(n) = O(log^2n)$; $W(n) = O(nlogn)$ 应用Toeplitz矩阵实现多项式的除法 两个多项式$ s(x) = \\sum_{j=0}^{n-1}sjx^j $和$ t(x) = \\sum{j=0}^{m-1}t_jx^j $,存在唯一的两个多项式, 商$q(x)$和余数$r(x)$使得$ s(x) = t(x)q(x) + r(x) $且$r(x)$的阶(degree)小于$t(x)$的阶(余数的最高次小于除数的最高次) 引理8.2: $t(x)$和$s(x)$是两个阶分别为n-1和m-1的多项式(n&gt;m)。 如果商$q(x)$已知，$r(x)$可以在O(logn)的时间内用O(nlogn)的计算量求出来。 如果余数$r(x)$已知，$q(x)$可以在O(log(n-m))的时间内用O((n-m)log(n-m))的计算量算出来。 $q(x)$的阶为n-m，两个矩阵$t(x)q(x)$相乘可以在O(logn)时间内用O(nlogn)计算量复杂度的基于FFT的算法。$r(x) = s(x) - t(x)q(x)$可以在O(1)时间内由O(n)计算量完成 $s(x) - r(x)$可在O(1)时间内由O(n)操作完成。通过多项式求值/差值和DFT的关系求$q(x) = \\frac{s(x)-r(x)}{t(x)}$: 计算$s(\\omega^l) - r(\\omega^l)$和$t(\\omega^l), 0 \\leq l \\leq n-m+1$, 其中$\\omega$是第(n+m-1)本原单位根。FFT算法可以在O(log(n-m))的时间内用O((n-m)log(n-m))计算量计算出来。因此$q(\\omega^l)$能在这个上界内求得，再使用快速傅里叶逆变换算法能求得$q(x)$ 计算多项式的商: 设$q(x) = \\sum_{j=0}^{n-m}qjx^j$是两个多项式$s(x) = \\sum{j=0}^{n-1}sjx^j$和$t(x) = \\sum{j=0}^{m-1}t_jx^j$的商。 不失一般性假设$t{m-1}s{n-1} \\not= 0$, $t(x)q(x)$可表示为$\\sum_{k=0}^{n-1}a_kx^k$, 其中$ak = \\sum{j=0}^ktjq{k-j}$ 设r(x)为$s(x)$除以$t(x)$的余数，给定$r(x)$的阶小于m-1; 则$\\sum_{k=m-1}^{n-1}skx^k = \\sum{k=m-1}^{n-1}a_kx^k$, 故$s_k = a_k, m-1 \\leq k \\leq n-1$ , 从而$sk = \\sum{j=0}^ktjq{k-j}, m-1 \\leq k \\leq n-1$ 由$t_j = 0, j \\geq m$和$q_j = 0, j \\geq n-m+1$可得: 关于$s(x)$和$t(x)$的系数的矩阵T是一个(n-m+1)*(n-m+1)下三角托普利茨矩阵 两个多项式(n阶和m阶, n &gt; m)相除的并行算法的复杂度$T(n) = O(log^2(n-m) + logn)$;$W(n) = O(nlogn)$ 多项式求值和插值多项式求值(polynomial evaluation): n-1阶多项式$p(x) = \\sum_{j=0}^{n-1}a_jx^j$ ${a_l | 0 \\leq l \\leq n-1}$是一组相异点的集合 计算$p(\\alpha_l), 0 \\leq l \\leq n-1$ Horner’s algorithm并发地求，$T = O(logn), W = O(n^2)$ 多项式求值的分治算法 令$q_l = x - \\alpha_l, 0 \\leq l \\leq n-1$ $Q1(x) = \\prod{i=0}^{\\frac{n}{2}-1}q_l(x)$$Q2(x) = \\prod{l=\\frac{n}{2}}^{n-1}q_l(x)$ 设定n为2的幂，$Q_1(x)$和$Q_2(x)$是阶为$\\frac{n}{2}$的多项式 $p_1(x) = p(x) mod Q_1(x)$; $p_2(x) = p(x) mod Q_2(x)$ 对某个多项式$t_1(x)$和$t_2(x)$有$p(x) = t_1(x)Q_1(x) + p_1(x)$和$p(x) = t_2(x)Q_2(x) + p_2(x)$ ($deg(p_1(x)), deg(p_2(x)) &lt; \\frac{n}{2}$) $p(\\alpha_l) = p_1(\\alpha_l), 0 \\leq l \\leq \\frac{n}{2}-1$; $p(\\alpha_l) = p_2(\\alpha_l), \\frac{n}{2} \\leq l \\leq n-1$ algorithm 8.31234567891011121314151617(Polynomial Evaluation)Input: (1)A polynomial p(x) of degree n-1 specified by its coefficients, and (2)a set of n distinct points a_j, where 0 &lt;= j &lt;= n-1 and n = 2^k for some integer k.Output: The values p(a_j), where 0 &lt;= j &lt;= n-1begin1. for 0 &lt;= j &lt;= n-1 pardo Set Q_&#123;0, j&#125;(x) := x - a_j2. for h = 1 to log n-1 do for 0 &lt;= j &lt;= (n/2^h) - 1 pardo Set Q_&#123;h,j&#125;(x) := Q_&#123;h-1,2j&#125;(x) * Q_&#123;h-1,2j+1&#125;(x)3. Set p_&#123;k,0&#125;(x) := p(x)4. for h = log n-1 to 0 do for 0 &lt;= j &lt;= (n/2^h)-1 pardo j even : Set p_&#123;h,j&#125;(x) := p_&#123;h+1,j/2&#125;(x) mod Q_&#123;h,j&#125;(x) j odd : Set p_&#123;h,j&#125;(x) := p_&#123;h+1,(j-1)/2&#125;(x) mod Q_&#123;h,j&#125;(x)5. for 0 &lt;= j &lt;= n-1 pardo Set p(a_j) := p_&#123;0,j&#125;end $ T(n) = O(log^3n) $; $ W(n) = O(nlog^2n) $ 多项式插值的分治算法 集合$ { \\betaj = p(\\alpha) }{j=0}^{n-1} $ 拉格朗日插值公式(Lagrange interpolation formula):$ p(x) = \\sum_{j=0}^{n-1}\\betaj \\frac{\\prod{l=0,l \\not= j}^{n-1}(x - \\alphaj)}{\\prod{l=0,l \\not= j}^{n-1}(\\alpha_j-\\alpha_l)} $ $q_l(x) = x - \\alphal$; $Q(x) = \\prod{i=0}^{n-1}q_l(x)$; $Q^{‘}(\\alphaj) = \\prod{l=0,l \\not= j}^{n-1}(\\alpha_j) - \\alpha_l$ $\\gamma_j = Q^{‘}(\\alpha_j), 0 \\leq j \\leq n-1$, $c_j = \\beta_j/\\gammaj, 0 \\leq j \\leq n-1$; $p(x) = Q(x)\\sum{j=0}^{n-1}\\frac{c_j}{x - \\alpha_j}$ $\\sum_{j=0}^{n-1}\\frac{c_j}{x-\\alphaj}$可用平衡树方法求得$ \\frac{p(x)}{Q(x)} = \\frac{p{k-1,0}(x)}{Q{k-1,0}(x)} + \\frac{p{k-1,1}(x)}{Q{k-1,1}(x)} = \\frac{p{k-1,0}(x)Q{k-1,1}(x) + p{k-1,1}(x)Q_{k-1,0}(x)}{Q(x)} $ Algorithm 8.412345678910111213141516(Polynomial Interpolation)Input: A set of pairs of numbers (a_j, b_j), where 0 &lt;= j &lt;= n, the a_j&apos;s are distinct, and n = 2^k for some integer k.Output: The coefficients of the (n-1)st-degree polynomial p(x) such that p(a_j) = b_j, for all 0 &lt;= j &lt;= n-1.begin1. for 0 &lt;= j &lt;= n-1 pardo Set Q_&#123;0,j&#125;(x) := x - a_j2. for h = 1 to logn do for 0 &lt;= j &lt;= (n/2^h)-1 pardo Set Q_&#123;h,j&#125;(x) := Q_&#123;h-1,2j&#125;(x) * Q_&#123;h-1,2j+1&#125;(x)3. Compute Q_&#123;k,0&#125;(x), and user Algorithm 8.3 to compute y_j = Q&apos;_&#123;k,0&#125;(a_j), for all 0 &lt;= j &lt;= n-14. for 0 &lt;= j &lt;= n-1 pardo Set p_&#123;0,j&#125;(x) := b_j/y_j5. for h = 1 to logn do for 0 &lt;= j &lt;= (n/2^h)-1 pardo Set p_&#123;h,j&#125;(x) := p_&#123;h-1,2j&#125;(x)Q_&#123;h-1,2j+1&#125;(x) + p_&#123;h-1,2j+1&#125;(x)Q_&#123;h-1,2j&#125;(x)6. Set p(x) := p_&#123;k,0&#125;(x) $ T(n) = O(log^3n) $; $ W(n) = O(nlog^2n) $","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"字符串匹配的并行算法","slug":"parellel_and_distributed_computing/paralell_compute7","date":"2017-04-10T16:00:00.000Z","updated":"2017-04-16T07:49:39.578Z","comments":true,"path":"2017/04/11/parellel_and_distributed_computing/paralell_compute7/","link":"","permalink":"https://chenfeng.github.io/2017/04/11/parellel_and_distributed_computing/paralell_compute7/","excerpt":"(并行与分布式计算六) 字符串的预备知识字符串: 有限长度的字符序列 字符表(或字母表 alphabet) 字符串Y的长度: |Y| 两条字符串X和Y的连接为 XY 字符串Y中第i个字符: Y(i)(1 &lt;= i &lt;= |Y|) 字符串Y的子字符串: Y(i:j)(1 &lt;= i &lt;= j &lt;= |Y|) 字符串Y的前缀(prefix): Y(1:i)(1 &lt;= i &lt;= m) 字符串Y的后缀(suffix): Y(j:m)(1 &lt;= j &lt;= m)","text":"(并行与分布式计算六) 字符串的预备知识字符串: 有限长度的字符序列 字符表(或字母表 alphabet) 字符串Y的长度: |Y| 两条字符串X和Y的连接为 XY 字符串Y中第i个字符: Y(i)(1 &lt;= i &lt;= |Y|) 字符串Y的子字符串: Y(i:j)(1 &lt;= i &lt;= j &lt;= |Y|) 字符串Y的前缀(prefix): Y(1:i)(1 &lt;= i &lt;= m) 字符串Y的后缀(suffix): Y(j:m)(1 &lt;= j &lt;= m) 字符串匹配问题及其串行算法 字符串X在字符串Y中出现，是指存在位置i，使得X(j)=Y(i+j-1)对所有1 &lt;= j &lt;= |X|成立 字符串X在位置i与Y匹配(match) KMP算法：O(|X|+|Y|)复杂度 字符串的周期性(periodicities in string) 如果$Y = X^kX’$，其中$X’$是$X$的一个前缀，则$|X|$是$Y$的一个周期 如果p是Y的最短周期，则简称p是Y的周期(没有加“一个”在前面): The period(周期)，a period(一个周期) 如果Y的周期不大于|Y|/2，就称Y是周期的(periodic) e.g: abcaabcab不是周期的(最短周期是abcaabc)，abcabcab是周期的(周期p = 3) 字符串的周期引理: 如果p和q都是Y的一个周期且p+q &lt;= |Y|, 则p和q的最大公约数也是Y的一个周期 证明: 由p和q都是Y的一个周期，可得|p-q|也是Y的一个周期: Y(i) = Y(i-p) = Y(i-q) ==&gt; Y(j) = Y(j+p-q) 由最大公约数的欧几里德算法gcd(p, q) = gcd(p-q, q)可以得到结论 推论1：如果X的周期为p且X在Y的i和j位置出现，则|i-j| &gt;= p推论2：如果X的周期为p且在Y的i和i+d(d &lt;= m-p)位置出现, 则d是p的倍数; 如果0 &lt;= d &lt;= |X|/2, 则X也在i+kp出现(其中k是满足kp &lt;= d的整数) (区别)见证数组(Witness Array) 长度为m，周期为p的字符串Y，定义Pi(Y) = min{p, $\\lceil \\frac{m}{2} \\rceil$} 见证函数Wit(i)定义： Wit(1) = 0 Wit(i) = k($2 \\leq i \\leq Pi(Y)$), k是满足$Y(k) \\not= Y(i + k - 1)$的一个下标 见证函数数组WITNESS(1:r)(r = Pi(Y)) e.g: abcaabcab，见证数组WITNESS = (0,3,2,2,5) e.g: abcabcab，见证数组WITNESS = (0,3,2) (区别)见证数组的基本思想: 如果匹配两个位置的子字符串时，可以由某个特定的位置排除这两个位置的其中一个的匹配性，就可以减少字符串匹配的复杂度 这个特定的位置，称为（区别）见证位置(如果在见证位置不同，则不可能匹配) 见证位置与对决 Z字符串为文本字符串，Y为模式；利用见证位置排除掉Z中两处潜在的匹配中的一处的过程称为对决： 对决算法 Algorithm 7.1123456789101112(Duel(i, j))Input:(1)A string Z of length n;(2)a WITNESS array of another string Y of length m &lt;= n;(3)two indices i and j, where 1 &lt;= i &lt; j &lt;= n - m, such that j - i &lt; Pi(Y) = min&#123;p, $\\lceil \\frac&#123;m&#125;&#123;2&#125; \\rceil$&#125; and p is the period of Y.Output: One of i or j(that may match); string Y cannot occur in Z at the eliminated position.begin1. Set k := WITNESS(j - i + 1)2. if Z(j + k - 1) != Y(k) then return(i) else return(j)end T = O(1), W = O(1) e.g. (example 7.5) 字符串Y = abcabcab, 见证数组WITNESS = (0, 3, 2) 字符串Z = abcaabcabaa 考虑Z的位置i = 5和j = 7 WITNESS(7 - 5 + 1) = 2, Y(2) = b != Z(8) = a, 对决算法输出下标i = 5(可能匹配的位置) 字符串匹配(string matching)的两种分析string-matching problem: 在Y中找X的所有出现的位置 称Y为待匹配的文本(text)，X为待匹配的模式(pattern) 解决字符串匹配问题的经典范式包含两个步骤: 模式分析 Pattern Analysis 只对模式进行处理 将模式的部分信息压缩并保存在一个表中 文本分析 Text Analysis 用模式以及模式分析中产生的信息对文本进行处理 文本分析 文本T(1:n)，模式P(1:m)，模式的见证数组WITNESS(1:r)(r = Pi(P) = min{p, $\\lceil \\frac{m}{2} \\rceil$})，P周期为p 文本分析算法：非周期模式Algorithm 7.2123456789(Text Analysis, Nonperiodic Pattern)Input: Three arrays T(1:n), P(1:m), and WITNESS(1:m/2) corressponding to a text, a pattern and a witness function of the pattern, respectively. It is assumed that P is nonperiodic, and m is even.Output: The array MATCH, indicating all the positions where the pattern occurs in the text.begin1. Partition T into $\\lceil 2n/m \\rceil$(up integer) blocks T_i, each block containing no more than m/2 consecutive characters.2. For each block T_i, eliminate all but one position as a possible candidate for matching by using a balanced binary tree, where each internal node u contains the index returned by the function duel(i, j), and i and j are the indices stored in the children of u.3. For each candidate position, verify where P occurs at that position in T by using the brute-force algorithm.end T = O(log m) W = O(n) e.g: T = babaababaaba, P = abaab 见证数组WITNESS = (0,1,2) 分块: $T_1 = bab,T_2 = aab,T_3 = aba,T_4 = aba$, 对每个块并发处理 第一轮对决(WINESS(2) = 1): Duel(1,2)=2, Duel(4,5)=5, Duel(7,8)=7, Duel(10,11)=10 第二轮对决: Duel(2,3)=2, Duel(5,6)=5,Duel(7,9)=7, Duel(10,12)=10 对T的位置2, 5, 7, 10用暴力算法尝试匹配: 2和7能匹配 文本分析算法：周期模式 基本思想： 用周期模式的最大非周期前缀来作为初始模式 查找文本中初始模式的位置 要找出文本中周期模式的位置，可以用初始模式的位置来筛选 只有周期重复次数足够的位置才能在筛选中存活下来 周期重复次数可以用分段后缀和算法来并行计算 P(1:m) = $u^kv$, v是u的一个前缀(可空), |u| = p是P的周期, 见证数组WITNESS长度为p 将P(1:2p-1)作为一个新的模式(P的最大非周期前缀)在T中在O(logp)时间内用O(n)操作找出所有匹配 检查$u^2v$是否出现在(T的)位置i, i+p, …, i+(k-2)p(k是P(1:m)=$u^kv$中的k) Algorithm 7.312345678910(Text Analysis, Periodic Case)Input: Three arrays T(1:n), P(1:m), and WITNESS(1:p) representing respectively a text, a pattern, and a WITNESS array corresponding to P(1:2p-1). We also know that the pattern is periodic and has period p.Output: The array MATCH identifying all the positions in the text where the pattern occurs.begin1. Use Algorithm 7.2 to determine the occurrences of the prefix P(1:2p-1) in T.2. For each occurence of P(1:2p-1) in T(at position i), find whether u^2v occurs at i, where u = P(1:p), v = P(kp+1:m, and k = $\\lfloor m/p \\rfloor$(lower integer)). If it does, set M(i) := 1. For all the other positions i such that 1 &lt;= i &lt;= n, set M(i) := 0. 3. For each i such that 1 &lt;= i &lt;= p, let S_i be the subarray of M consisting of the bits (M(i), M(i+p), M(i+2p), ...). For each position l of S_i that contains a 1, set C(i, l) := 1 if there are at least k-1 consecutive 1's starting at this position. For all the remaining positions l of S_i, set C(i, l) := 0.4. For each 1 &lt;= j &lt;= n - m + 1, let j = i + lp, where 1 &lt;= i &lt;= p and l &gt;= 0. Then, set MATCH(j) := C(i, l+1).end T = O(logm), W = O(n) e.g. (example 7.8) T = babababababaabab = (ba)^6(ab)^2, P = abababa = (ab)^3a p = 2, P(1:2p-1) = P(1:3) = aba T中出现P(1:3)的位置2, 4, 6, 8, 10, 13 (ab)^2a在T中出现位置2, 4, 6, 8; M = (0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0) S_1 = (0, 0, 0, 0, 0, 0, 0, 0), S_2 = (1, 1, 1, 1, 0, 0, 0, 0) C(1, l) = 0(1 &lt;= l &lt;= 8) C(2, 1) = C(2, 2) = C(2, 3) = 1, C(2, l) = 0(4 &lt;= l &lt;= 8) MATCH(2) := C(2, 1) = 1, MATCH(4) := C(2, 2) = 1, MATCH(6) := C(2, 3) = 1, MATCH(i) := 0 otherwise. P 出现在T的2, 4, 6位置 模式分析算法 目标：计算见证数组WITNESS WITNESS(i)(1 &lt;= i &lt;= r, r = min{p, $\\lceilm/2\\rceil$}) = k != 0, k满足P(i + k - 1) P(1:i-1)不是模式的周期 基本思想: 迭代算法，每一迭代令模式的短子模式长度翻倍 从模式的短子模式开始，通过短子模式来计算长子模式见证数组的部分元素 剩余的元素在后面的迭代中计算 简单算法 lemma 7.7:Suppose that we are given WITNESS(2:t) of the string P(1:m), for some t &lt; min(p, m/2), where p is the period of P. Then, given any pair of distinct indices i and j, such that t &lt; i, j &lt;= $\\lceil\\frac{m}{2}\\rceil$ and |j - i| &lt; t, we can compute at least one of WITNESS(i) or WITNESS(j) in O(1) sequential time. Algorithm 7.512345678910111213(Simple Pattern Analysis)Input: A pattern P(1:m), where m = 2^s.Output: The array WITNESS(1:r), where r = min(p, 2^(s-1)), and p is the period of P.begin1. for 1 &lt;= i &lt;= m/2 pardo Set WITNESS(i) := 02. for i = 1 to s - 1 do 2.1 Let j != 1 be the candidate in the first i-block. Compute WITNESS(j) using the brute force algorithm. 2.2 if WITNESS(j) = 0 then exit 2.3 for all i_blocks B(except the first) pardo Apply duel(k, s), where k and s are the candidates in B.end T = O(log m) W = O(m log m) …","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"搜索、归并与排序的并行算法","slug":"parellel_and_distributed_computing/paralell_compute5","date":"2017-03-27T16:00:00.000Z","updated":"2017-04-22T13:11:26.047Z","comments":true,"path":"2017/03/28/parellel_and_distributed_computing/paralell_compute5/","link":"","permalink":"https://chenfeng.github.io/2017/03/28/parellel_and_distributed_computing/paralell_compute5/","excerpt":"(并行与分布式计算三) 并行搜索的基本思想在升序数组中采用与二分搜索类似的p+1分搜索: 使用递归按比例缩小搜索范围的办法 二分搜索每层递归中加入一次比较，p+1分搜索每层递归中加入p次比较 上述的每层p次比较可以用p个处理器同时进行 长度为n的升序数组，用p个处理器做p+1分搜索，并行时间为$O(log_{p+1}(n+1))$","text":"(并行与分布式计算三) 并行搜索的基本思想在升序数组中采用与二分搜索类似的p+1分搜索: 使用递归按比例缩小搜索范围的办法 二分搜索每层递归中加入一次比较，p+1分搜索每层递归中加入p次比较 上述的每层p次比较可以用p个处理器同时进行 长度为n的升序数组，用p个处理器做p+1分搜索，并行时间为$O(log_{p+1}(n+1))$ 例：p+1分并行搜索:X=(2,4,6,…,30)，X[1]=2, X[15]=30; Y=9 作p+1分并行搜索，p=2: 迭代1：q0=0, q1=5, q2=10, q3=16 迭代2：q0=5, q1=6, q2=7, q3=10 迭代3：q0=7, q1=8, q2=9, q3=10 快速并行搜索算法Algorithm 4.112345678910111213141516171819202122232425(Parallel Search for Processor P_j)Input: (1)An array X = (x_1, x_2, ..., x_n) such that x_1 &lt; x_2 &lt; ... &lt; x_n; (2)an element y; (3)the number p of processors, where p &lt;= n; (4)the processor number j, where 1 &lt;= j &lt;= p.Output: An index i such that x_i &lt;= y &lt; x_i+1.begin1. if (j = 1) then do 1.1 Set l := 0; r := n + 1; x_0 := -∞; x_n+1 := +∞ 1.2 Set c_0 := 0; c_p+1 := 12. while (r - 1 &gt; p) do 2.1 if (j = 1) then &#123;set q_0 := l; q_p+1 := r&#125; 2.2 Set q_j := l + j*floor((r-1)/(p+1)) 2.3 if (y = x_q_j) then &#123;return (q_j); exit&#125; else &#123;set c_j := 0 if y &gt; x_q_j and c_j := 1 if y &lt; x_q_j&#125; 2.4 if (c_j &lt; c_j+1) then &#123;set l := q_j; r := q_j+1&#125; 2.5 if (j = 1 and c_0 &lt; c_1) then &#123;set l := q_0; r := q_1&#125;3. if (j &lt;= r - l) then do 3.1 Case statement: y = x_l+j : &#123;return (l + j); exit&#125; y &gt; x_l+j : set c_j := 0 y &lt; x_l+j : set c_j := 1 3.2 if (c_j-1 &lt; c_j) then return (l + j - 1)end 初始化 外层搜索递归调用内层搜索 最内层搜索 $T = O(log_{p+1}(n+1)) = O(\\frac{log(n+1)}{log(p+1)}) = O(1)$ 并行归并的基本思想 并行地归并两个升序数组，可以等价为计算：1.归并序=自序+交叉序2.自序=数组元素在自己所在数组中的序3.交叉序=数组元素在另一个数组中的序 自序是已知的，交叉序可以用快速并行搜索算法来计算 交叉序的并行搜索的两层并行性: 单个元素的快速搜索内部并行 不同元素的搜索之间并行 例：并行归并中的交叉序计算 A=(-5,0,3,4,17,18,24,28)B=(1,2,15,21)分两个迭代并行搜索 迭代1：定位b2和b4。b_2=2在a_2=0和a_3=3之间，b_4=21在a_6=18和a_7=24之间(rank(b_2:A)=2, rank(b_4:A)=6)迭代2：在b_2前的A元素中搜索b_1的位置，在b_2后、b_4前的A元素中搜索b_3的位置(rank(b_1:A)=2, rank(b_3:A)=4) 并行归并的加速技巧思路：双层对数树，利用处理器的冗余性加速 设要计算长度为m的数组B的元素在长度为n的数组A中的交叉序，则由加速层叠法： 最上层分叉成长度为$\\sqrt{m}$的段计算，每往下一层长度再开根号 最上层每段使用\\sqrt{n}个处理器来并行搜索(共\\sqrt{mn}个处理器)，从而分划数组A供下层递归使用 全局来说，每一层都使用不超过(m+n)/2个处理器，并且每层搜索时间T=O(1) 迭代1分割的A段长短不一不会影响加速算法中的处理器上界 最上层$\\sqrt(m)$段，对段的右端点在长度为n的A中搜索，求交叉序(能用$\\sqrt(n)$个处理器) $T = O(log{\\sqrt(n)+1}(n+1)) = O(log{\\sqrt(n)}n) = O(2) = O(1)$ 处理器个数$\\sqrt m\\sqrt n \\leqslant \\frac{m+n}{2}$ 第二层设B中第i段的右端点切到的A的段的长度为n，B分成$m^{\\frac{1}{4}}n^{\\frac{1}{4}}$段。第i段用$\\sqrt{n_{|\\frac{i-1}{\\sqrt{m}}|+1}}$个处理器 总处理器数 = $\\sum{i=1}^{m^{\\frac{3}{4}}}\\sqrt{n{|\\frac{i-1}{\\sqrt{m}}|+1}} = \\sum_{j=1}^{\\sqrt{m}}m^{\\frac{1}{4}}\\sqrt{nj} \\leqslant \\sum{j=1}^{\\sqrt{m}}\\frac{\\sqrt{m}+nj}{2} = (\\sum{j=1}^{\\sqrt{m}}\\sqrt{m} + \\sum_{j=1}^{\\sqrt{m}}n_j)/2 = (m+n)/2$ 第三层处理器个数 = $\\sum_{j=1}^{m^{\\frac{3}{4}}}m^{\\frac{1}{8}}\\sqrt{n_j^{(1)}} \\leqslant = (\\sum m^{\\frac{1}{4}} + n_j^{(1)})/2 = (m+n)/2$ 其中$n^(1)$是第二层分出的A的$m^{\\frac{3}{4}}$段的长度 并行求交叉序Algorithm 4.2123456789(Ranking a Sorted Sequence in Another Sorted Sequence)Input: Two arrays A = (a_1, ..., a_n) and B = (b_1, ..., b_m) in increasing order. Assume that sqrt(m) is an integer; otherwise, replace sqrt(m) whenever it occur by floor(sqrt(m)).Output: The array rank(B : A)begin1. If m &lt; 4, then rank the elements of B by applying the parallel-search algorithm(Algorithm 4.1) with p = n, and exit.2. Concurrently rank the elements b_sqrt(m), b_2sqrt(m), ..., b_i*sqrt(m), ..., b_m in A by using the parallel-search algorithm(Algorithm 4.1) with p = sqrt(n). Let rank(b_i*sqrt(m) : A) = j(i), for 1 &lt;= i &lt;= sqrt(m). set j(0) = 0.3. For 0 &lt;= i &lt;= sqrt(m)-1, let B_i = (b_i*sqrt(m)+1, ..., b_(i+1)*sqrt(m)-1) and let A_i = (a_j(i)+1, ..., a_j(i+1)); if j(i) = j(i+1), then set rank(B_i : A_i) = (0, ..., 0), else recursively compute rank(B_i: A_i).4. Let 1 &lt;= k &lt;= m be an arbitrary index that is not a multiple of sqrt(m), and let i = floor(k/sqrt(m)). Then rank(b_k : A) = j(i) + rank(b_k : A_i)end |A| = n, |B| = m, T = O(log logm), W = O((n + m)log logm) 最优的并行求交叉序前一个算法的问题： 运算量O((m+n)log log m)不是最优 最优运算量应该是O(m+n) 解决办法： 在两边数组均匀步长地抽取元素，缩短求交叉序的并行算法的输入数组 用前述并行算法求交叉序 利用抽取的点把两边的数组分段，这边的段一一对应地归并 两个长度都为n的升序数组，可以在O(log log n)的并行时间内用O(n)的运算量归并 在A和B中都先均匀采样，对两边采样点计算缩短的数组的交叉序，然后再利用该交叉序来进一步计算原来的数组的交叉序 T = O(log logn), W = O(n) 一个快速并行归并排序算法 从长度为较小常数的数组开始，逐层两两归并，共log n层 每层用O(log log n)的并行时间和O(n)的运算量来归并 总共O(log n log log n)的并行时间和O(n log n)的运算量 Algorithm 4.312345678910(Simple Merge Sort)Input: An array X of order n, where n = 2^l for sime integer l.Output: A balanced binary tree with n leaves such that, for each 0 &lt;= h &lt;= logn, L(h, j) contains the sorted subsequence consisting of the elements stored in the subtree rooted at node(h, j), for 1 &lt;= j &lt;= n/2^h. That is node(h, j) contains the sorted list of the elements X(2^h*(j-1) + 1), X(2^h*(j-1) + 2), ..., X(2^h*j)begin1. for 1 &lt;= j &lt;= n pardo Set L(0, j) := X(j)2. for h = 1 to logn do for 1 &lt;= j &lt;= n/2^h pardo Merge L(h-1, 2j-1) and L(h-1, 2j) into the sorted list L(h, j)end","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"图的并行算法","slug":"parellel_and_distributed_computing/paralell_compute4","date":"2017-03-20T16:00:00.000Z","updated":"2017-04-22T13:10:32.396Z","comments":true,"path":"2017/03/21/parellel_and_distributed_computing/paralell_compute4/","link":"","permalink":"https://chenfeng.github.io/2017/03/21/parellel_and_distributed_computing/paralell_compute4/","excerpt":"(并行与分布式计算四) 连通分量 顶点之间的连通性：在无向图G中，若从顶点$v_i$到顶点$v_j$有路径(当然从$v_j$到$v_i$也一定有路径)，则称$v_i$和$v_j$是连通的(Connected) 连通图：若V(G)中任意两个不同的顶点$v_i$和$v_j$都连通(即有路径)，则称G为连通图(Connected Graph) 连通分量：无向图G的极大连通子图称为G的连通分量(Connected Component) 寻找连通分量的串行算法","text":"(并行与分布式计算四) 连通分量 顶点之间的连通性：在无向图G中，若从顶点$v_i$到顶点$v_j$有路径(当然从$v_j$到$v_i$也一定有路径)，则称$v_i$和$v_j$是连通的(Connected) 连通图：若V(G)中任意两个不同的顶点$v_i$和$v_j$都连通(即有路径)，则称G为连通图(Connected Graph) 连通分量：无向图G的极大连通子图称为G的连通分量(Connected Component) 寻找连通分量的串行算法 深度优先搜索 1.令k=1 2.当图中有顶点未被标记时： 任取一个未被标记的顶点v 深度优先标记（v, k）：把v标记为第k个连通分量中的顶点 遍历v的未被标记的相邻顶点u： 递归地深度优先标记（u,k） 3.令k=k+1 广度优先搜索 1.令k=1 2.当图中有顶点未被标记时： 任取一个未被标记的顶点v 把v标记为第k个连通分量中的顶点 用v的相邻顶点组成集合U 当U非空时：把U中的顶点v都标记为第k个连通分量中的顶点;更新U，用旧的U中的顶点的未被标记的相邻顶点组成新的U 3.令k=k+1 算法可并行化程度分析深度优先搜索算法： 外循环用到连通分量编号k，不可并行 内循环用到前一个访问的顶点的标记，不可并行 广度优先搜索算法： 外循环用到连通分量编号k，不可并行 内循环只用到上一次内循环的标记，可以并行 广度优先搜索的并行性更好 改进寻找连通分量的算法的并行性 广度优先搜索算法 外循环的不可并行性问题是否可以解决 问题在于连通分量的编号方式: 连通分量的连续整数编号 需要依次搜索各个连通分量来保证：连通分量内编号相同，连通分量外编号不同 采用其它方式来为连通分量编号: 同一连通分量内的深度和广度优先探索都形成搜索树 用树根顶点作为连通分量的编号 不需要依次搜索各个连通分量 全并行连通分量搜索算法基本思想: 相邻的顶点可以合并为超顶点 相邻的超顶点可以继续合并为更大的超顶点 继续合并，直到把同一连通分量中的顶点都合并为一个超顶点 最终的结果是一个连通分量一个超顶点，用超顶点内编号最小的顶点来标记这个超顶点即可 顶点合并技巧: 合并方向函数 编号是极小值点的顶点或超顶点合并其它顶点或超顶点 定义合并方向函数$C(u) = min{v: v是u的邻居}$ 上述合并方向函数C(u)形成伪森林，同一伪树包含在同一个连通分量里，但是同一连通分量里可能有多个伪树 伪树:A pseudoforest is a directed graph in which each vertex has an outdegree less than or equal to 1. 顶点合并技巧：伪树的星化 每棵伪树内都只有一个环 根是环内编号更小的节点 如果用指针跳转法来跳转，当跳转步数大于或等于伪树的高度时，伪树上的所有节点都跳到环内的两个顶点之一 如果在使用指针跳转法之前先把伪树的环修改为从根指向根(loop)的回路，则当跳转步数大于或等于伪树的高度时，伪树上的所有节点都跳到伪树的根上 星化伪树： A rooted star is a directed tree that each vertex is directly connected to the root r. 顶点合并技巧：星化伪树的超顶点合并 星化的伪树合并为以根为标记的超顶点 当且仅当两个超顶点中的顶点有跨越超顶点的边连接时，这两个超顶点是相邻的 超顶点使用前面同样的合并方向函数来构造更高级别的伪树 更高级别的伪树又可以用同样的指针跳转法来星化，从而合并成更高级别的超顶点 继续合并，直到每个连通分量只剩一个超顶点 无向图G=(V, E)，定义函数C: C(v)=min{u | A(u, v) = 1}(A为图G邻接矩阵)，C(v)=v当且仅当v是孤立点;C定义了一棵伪树;树根定义为伪树中编号最小顶点 用指针跳转法(pointer jumping)将每个伪树收缩为超顶点(supervertex)，每个超顶点都孤立时算法停止 如果超顶点$r_i$和$r_j$邻接(存在连接两个顶点集的两个顶点的边)，则插入边($r_i$, $r_j$); 继续进行收缩 Algorithm 5.1 12345678910111213(Connected Components for Dense Graphs)Input: The n*n adjacency Matrix A of an undirected graph.Output: An array D of size n such that D(i) is equal to the smallest vertex in the connected component of i.begin1. Set A_0 := A, n_0 := n, k := 0.2. while n_k &gt; 0 do 2.1 Set k := k + 1 2.2 Set C(v) := Min&#123;u | A_k-1(u, b) = 1, u != v&#125; if none then v, 2.3 Shrink each tree of the pseudoforest defined by C to a rooted star. The root of each star containing more than one vertex defines a new supervertex. 2.4 Set n_k to be the number of the new supervertices, and set A_k to be the n_k * n_k adjancy matrix of the new supervertex graph.3. For each vertex v, determine D(v) as follows. If, at the end of step2, C(v) = v, then set D(v) = v; otherwise, reverse the process preformed at step 2 by expanding each supervertex r (of the supervertices formed during an iteration) into the set V_r of vertices of its directed tree, and making the assignment D(v) = D(r) for each v belongto V_r.end A是邻接矩阵，D是每个顶点所在的连通分量中标号最小的顶点 $T = O(log^2n)$, $W = O(n^2)$ W的主要部分是计算超顶点之间的边 该算法并行复杂度的最优性分析 串行算法的复杂度是O(m+n)，其中m是边数， n是顶点数 如果$m=O(n^2)$，那么前述并行算法就是最优的 当图是稠密的时候，$m=O(n^2)$ 然而，也有很多图是稀疏的 针对稀疏图改进连通分量并行算法改进$T(O(log^2n) -&gt; O(logn))$: 不用等一个级别内的所有伪树都星化了再做下一级别 嫁接法(Grafting): 伪森林中两棵相异的树$T_i$和$T_j$由D定义，$T_i$的根$r_i$，v是$T_j$一个顶点，将$T_i$嫁接到$T_j$是指D(r_i) = v的操作 非对称嫁接：当发现伪树的根大于伪树上某个节点的邻居的(不在原伪树上的)父结点时，把该根连接到该父结点上 if D(u) = D(D(u)) and D(v) = D(D(v)), which will result in an attempt to graft $T_i$ onto $T_j$ and $T_j$ onto $T_i$ simultaneously. To avoid such a difficulty we insist on grafting a tree onto a smaller vertex of another tree:Given an edge (u, v) belongs to E, we check whether D(u) = D(D(u)) and D(v) = D(D(u)) and D(v) &lt; D(u), and, if they are, we graft $T_i$ onto $T_j$, that is we set D(D(u) = D(v)) 星嫁接：(在非对称嫁接完成之后)如果一颗伪树已星化且非对称嫁接失败(伪树的根小于所有伪树上的节点的邻居的父结点)，就检查伪树上的节点有没有邻居不在伪树上，如果有则任选一个不在伪树上的邻居，把伪树根连接到该邻居的当前父结点 嫁接后续工作：继续用指针跳转法星化伪树(连通分量内的伪树之高总和不会因为嫁接变大，并且，每个指针跳转迭代都至少乘以2/3) 改进$W(O(n^2) -&gt; O((m + n)logn))$: Algorithm 5.212345678910111213141516171819(Connected Components for Sparse Graphs)Input: (1)A set of edges (i, j) given in an arbitrary order, and (2) a pseudoforest defined by a function D such that all the vertices in each tree belong to the same connected component.Output: The pseudoforest obtained after (1) grafting trees onto smaller vertices of other trees, (2) grafting rooted stars onto other trees if possible, and (3) performing the pointer jumping operation on each vertex. Description of a general iterationbegin1. perform a grafting operation if trees onto smaller vertices of other trees as follows(非对称嫁接):for all (i, j) belong to E pardo if (D(i) = D(D(i)) and D(j) &lt; D(i)) then set D(D(i)) := D(j)2. Graft rooted stars onto other trees if possible, as follows(星嫁接):for all (i, j) belong to E pardo if (i belongs to a star and D(j) != D(i)) then set D(D(i)) := D(j)3. If all the vertices are in rooted stars, then exit. Otherwise, perform the pointer jumping operation on each vertex as follows:for all i pardo set D(i) := D(D(i))end 非对称嫁接不会使连通分量里的伪树的高度总和变大 星嫁接不会使连通分量里的伪树的高度总和变大 (一遍)指针跳转法压缩伪树把不是星化伪树的高度降为至少原来的2/3(高度为1的不再降、高度为2的降为1、高度为3的降为2、高度为4的将为2……) 最小生成树 在一给定的无向图 G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边，而 w(u, v) 代表此边的权重 若存在 T 为 E 的子集且为无循环图，使得 的 w(T) 最小，则此 T 为 G 的最小生成树 最小生成树其实是最小权重生成树的简称 最小生成树串行算法输入：一个加权连通图，其中顶点集合为V，边集合为E 初始化：$V{new} = {x}$，其中x为集合V中的任一节点(起始点)，$E{new}= {}$,为空 重复下列操作，直到$V_{new} = V$: 在集合E中选取权值最小的边，其中u为集合$V{new}$中的元素，而v不在$V{new}$集合当中，并且$v∈V$(如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一) 将v加入集合$V{new}$中，将边加入集合$E{new}$中 输出：使用集合$V{new}$和$E{new}$来描述所得到的最小生成树 Prim’s algorithm kruskal’s algorithm 最小生成树并行算法基本思想: 如果(u,C(u))是从u出发的最小权边，则(u,C(u))必在最小生成树中;若不然，设最小生成树中从u到C(u)的路径是u,x_1,x_2,…,x_s,C(u)，则另一路径u,C(u),x_s,…,x_2,x_1串连了这些节点，并且权和更小 函数C定义了一个伪森林，使得其中的每棵伪树上有且仅有一个环 用指针跳转法可以把每棵伪树星化，并聚合成超顶点 取超顶点之间的边权为它们的跨伪树的连接边的最小权，并用C(.)来生成另一级别的伪森林，从而可以继续星化和合并超顶点 Sollin’s MST algorithm $T = O(log^2n), W = O(n^2)$ Algorithm 5.312345678910111213(Minimum Spanning Tree)Input: An n*n array W, representing a weighted connected graph such that no two edges have the same weight.Output: A label for each edge belonging to the MST.begin1. Set W_0 := W, n_0 := n, k := 02. while (n_k &gt; 1) do 2.1 Set k := k + 1 2.2 Set C(v) := u, where W_k-1(v, u) = min&#123;W_k-1(v, x)|x != v&#125;. Mark (v, C(v)). 2.3 Shrink each directed tree of the pseudoforest defined by C to a rooted star. 2.4 Set n_k to be equal to the number of the rooted stars, and set W_k to the n_k * n_k weight matrix of the graph induced by viewing each star as a single vertex.3. Restore each marked edge to its original name. end","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"列表和树","slug":"parellel_and_distributed_computing/paralell_compute3","date":"2017-03-13T16:00:00.000Z","updated":"2017-03-25T03:39:38.176Z","comments":true,"path":"2017/03/14/parellel_and_distributed_computing/paralell_compute3/","link":"","permalink":"https://chenfeng.github.io/2017/03/14/parellel_and_distributed_computing/paralell_compute3/","excerpt":"(并行与分布式计算二) 列表排序The list-ranking problem is to determine the distance of each node i from the end of the list 指针跳转法(pointer jumping technique)思想： 链表中的指针跳转可以由一次跳转一步改为一次跳转多步 如果能在O（1）时间内一次跳转k步，那么一次跳转2k步只需要双倍时间 如果为每个节点，把一次跳转2k步的跳转结果记录下来，那么以后一次跳转2k步也只需要O（1）时间 反复利用跳转步数翻倍和跳转结果记录的技巧，可以在O（log N）的时间内把跳转步数扩大为N","text":"(并行与分布式计算二) 列表排序The list-ranking problem is to determine the distance of each node i from the end of the list 指针跳转法(pointer jumping technique)思想： 链表中的指针跳转可以由一次跳转一步改为一次跳转多步 如果能在O（1）时间内一次跳转k步，那么一次跳转2k步只需要双倍时间 如果为每个节点，把一次跳转2k步的跳转结果记录下来，那么以后一次跳转2k步也只需要O（1）时间 反复利用跳转步数翻倍和跳转结果记录的技巧，可以在O（log N）的时间内把跳转步数扩大为N T = O(logn); W = O(nlogn)并不比串行算法(linear, O(n))更优 Algorithm 3.112345678910111213141516# List Ranking Using Pointer JumpingInput: A linked list of n nodes such that (1)the successor of each node i is given by S(i), and (2)the S value of the last node on the list is euqal to 0.Output: For each 1 &lt;= i &lt;= n, the distance R(i) of node i from the end of the list.begin1. for 1 &lt;= i &lt;= n pardo if (S(i) != 0) then set R(i):= 1 else set R(i):= 02. for 1 &lt;= i &lt;= n pardo set Q(i) := S(i) while (Q(i) ！= 0 and Q(Q(i)) != 0) do set R(i) := R(i) + R(Q(i)) set Q(i) := Q(Q(i))end 优化思路: 用快速并行算法把链表长度缩短为n/log n 要求：缩短和恢复都可以用很小的T，并且W=O(n) 方法：通过删除链表中的独立顶点集来缩短链表 在缩短的链表上用指针跳转法来求序，只需W=O(n) 最后用快速并行算法来恢复链表的长度 也即： 把列表分成约n/logn块{ $B_{i}$ }, 每块包含O(logn)个节点 在每块内对每个节点用最优串行算法求序(preliminary rank) 用O(logn)的平行算法把所有排好序的块组合 List-Ranking Strategy Shrink the linked list L until only O(n/logn) nodes remain. Apply the pointer jumping technique(Algorithm 3.1) on the short list of the remaining nodes. Restore the original list and rank all the nodes removed in step 1. independent sets A set I of nodes is independent if, whenever i belongs to I, S(i) not belongs to I. 缩减的列表结点必须构成一个独立集，即不相邻 Algorithm 3.21234567891011121314# removing nodes of an independent setInput: (1)Arrays S and P of length n representing, respectively, the successor and predecessor relations of linked list; (2)an independent set I of nodes such that P(i), S(i) != 0; (3)a value R(i) for each node i.Output: The list obtained after removal of all the nodes in I with the updated R values.begin1. Assign consecutive serial numbers N(i) to the elements of I, where 1 &lt;= N(i) &lt;= |I| = n'.2. for for all i belongs to I pardo set U(N(i)) := (i, S(i), R(i)) set R(P(i)) := R(P(i) + R(i)) set S(P(i)) := S(i) set P(S(i)) := P(i)end 删除独立顶点集并合并其权重到剩余顶点的并行复杂度: T=O(1) W=O(n) Determination of an Independent Set独立集合充分大：存在常数c，c属于(0, 1)，使集合包含顶点数不少于c×n 保证快速地迭代缩短链表 把长度为n的链表缩短为n/logn只需不超过log_1-c(logn)的T 最理想但没有快速算法：用序的奇偶性确定独立顶点集合，c=1/2 (存在快速算法)对链表使用三色着色算法，把局部最小色数(或最大)的节点作为独立集元素 从一个局部极小到下一个局部极小着色点，中间经过的点数最多为3，因此C=1/4 3-color 算法收敛很快，每次调用算法，着色的色数都变小为原色数的对数比例，这里的对数以2为基底 要把色数变小为3，T几乎是O(1) Algorithm 3.312345678910111213141516# simple optimal list rankingInput: A linked list with n nodes suc that the successor of each node i is given by S(i).Output: For each node i, the distance of i from the end of the list.begin1. set n_0 := n, k := 02. while n_k &gt; n/logn do 2.1 set k := k + 1 2.2 color the list with three colors and identify the set I of local minima. 2.3 remove the nodes in I, and store the appropriate information regarding the removed nodes(Algorithm 3.2). 2.4 let n_k be the size of the remaining list. compact the list into consecutive memory locations.3. apply the pointer jumping technique (Algorithm 3.1) to the resulting list.4. restore the original list and rank all the removed nodes by reversing the process performed in step2.end 缩短链表和恢复链表：T = O(log logn), W = O(n) 把长度为n的链表缩短为n/logn，只需不超过log_1-c(logn)的T 第一次迭代W = O(n), 第二次迭代W = O((1 - c)*c), … W = O(n + (1 - c)n + (1 - c)^2 *n + …) = O(n/c) = O(n) 恢复和缩短是对称的，T和W都相同 指针跳转是在长度为n/logn的已缩短链表上zuo做的，T = O(logn), W = O(n) 算法的并行复杂度: T = O(loglogn); W = (n) *一个优化的时间复杂度为O(logn)的列表求序算法…… 欧拉回路(the Euler-Tour Technique)树的欧拉回路是指：将一棵树的每一条边换成两条指向相反的有向边，成为一个欧拉图，就存在欧拉回路；可以定义一个论域为所有有向边的函数s(successor function)，描述这棵树的欧拉回路 Lemma 3.6: Given a tree T = (V, E) and an ordering of the set of vertices adjacent to each vertex v belongs to V, the function s defined previously specifies an Euler circuit in the directed graph T’ = (V, E’), where E’ is obtained by replacement of each e belongs to E by two arcs of opposite directions. we call the Euler circuit of T’ the Euler tour of T 每棵树都有欧拉回路 如果欧拉回路从树的根节点出发，则它实际上是树的节点深度优先遍历路径 给出一个由邻接表及附加的指针信息描述的树，求得一条欧拉回路的T = O(1), W = O(n), |V| = n(指针信息: data field + pointer * 2(描述下一个邻接点 + 描述该点在邻接表中指向此顶点的item)) 树求根(rooting a tree): 树根结点为r，对于每个非根结点v，寻找其父父结点p(v) 一对顶点之间的两条弧，先出后进的顶点是父节点，先进后出的是子节点 弧的顺序的确定：-把欧拉回路从其中一点处断开（例如去除回路路径列表中的最前与最后的弧的相邻关系） 用链表求序来对这些弧定序 树的一个欧拉回路为L[r] = &lt; u_0, u_1, … , u_d-1 &gt; 设s(&lt; u_d-1, r &gt;) = 0，将欧拉回路从r处截断，得到一条始于r，遍历所有顶点一次，终于r的欧拉路径 Algorithm 3.51234567891011# rooting a treeInput: (1)a tree T defined by the adjacency lists of its vertices, (2)an Euler tour defined by the successor function s, and (3)a special vertex rOutput: For each vertex v != r, the parent p(v) of v in the tree rooted at r.begin1. Identify the last vertex u appearing on the adjacency list of r. set s(&lt;u, r&gt;) = 02. Assign a weight of 1 to each arc &lt;x, y&gt;, and apply parallel prefix on the list of arcs defined by s.3. For each arc &lt;x, y&gt;, set x = p(y) whenever the prefix sum of &lt;x, y&gt; is smaller than the prefix sum of &lt;y, x&gt;.end 并行复杂度与链表求序相同： T=O(log n log log n) ？？？ W=O(n) 这里n是顶点数（树的边数是顶点数减一） 1、Postorder Numbering 后序遍历的序数 往下走的弧的权重为0，往上走的弧的权重为1，然后用链表中求前缀和的方法来算出后序遍历编号 Algorithm 3.61234567891011# Postorder NumberingInput: (1)A rooted binary tree with root r, and (2)the coresponding Euler path defined by the function sOutput: The postorder number post(v) of each vertex vbegin1. For each vertex v != r, assign the weights w(&lt;v, p(v)&gt;) = 1 and w(&lt;p(v&gt;, v) = 02. Perform parallel prefix on the list of arcs defined by s.3. For each vertex v != r, set post(v) equal to the prefix sum of &lt;v, p(v)&gt;. For v = r, set post(v) = n, where n is the number of vertices in the given tree.end 2、Computing the Vertex level 结点层数 可用类似Algorithm 3.6的算法，1和3做改动: w() = +1; w() = -1。level(v) = 的前缀和 3、Computing the preorder Number w(&lt; p(v), v &gt;) = 1; w(&lt; v, p(v) &gt;) = 0; preorder(v) = &lt; p(v), v &gt;前缀和 + 1; preorder(r) = 1 4、Computing the Number of Descendants w(&lt; p(v), v &gt;) = 1; w(&lt; v, p(v) &gt;) = 0; desc(v) = &lt; v, p(v) &gt;前缀和 - &lt; p(v), v &gt;前缀和; desc(r) = n - 1 以上四个并行算法:T = O(logn); W = O(n)（由平衡树方法求前缀和的平行算法所决定） *Tree Contraction(树收缩) …… *Lowest Common Ancestors ……","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"计算机网络和因特网","slug":"computer_network/computer_network_1","date":"2017-02-27T16:00:00.000Z","updated":"2017-04-23T12:33:50.854Z","comments":true,"path":"2017/02/28/computer_network/computer_network_1/","link":"","permalink":"https://chenfeng.github.io/2017/02/28/computer_network/computer_network_1/","excerpt":"因特网连接到因特网的设备：主机(host)或端系统(end system) 端系统通过通信链路(communication link)和分组交换机(parket switch)连接到一起 路由器(router) 链路层交换机(link-layer switch) 端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网 因特网部件运行一系列协议(protocol),协议控制因特网中信息的接受和发送","text":"因特网连接到因特网的设备：主机(host)或端系统(end system) 端系统通过通信链路(communication link)和分组交换机(parket switch)连接到一起 路由器(router) 链路层交换机(link-layer switch) 端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网 因特网部件运行一系列协议(protocol),协议控制因特网中信息的接受和发送 Reliable Stream Transport Service:Sends a large amount of data across a reliable “connection” Connectionless Packet Delivery Service:Routes small messages from one computer to another TCP(Transmission Control Protocol, 传输控制协议) IP(Internet Protocol, 网际协议)定义在路由器和端系统之间发送和接受的分组格式 因特网标准(Internet standard)由因特网工程任务组(Internet Engineering task Force, IETF)研发 IETF标准文档称请求评论(Request For Comment, RFC) 分布式应用程序(distributed application)涉及多台相互交换数据的端系统 应用程序编程接口(Application Programming Interface, API) 网络边缘主机(hosts) = 端系统: 客户(client)和服务器(server) 数据中心(data center)由许多服务器构成 接入网(access network)指将端系统连接到其边缘路由器(edge router)的物理链路 residential access nets institutional access networks (school, company) mobile access networks bandwidth(bit per second, bps); shared / dedicated(专用) 数字用户线(Digital Subscriber Line, DSL): existing telephone line to central office DSLAM &lt; 2.5 Mbps upstream transmission rate (typically &lt; 1 Mbps) &lt; 24 Mbps downstream transmission rate (typically &lt; 10 Mbps) frequency division multiplexing: different channels transmitted in different frequency bands 电缆因特网接入(cable Internet access) 有线电视 HFC: hybrid fiber coax asymmetric: up to 30Mbps downstream transmission rate, 2 Mbps upstream transmission rate 以太网Ethernet 光纤到户(Fiber To The Home, FTTH) 光纤分布体系结构：主动光纤网络(Active Optical Network, AON)和被动光纤网络(Passive Optical Network, PON) 光纤网络端接器(Optical Network Terminator, ONT) 分配器(splitter) 光纤线路端接器(Optical Line Terminator, OLT) 无线网络wireless network wireless LANs: within building (100 ft.) 802.11b/g/n (WiFi): 11, 54, 450 Mbps transmission rate wide-area wireless access provided by telco (cellular) operator, 10’s km between 1 and 10 Mbps 3G, 4G: LTE host sending function: takes application message breaks into smaller chunks, known as packets, of length L bits transmits packet into access network at transmission rate R link transmission rate, aka link capacity, aka link bandwidth 物理媒体(physical medium): 双绞铜线、同轴电缆、多模光纤缆、陆地无线电频谱、卫星无线电频谱 bit: propagates between transmitter/receiver pairs physical link: what lies between transmitter &amp; receiver 导引型媒体(guided media): signals propagate in solid media: copper, fiber, coax 非导引型媒体(unguided media): signals propagate freely, e.g., radio 双绞铜线 twisted pair (TP): two insulated copper wires Category 5: 100 Mbps, 1 Gbps Ethernet Category 6: 10Gbps 两根隔离的铜线以规则的螺旋形式排列组成；两根线绞合起来以减少邻近类似双绞线的电气干扰 一对电线构成一个通信链路；通常许多双绞线捆扎在一起成电缆 无屏蔽双绞线(Unshielded Twisted Pair, UTP) 常用于建筑物内网络 同轴电缆 coaxial cable: two concentric copper conductors bidirectional broadband: multiple channels on cable HFC 光纤 fiber optic cable: glass fiber carrying light pulses, each pulse a bit high-speed operation: high-speed point-to-point transmission (e.g., 10’s-100’s Gbps transmission rate) low error rate: repeaters spaced far apart immune to electromagnetic noise(不受电磁干扰) 单模光纤速率高，价格贵; 多模光纤速率低，价格便宜 电磁波 ratio signal carried in electromagnetic spectrum no physical “wire” bidirectional propagation environment effects: reflection obstruction by objects interference adio link types: terrestrial microwavee.g. up to 45 Mbps channels LAN (e.g., WiFi)54 Mbps wide-area (e.g., cellular)4G cellular: ~ 10 Mbps satellite Kbps to 45Mbps channel (or multiple smaller channels) 270 msec end-end delay geosynchronous versus low altitude 同步卫星(geostationary satellite); 近地轨道(Low-Earth Orbiting, LEO)卫星 编码(encoding)Non-return to Zero Inverted (NRZI): make a transition from current signal to encode a one; stay at current signal to encode a zero solves the problem of consecutive ones 经网络传输数据会产生时钟同步问题 Manchester: transmit XOR of the NRZ encoded data and the clock only 50% efficient (bit rate = 1/2 baud rate) 包含丰富的时钟信息 4B/5B: every 4 bits of data encoded in a 5-bit code 5-bit codes selected to have no more than one leading 0 and no more than two trailing 0s thus, never get more than three consecutive 0s resulting 5-bit codes are transmitted using NRZI achieves 80% efficiency 数据帧化Framing Break sequence of bits into a frame Typically implemented by network adaptor Sentinel-based: delineate frame with special pattern: 01111110 e.g., HDLC, SDLC, PPP Beginning sequence(8) + Header(16) + Body + CRC(16) + Ending sequence(8) problem: special pattern appears in the payload solution: bit stuffing sender: insert 0 after five consecutive 1s receiver: delete 0 that follows five consecutive 1s Counter-based: include payload length in header e.g., DDCMP SYN(8) + SYN(8) + Class(8) + Count(14) + Header(42) + Body + CRC(16) problem: count field corrupted solution: catch when CRC fails Clock-based: each frame is 125us long e.g., SONET: Synchronous Optical Network STS-n (STS-1 = 51.84 Mbps) 网络核心Communication networks can be classified based on the way in which the nodes exchange information: Communication Network: Broadcast Communication Network Switched Communication Network Circuit-Switched Communication Network Packet-Switched Communication Network Datagram Network Virtual Circuit Network Connection Oriented(面向连接)Has connection establish and release procedures Similar to circuit switched Transmission in order Bandwidth may be guaranteed Flow control may exist Error control may exist Connectionless(无连接)Each datagram may take a different path Datagrams may arrive out of order Link failures not a problem problem in a Generic Switch incoming links : how to demultiplex switch : how to switch outgoing links : how to multiplex Packet Switching(分组交换)各种网络应用中，端系统彼此交换报文(message) 分组(packet swicth): 源端系统像目的端系统发送报文，源将报文划分为较小的数据块 每个分组通过通信链路和分组交换机(packet switch)传送 两类交换机: 路由器和链路层交换机 packet-switching: hosts break application-layer messages into packets Data from any conversation can be transmitted at any given time A single conversation can use the entire link capacity if it is alone How to demultiplex? Use meta-data (header) to describe data Data are sent as formatted bit-sequences so-called packets. Packets have the following structure: Header + Data + Tailer Header and Trailer carry control information e.g., destination address, check sum 输出缓存(output buffer)(输出队列 output queue): 用于存储路由器准备发往相连的链路的分组; Store-and-Forward Networks(存储转发传输): At each node the entire packet is received, stored briefly, and then forwarded to the next node based on the header information Allows statistical(统计的) multiplexing 在接收完所有的比特后进行查错，无误在再进行转发 “热土豆”传输: 一边接收，一边转发 适用于网络质量好，出错概率低的情况 通过N条速率均为R的链路组成的路径(源和目的地之间有N-1台路由器)发送一个分组，端到端时延: $$d_{EndToEnd} = N \\frac{L}{R}$$ takes L/R seconds to transmit L-bit packet into link at R bps one-hop numerical example: L = 7.5 Mbits R = 1.5 Mbps one-hop transmission delay = 5 sec packet-switching forward packets from one router to the next across links on path from source to destination Each packet is independently switched header contains destination address Two key network-core functions routing: determines source-destination route taken by packets routing algorithms forwarding: move packets from router’s input to appropriate router output 排队时延(queue delay):到达的分组在链路忙于传输其他分组时必须在输出缓存中等待; 分组丢失(丢包 packet lost): 一个分组到达时缓存已被其他等待传输的分组完全充满，到达的分组或已经排队的分组之一将被丢弃 queuing and loss: if arrival rate exceeds transmission rate of link for a period of time packets will queue, wait to be transmitted on link can be dropped (lost) if memory (buffer) fills up Circuit Switching(电路交换)两台主机通信时网络在两台主机之间创建一条专用的端到端连接(end-to-end connection) 频分复用(Frequency-Division Multiplexing, FDM): 链路的频谱由跨越链路创建的所有连接所共享; 在连接期间链路为每条连接专用一个频段 时分复用(Time-Division Multiplexing, TDM): 时间被划分为固定区间的帧(frame)，每帧划分为固定数量的时隙; 网络跨越一条链路创建一条连接时在每个帧中为该连接指定一个时隙(slot) Time divided in frames and frames divided in slots Relative slot position inside a frame determines which conversation the data belongs to Needs synchronization(同步) between sender and receiver If a conversation does not use its circuit the capacity is lost Three phases(三个阶段) circuit establishment data transfer circuit termination If circuit not available: busy Examples Telephone networks ISDN (Integrated Services Digital Networks)(综合业务数字网) end-end resources allocated to, reserved for “call” between source &amp; dest dedicated resources: no sharing circuit-like (guaranteed) performance circuit segment idle(闲置) if not used by call (no sharing) Packet-Switching vs. Circuit-SwitchingMost important advantage of packet-switching: Ability to exploit statistical multiplexing More efficient bandwidth usage However, packet-switching needs to buffer and deal with congestion More complex switches Harder to provide good network services (e.g., delay and bandwidth guarantees) packet switching allows more users to use network example: 1 Mb/s linkeach user: 100 kb/s when “active” active 10% of time circuit-switching: 10 users packet switching: with 35 users, probability &gt; 10 active at same time is less than .0004 * packet switching: great for bursty data resource sharing simpler, no call setup excessive congestion possible: packet delay and loss protocols needed for reliable data transfer, congestion control Q: How to provide circuit-like behavior? bandwidth guarantees needed for audio/video apps Virtual-Circuit Packet Switching(虚电路交换) Hybrid of circuit switching and packet switching Data is transmitted as packets All packets from one packet stream are sent along a pre-established path (=virtual circuit) Guarantees in-sequence delivery of packets Packet header only contains local virtual circuit identifier (VCI) Demultiplexing and switching based on VCI Note: packet headers don’t need to contain the full destination address of the packet Example: ATM networks Communication with virtual circuits takes place in three phases VC establishment data transfer VC disconnect Internet structure: network of networks(网络的网络)End systems connect to Internet via access ISPs (Internet Service Providers) residential, company and university ISPs Access ISPs in turn must be interconnected. so that any two hosts can send packets to each other Resulting network of networks is very complex evolution was driven by economics and national policies Question: given millions of access ISPs, how to connect them together?Option: connect each access ISP to every other access ISP?Option: connect each access ISP to one global transit ISP? Customer and provider ISPs have economic agreement. at center: small # of well-connected large networks “tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), national &amp; international coverage content provider network (e.g., Google): private network that connects it data centers to Internet, often bypassing tier-1, regional ISPs 分组交换网中的时延、丢包和吞吐量(delay, loss, throughput in networks)时延 结点处理时延(nodal processing delay): 检查分组首部和决定出口链路、查错校验 排队时延(queuing delay): 分组在出口链路队列上等待传输 传输时延(transmission delay): L/R(分组长度/链路传输速率); 将所有分组比特推(传输)向链路所需时间 传播时延(propagation delay): d/s(距离/传播速率)，介质相关 结点总时延(total nodal delay) $$d{nodal} = d{proc} + d{queue} + d{trans} + d_{prop}$$ How do loss and delay occur:packets queue in router buffers packet arrival rate to link (temporarily) exceeds output link capacity packets queue, wait for turn $d_{proc}$: nodal processing check bit errors determine output link typically &lt; msec $d_{queue}$: queueing delay time waiting at output link for transmission depends on congestion level of router $d_{trans}$: transmission delay L: packet length (bits) R: link bandwidth (bps) $d_{trans} = L/R$ $d_{prop}$: propagation delay d: length of physical link s: propagation speed (~2x108 m/sec) $d_{prop} = d/s$ $d{trans}$ and $d{prop}$ are very different 排队时延和丢包流量强度(traffic intensity): La/R; a: 分组到达队列的平均速率(pkt/s)(a: average packet arrival rate) R: link bandwidth (bps) L: packet length (bits) La/R ~ 0: avg. queueing delay small La/R -&gt; 1: avg. queueing delay large La/R &gt; 1: more “work” arriving than can be serviced, average delay infinite! 设计系统时流量强度不能大于1 随着流量强度接近于1，平均排队时延迅速增加 丢包: 分组到达时路由器链路队列已满，路由器丢弃(drop)该分组，该分组会丢失(lost) queue (aka buffer) preceding link in buffer has finite capacity packet arriving to full queue dropped (aka lost) lost packet may be retransmitted by previous node, by source end system, or not at all 吞吐量(throughput)瞬时吞吐量(instantaneous throughput): 主机接收到文件的速率(bps) 平均吞吐量(average throughput): F/T秒; 接收总共F比特用去T秒 瓶颈链路(bottleneck link): 系统中传输速率最小的链路 throughput: rate (bits/time unit) at which bits transferred between sender/receiver instantaneous: rate at given point in time average: rate over longer period of time bottleneck link:link on end-end path that constrains end-end throughput 协议层次 服务模型(protocol layers, service models)分层(layer) layers: each layer implements a service via its own internal-layer actions relying on services provided by layer below 协议栈(protocol stack) 应用层(第七层): 报文(message) 运输层(四层): 报文段(segment) 网络层(三层): 数据报(datagram) 链路层(二层): 帧(frame) 物理层(一层): 将帧中的比特一个一个从一个结点移动到下一个结点 OSI(Open System Interconnect Reference Model, 开放系统互联参考模型) 表示层: 数据压缩、数据加密、数据描述 会话层: 数据交换定界、同步功能，建立检查点和恢复方案 Internet protocol stack: application: supporting network applications FTP, SMTP, HTTP transport: process-process data transfer TCP, UDP network: routing of datagrams from source to destination IP, routing protocols link: data transfer between neighboring network elements Ethernet, 802.111 (WiFi), PPP physical: bits “on the wire ISO/OSI reference model: (two more layer) presentation: allow applications to interpret meaning of data, e.g., encryption, compression, machine-specific conventions session: synchronization, checkpointing, recovery of data exchangeInternet stack “missing” these layers! these services, if needed, must be implemented in application 封装(encaosulation): 应用层报文(application-layer message) -&gt; 运输层报文段(transport-layer segment) -&gt; 网络层数据报(network-layer datagram) -&gt; 链路层帧(link-layer frame) 分组 : 首部字段 + 有效载荷字段(payload field)(来自上一层的分组) 面对攻击的网络(networks under attack: security)Internet not originally designed with (much) security in mind original vision: “a group of mutually trusting users attached to a transparent network”  Internet protocol designers playing “catch-up” security considerations in all layers! 恶意软件(malware) 僵尸网络(botnet) 病毒(virus): 需要某种形式的用户交互感染用户设备的恶意软件 蠕虫(worm): 无需任何明显用户交互就能进入设备的恶意软件 malware can get in host from: virus: self-replicating infection by receiving/executing object (e.g., e-mail attachment) worm: self-replicating infection by passively receiving object that gets itself executed spyware malware can record keystrokes, web sites visited, upload info to collection site infected host can be enrolled in botnet, used for spam. DDoS attacks 拒绝服务攻击(Denial-of-Service (DoS) attack) 弱点攻击: 向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文 带宽洪泛: 向目标主机发送大量的分组使目标接入链路拥塞 连接洪泛: 在目标主机中创建大量半开或全开TCP连接 分布式Dos(Distributed DoS, DDoS): 攻击者控制多个源向目标发送大量流量 Denial of Service(DoS): attackers make resources (server, bandwidth) unavailable to legitimate traffic by overwhelming resource with bogus traffic select target break into hosts around the network (see botnet) send packets to target from compromised hosts 分组嗅探器(packet sniffer) packet “sniffing”: broadcast media (shared Ethernet, wireless) promiscuous network interface reads/records all packets (e.g., including passwords!) passing by wireshark software is a (free) packet-sniffer IP哄骗(IP spooning) IP spoofing: send packet with false source address ~ history","categories":[],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://chenfeng.github.io/tags/computer-network/"}]},{"title":"并行计算基础知识及基本并行算法","slug":"parellel_and_distributed_computing/paralell_compute1&2","date":"2017-02-27T16:00:00.000Z","updated":"2017-04-03T08:27:31.927Z","comments":true,"path":"2017/02/28/parellel_and_distributed_computing/paralell_compute1&2/","link":"","permalink":"https://chenfeng.github.io/2017/02/28/parellel_and_distributed_computing/paralell_compute1&2/","excerpt":"(并行与分布式计算一) 基础知识设计分布式并行算法基本流程1.1发现计算问题的内在并行性 1.2设计与硬件无关的并行算法","text":"(并行与分布式计算一) 基础知识设计分布式并行算法基本流程1.1发现计算问题的内在并行性 1.2设计与硬件无关的并行算法 让算法设计者专注于挖掘问题相关的内在并行性而不是被繁琐的硬件特性所干扰 便于不同硬件环境下的开发者移植算法 便于算法到硬件的映射的自动匹配和优化 为并行和分布式计算的系统库(中间件)研发提供一套高层语义抽象 PRAM(Parallel Random Access Machine, 随机存取并行机器): 一个简单的并行算法模型 Parallel: 可以自由分布任意个处理器并行地读、写和计算 Random Access: 处理器可以按下面其中一条规则自由地访问“共享内存” 规则一: Exclusive Read Exclusive Write(EREW)(不允许同时读和同时写) 规则二: Concurrent Read Exclusive Write(CREW)(允许同时读但不允许同时写) 规则三: Concurrent Read Concurrent Write(CRCW)(允许同时读和同时写) 算法复杂度框架: work(计算量(operation)), time(计算时间) 2.1发现硬件的网络拓扑和处理能力 网络拓扑: 静态: 环、星、树、超立方、图 动态: 互联网或移动网络中的分布式计算 处理能力: 指标: 处理速度和处理规模 结构: 同构、异构 方式: 内存计算还是内外存混合计算，计算密集型还是数据密集型 发现网络拓扑的算法: 目的一: 建立数据通信的路由 目的二: 死锁检测和解除 目的三: 优化数据传播和交换 发现处理能力的方法: 测试程序 人工检测 2.2设计与计算问题无关的分布式计算协议 (所需计算协议包括以下但不止) 广播、多播和数据收集 同步和异步控制 终止检测和全局谓词(条件)检测 快照保存与检查点恢复 3.把并行算法映射到硬件上，匹配、优化 匹配: 与硬件相关的具体并行算法 数据分划和任务指派方案(静态或动态) 并行和分布式计算的程序 优化: 面向硬件体系结构的算法复杂度分析 针对硬件特性的算法改进和程序调优 并行计算的基本方法平衡树方法(Balanced Trees) 例: 设是满足结合律的二元运算符，考虑计算$$ S_i = x_1 x_2 … x_i, 1 \\leq i \\leq n $$ Algorithm 2.112345678910111213141516# Prefix SumsInput: An array of n = 2^k elements (x_1, x_2, ..., x_n), where k is a nonnegative integer.Output: The prefix sums s_i, for 1 &lt;= i &lt;= n.begin1. if n = 1 then &#123;set s_1 := x_1; exit&#125;2. for 1 &lt;= i &lt;= n/2 pardo set y_i := x_2i-1 * x_2i3. Recursively, compute the prefix sums of &#123;y_1, y_2, ..., y_n&#125;, and store them in z_1, z_2, ..., z_n/24. for 1 &lt;= i &lt;= n pardo &#123;i even : set s_i := z_i/2 i = 1 : set s_1 := x_1 i odd &gt; 1 : set s_i := z_(i-1)/2 * x_i&#125;end 复杂度分析$$ T(n) = T(\\frac{n}{2}) + a $$$$ W(n) = W(\\frac{n}{2}) + bn $$求解递归方程$$ T(n) = O(logn) $$$$ W(n) = O(n) $$ Algorithm 2.2123456789101112131415161718# Nonrecursive Prefix SumsInput: An array A of size n = 2^k, where k is a nonnegative integer.Output: An array C such that C(0, j) is the jth prefix sum, for 1 &lt;= j &lt;= nbegin1. for 1 &lt;= j &lt;= n pardo set B(0, j) := A(j)2. for h = 1 to logn do for 1 &lt;= j &lt;= n/2^h pardo set B(h, j) := B(h - 1, 2j - 1) * B(h - 1, 2j)3. for h = logn to 0 do for 1 &lt;= j &lt;= n/2^h pardo &#123;j even : set C(h, j) := C(h + 1, j/2) j = 1 : set C(h, 1) := B(h, 1) j odd &gt; 1 : set C(h, j) := C(h + 1, (j - 1)/2)*B(h, j)&#125;end 指针跳转法(Pointer Jumping) 例一: 存储在数组中的链表求序 串行算法: 线性复杂度 并行复杂度: T = O(logn), W = O(nlogn) 例二: 为森林里的每个节点找所在的那棵树的根节点 Algorithm 2.4123456789101112# Pointer JumpingInput: A forest of rooted directed trees, each with a self-loop at its root, such that each arc is specified by (i, P(i)), where 1 &lt;= i &lt;= n.Output: For each vertex i, the root S(i) of the tree containing i.begin1. for 1 &lt;= i &lt;= n pardo set S(i) := P(i) while (S(i)) != S(S(i)) do set S(i) := S(S(i))end T = O(logh); W = O(nlogh) Algorithm 2.512345678910111213# Parallel Prefix on Rooted Directed TreesInput: A forest of rooted directed trees, each with a self-loop at its root such that (1)each arc is specified by (i, P(i)), (2)each vertex i has a weight W(i), and (3)for each root r, W(r) = 0Output: For each vertex i, W(i) is set equal to the sum of the weights of vertices on the path from i to the root of its tree.begin1. for 1 &lt;= i &lt;= n pardo set S(i) := P(i) while (S(i)) != S(S(i)) do set W(i) := W(i) + W(S(i)) set S(i) := S(S(i))end T = O(logn); W = O(nlogn) 分而治之法(Divide and Conquer)例: 找二维平面上的点的凸包(planar convex hull) 分: 把这些顶点按由左到右平均分成两组 治: 在这两组内分别求凸包(求解两个规模相对较小的问题，递归) 合: 把两组凸包用快速算法合为一个 Algorithm 2.61234567891011# Simple Upper HullInput: A set S of n points in the plane, no two of which have the same x or y coordinates such that x(p_1) &lt; x(p_2) &lt; ... &lt; x(p_n), where n is a power of 2.Output: The upper hull of S.begin1. If n &lt;= 4, then use a brute-force method to determine UH(S), and exit.2. Let S_1 = (p_1, p_2, ..., P_n/2) and S_2 = (p_n/2+1, ..., p_n). Recursively, compute UH(S_1) and UH(S_2) in parallel.3. find the upper common tangent between UH(S_1) nad UH(S_2), and deduce the upper hull of S.end $$ T(n) \\leq T(\\frac{n}{2}) + alogn $$$$ W(n) \\leq 2W(\\frac{n}{2} + bn) $$并行复杂度: $ T = O(log^2 n); W = O(nlogn) $ 数据划分法(partition strategy) 例: 归并排序 1.数据均分为若干等分 2.在每一等分内用其它方法排序 3.平衡树快速并行合并这些等分 Algorithm 2.7123456789101112131415# PartitionInput: Two arrays A = (a_1, a_2, ..., a_n) and B = (b_1, b_2, ..., b_m) in increasing order, where both logm and k(m) = m/logm are integers.Output: k(m) pairs (A_i, B_i) of subsequences of A and B such that (1)|B_i| = log m, (2)\\sum |A_i| = n, and (3)each element of A_i and B_i is larger than each element of A_i-1 or B_i-1, for all 1 &lt;= i &lt;= k(m)-1begin1. set j(0) := 0, j(k(m)) := n2. for 1 &lt;= i &lt;= k(m) - 1 pardo 2.1. Rank b_ilogm in A using binary search method, and let j(i) = rank(b_ilogm : A)3. for 0 &lt;= i &lt;= k(m) - 1 pardo 3.1. set B_i := (b_ilogm+1, ..., b_(i+1)logm) 3.2. set A_i := (a_j(i) + 1, ..., a_j(i+1)) (A_i is empty if j(i) = j(i+1))end 合并后的序 = 自序 + 交叉序 自序(a_i) = {a_0, a_1, …, a_n-1}中有多少a_j 排在a_i前面(在这里即i) 交叉序(a_i) = {b_0, b_1, …, b_n-1}中有多少b_j排在a_i前面 并行复杂度: T = O(logn); W = O(n) 流水线方法(Pipelining) 例: 2-3树的数据插入 批量插入多个点及其并行复杂度T = O(logn); W = O(klogn) breaking up a task into a sequence of subtask t_1, t_2, …, t_m…… 加速层叠法(Accelerated Cascading) 例: 数组找最大值 常数的并行时间复杂度 Algorithm 2.8123456789101112# Basic MaximumInput: An array A of p distinct elements.Output: A Boolean array M such that M(i) = 1 if and only if A(i) is the maximum element of A.begin1. for 1 &lt;= i, j &lt;= p pardo if (A(i) &gt;= A(j)) then set B(i, j) := 1 else set B(i, j) := 02. for 1 &lt;= i &lt;= p pardo set M(i) := B(i, 1) &amp; B(i, 2) &amp; ... B(i, p)end $ T = O(1); W = O(p^2) $ 双层log深度树(doubly logarithmic-depth tree): 最底层节点数 为 n，根节点的孩子节点数 为 $n^{\\frac{1}{2}}$，下一层每个节点的孩子节点数 $n^{\\frac{1}{2^2}}$，… 假设$n = 2^{2^k}$, 树根有$2^{2^{k-1}}$个孩子, 第一层有$2^{2^{k-2}}$个孩子, …, 第i层有$2^{2^{k-i-1}}$个孩子, … 倒数第二层每个节点有常数个子节点 向上合并用常数复杂度求最大值方法 整体并行复杂度: $$ T(n) = O(log log n) $$ $$ W(n) = O(n log log n) $$ accelerated cascading: start with the optimal algorithm until the size of the problem is reduced to a centain threshold value. 双层log深度树加速 Then, shift to the fast but nonoptimal algorithm. 常数时间算法层叠 对称破坏法(Symmetry Breaking) 例: 环的三色着色问题 要求: 相邻的点不能是相同的颜色 串行算法: 在环上随机选一点把环打开得到一个队列；从队首开始除队尾外以0，1相间着色，队尾着色为2(确保队尾和队首、对中倒数第二节点的颜色都不同) 并行算法大致思想: 从以节点编号为颜色的着色方案开始，通过迭代算法，逐步减少着色数量 Algorithm 2.91234567891011# Basic ColoringInput: A directed cycle whose arcs are specified by an array S of size n and a coloring c of the vertices.Output: Another coloring c' of the verteces of the cycle.beginfor 1 &lt;= i &lt;= n pardo 1. set k to the least significant bit position in which c(i) and c(S(i)) disagree. 2. set c'(i) := 2k + c(i)_kend T = O(1); W = O(n) definition: $log^{(1)}x = logx$, and $log^{(i)}x = log(log^{(i-1)}x)$ Fast Coloring反复运用这个算法使得从颜色序号{0, 1, 2}中重新选择颜色给每个顶点着色且相邻顶点色不同, 整体并行复杂度为: $$ T = O(logn); W = O(nlogn) $$ Algorithm 2.10123456789101112131415# 3-coloring of a CycleInput: A directed cycle of length n whose arcs are specified by an array S.Output: A 3-coloring of the vertices of the cycle.begin1. for 1 &lt;= i &lt;= n pardo set C(i) := i2. Apply Algorithm 2.9 once.3. Sort the vertices by their colors.4. for i = 3 to 2 \\ceiling(logn) do for all vertices v of color i pardo color v with the smallest color from &#123;0, 1, 2&#125; that is diffrrent from the colors of its two neighbors.end T = O(logn); W = O(n) 三色环着色过程 迭代调用算法2.9，把颜色降至c种以下(c是较小常数，如10等) 遍历从3到c-1种颜色:for(color = 3; color &lt; c; ++color) { 环中结点号i if i的颜色为color pardo根据左右邻居占用3颜色0,1,2中的哪几种，决定结点i可以取得颜色({0,1,2}中的某一个) } 在1.中，设迭代t的颜色数为$nt$，则$n{t+1} \\leqslant 2(\\ulcorner log_2n_t \\urcorner - 1) + 1$","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://chenfeng.github.io/tags/并行计算/"}]},{"title":"不应当使用虚函数的情况","slug":"Cplusplus_thinking/不应当使用虚函数的情况","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:49:01.667Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/不应当使用虚函数的情况/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/不应当使用虚函数的情况/","excerpt":"关于是否应该所有成员函数缺省为虚函数的争论 只有涉及继承时，才需要考虑与此相关的问题 适用的情况 基类派生出的子类需要重写(or 覆盖，override)，基类中相应的成员和函数应声明为虚函数 不适用的情况 虚函数代价并不是非常高，当时会带来一定的额外开销 有些情况下非虚函数能够正确运行而虚函数不能 有些类并非为继承而设计(设计时并不兼容被继承)","text":"关于是否应该所有成员函数缺省为虚函数的争论 只有涉及继承时，才需要考虑与此相关的问题 适用的情况 基类派生出的子类需要重写(or 覆盖，override)，基类中相应的成员和函数应声明为虚函数 不适用的情况 虚函数代价并不是非常高，当时会带来一定的额外开销 有些情况下非虚函数能够正确运行而虚函数不能 有些类并非为继承而设计(设计时并不兼容被继承) 效率程序调用显式提供的对象的虚拟成员函数，优秀的编译器不带来额外的开销(与调用非虚函数相同)如：12T x;x.f(); 在这里，f是否虚函数应该没有影响；产生对T::f的直接调用 若所有对成员函数的调用都是通过显式指定的对象进行的则成员函数是否是虚函数就无关紧要了 一旦通过指针或引用进行调用就是有意义的 虚函数会产生额外的开销 用内存引用(memory reference)计数衡量大概的开销 随着微处理器的速度越来越快，内存应用耗时占比会越高，此项指标更精确；但高速缓存的更广泛更大量的使用也使得这项粗糙的估计更不准确；但在这儿这样估计是必要的。 如：12345int&amp; IntArray::operator[](unsigned n) &#123; if (n &gt;= arraysize) throw \"subscript out of range\"; return data[n];&#125; 设函数为内联函数，好的实现在直接通过对象使用operator[]时不引入新开销 通过指针或引用调用operator[]的开销与三个内存引用相关: 对指针本身 为此成员函数初始化this指针 用于调用返回序列 调用虚函数则通常需要多出另外的三个内存应用: 从对象取出描述对象类型的表的地址值 取出虚函数的地址 在可能的较大外围对象中，取出本对象的偏移量 成员函数很大时，这样的开销远小于函数执行所需开销，额外的开销不成问题 一个潜在开销很大的例子及改进策略：1234567891011121314151617181920212223242526272829303132333435363738class InputBuffer &#123;public: //... virtual int get(); //...&#125;;// all derived class of InputBuffer can override get()int countlines(InputBuffer&amp; b) &#123; int n = 0; int c; // get() would be called a lot of times while ((c = b.get()) != EOF) &#123; if (c == '\\n') ++n; &#125; return n;&#125;// imroved versionclass InputBuffer &#123;public: //... int get() &#123; // call a virtual function only in specified condition if (next &gt;= limit) return refill(); return *next++; &#125;protected: // read in plenty of characters virtual int refill();private: char* next; char* limit;&#125;; 行为当派生类并不严格扩展基类行为时，成员函数定义为虚函数会导致不正确的结果 123456789101112131415161718192021222324class IntArray &#123;public: IntArray(unsigned); int&amp; operator[] (unsigned); unsigned size() const; //...&#125;;class IntBlock: public Int Array &#123;public: IntBlock(int l, int h): low(l), high(h), IntArray(l &gt; h ? 0 : h - l + 1) &#123;&#125; int&amp; operator[](int n) &#123; return IntArray::operator[](n - low); &#125;private: int low, high;&#125;;int sum(IntArray&amp; x) &#123; int result = 0; for (int i = 0; i &lt; x.size(); ++i) result += x[i]; return result;&#125; 当将一个实际类型为IntBlock的对象传给sum()时，只有operator[]为非虚函数才有正确的行为 有些函数只为特定有限制的用途而设计 类的接口可以有两种用户：使用该类对象的人和从这个类派生新类的人 有的类会故意不考虑其他人如何通过继承改变它的行为 虚析构函数 有需要自定义的析构函数 存在此种情形：指向基类的指针或引用都有其静态类型，并实际上都指向派生类的对象","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"供给与需求的基本原理","slug":"economics/供给与需求的基本原理","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:52:01.314Z","comments":true,"path":"2017/01/21/economics/供给与需求的基本原理/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/economics/供给与需求的基本原理/","excerpt":"需求表 在其他条件相同时，一种物品的价格越高，人们愿意购买的数量就越少；而市场价格越低，人们愿意购买的数量就越多 价格与需求之间的关系可以用一张需求表(demand schedule)或一条需求曲线(demand curve)表示 需求曲线：数量和价格呈反比关系","text":"需求表 在其他条件相同时，一种物品的价格越高，人们愿意购买的数量就越少；而市场价格越低，人们愿意购买的数量就越多 价格与需求之间的关系可以用一张需求表(demand schedule)或一条需求曲线(demand curve)表示 需求曲线：数量和价格呈反比关系 需求向下倾斜规律(law of downward-sloping demand): 当一种商品的价格上升时(同时其他条件保持不变)，购买者便会趋向于购买更少的数量；当价格下降、其他条件保持不变时，需求量会增加 替代效应(substitution effect): 当一种物品的价格上升时，人们会用其他类似的物品替代它 收入效应(income effect): 当价格上升时，人们会发现自己比以前穷了一些 市场需求 市场需求曲线是将在每一价格水平下所有个人的需求量加总而得到的 市场需求曲线符合需求向下倾斜规律 需求曲线背后的因素 消费者的平均收入是需求的重要决定因素。个人收入上升，即使价格不变，人们也会倾向于购买更多数量的几乎任何物品。 市场规模(用人口衡量)影响市场需求曲线 相关物品的价格及其可获得性会影响对该物品的需求，尤其是替代品之间存在着重要的联系 爱好或偏好的主观因素。代表文化、历史因素，反映心理、生理需要或人为造成的需要或者传统、宗教的因素 其他特殊的因素 需求的移动：除物品价格以外的其他因素(非价格变量)发生了变化 需求变动：商品价格之外的因素变化引起购买数量发生变化 需求增加，需求曲线向右移动，每一价格水平人们会购买更多物品 需求减少，需求曲线向左移动，每一价格水平人们会购买更少物品 供给表 一种商品的供给表(supply schedule)或供给曲线(supply curve)体现在其它条件下，该商品的市场价格与生产者愿意生产和销售的数量之间的关系 应当保持不变的条件包括生产成本、相关物品的价格和政府政策 供给曲线 供给曲线向上倾斜的重要原因之一是边际收益递减规律：每一个新增加的劳动(要素)所增添的数量是递减的 供给曲线背后的因素 一个关键因素是生产成本 生产成本主要取决于投入品(劳动、能源或机器等)价格和技术进步(降低生产同量产出所需的投入品数量的变化)(从应用科学突破到现有技术的更新与挖潜、生产流程的重新组织) 供给受相关物品价格的影响 一种替代品的价格上升，另一种替代品的供给就会下降 政府政策会对供给曲线产生重大影响 特殊因素(气候条件之类)也会影响供给曲线 供给的移动：价格之外的其他因素发生变动而引起供给数量发生变动 在市场的每一价格水平，当供给的数量都增加(或减少)时，供给增加(或减少) 供给和需求的平衡 市场均衡(market equilibrium)：供给和需求的力量相互作用，产生均衡的价格和均衡的数量。 在该点买者所愿意购买的数量正好等于卖者所愿意出售的数量。 当供求力量平衡时，只要其他条件保持不变，价格就没有理由继续波动 市场出清价格(market-clearing price)：需求量与供给量相等的价格水平(均衡价格) 供给曲线与需求曲线的均衡 均衡价格与均衡数量发生在愿意供给的数量等于愿意购买的数量的水平上 在竞争市场上，均衡发生在供给曲线与需求曲线的交点 在均衡价格水平上，市场上不存在短缺或过剩 供给或需求的移动对均衡的影响 当影响需求或供给的诸因素发生变化时就会导致需求或供给发生变动，并引起市场上的均衡价格和均衡数量也发生变动 解释价格和数量的变动：供给变化或需求变化；需求变化或沿着需求曲线移动 供给、需求和移民：移民对于当地劳工市场影响微弱;人口流动性强，新移民流向最可能找到工作的城市，迁入城市对劳工需求已经上升;移民迁入，当地居民迁出，劳动总供给实际上没变动 通过价格进行分配 用钱包进行配给(rationing by the purse)：市场通过供求的相互作用决定所有投入和产出的均衡价格和均衡数量，将社会的稀缺品配置或配给到各种用途中","categories":[],"tags":[{"name":"微观经济学","slug":"微观经济学","permalink":"https://chenfeng.github.io/tags/微观经济学/"}]},{"title":"代理类","slug":"Cplusplus_thinking/代理类","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:49:04.379Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/代理类/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/代理类/","excerpt":"如何设计C++容器，能够包含类型不同而彼此相关的对象如何将继承自同一父类的属于不同子类的对象装入同一个容器（如vector）之中？(将容器和继承运用在一起) 代理 surrogate允许将整个派生层次压缩在一个对象类型中 surrogate是handle(句柄)类中最简单的一种","text":"如何设计C++容器，能够包含类型不同而彼此相关的对象如何将继承自同一父类的属于不同子类的对象装入同一个容器（如vector）之中？(将容器和继承运用在一起) 代理 surrogate允许将整个派生层次压缩在一个对象类型中 surrogate是handle(句柄)类中最简单的一种 一个表示不同交通工具的类派生层次1234567891011class Vehicle &#123;public: virtual double weight() const = 0; virtual void start() = 0; // pure virtual function // ...&#125;class RoadVehicle: public Vehicle &#123;/*...*/&#125;class AutoVehicle: public Vehicle &#123;/*...*/&#125;class Aircraft : public Vehicle &#123;/*...*/&#125;class Helicopter : public Vehicle &#123;/*...*/&#125; 一个容器123Vehicle parking_lot[1000]; // errorAutoVehicle x;parking_lot[num_vehicles++] = x; Vehicle是虚基类，不能实例化 子类对象转化为父类对象会丢失父类中没有的成员 parking_lot是Vehicle的集合而不是所有继承自Vehicle的对象的集合 间接层 indirection存储指针替代存储对象本身123Vehicle* parking_lot[1000];AutoVehicle x;parking_lot[num_vehicles++] = &amp;x; x是局部变量，释放之后parking_pot指向未知 存储副本的指针而非原对象的指针 12AutoVehicle x;parking_lot[num_vehicles++] = new AutoVehicle(x); 带来动态内存管理的负担 必须知道要放入parking_lot中的对象的静态类型1234if (p != q) &#123; delete parking_pot[p]; parking_pot[p] = new Vehicle(parking_pot[q]);&#125; // virtual base class has no instance 虚复制函数在Vehicle中增加合适的纯虚函数来复制编译时类型未知的对象12345678class Vehicle &#123;public: virtual double weight() const = 0; virtual void start() = 0; virtual Vehicle* copy() const = 0; virtual ~Vehicle() &#123;&#125; // virtual destructor // ...&#125; 在Vehicle的所有派生类中添加成员函数copy，若vp指向Vehicle不确定的子类的对象，vp-&gt;copy()返回指向该对象新建副本的指针。例如：123Vehicle* Trunk::copy() const &#123; return new Truck(*this);&#125; 定义代理类 用类表示概念避免显示处理内存分配且能保持父类在运行时绑定的属性 定义一个行为与Vehicle对象相似而又潜在地表示所有继承自Vehicle对象的东西 —— 代理（surrogate） 1234567891011121314class VehicleSurrogate &#123;public: VehicleSurrogate(); VehicleSurrogate(const Vehicle&amp;); ~VehicleSurrogate(); VehicleSurrogate(const VehicleSurrogate&amp;); VehicleSurrogate&amp; operator=(const VehicleSurrogate&amp;); // object fuctions of Vehicle double weight() const; void start(); // ...private: Vehicle* vp;&#125; 空代理(empty surrogate)的行为类似于空指针123456789101112131415161718192021222324252627282930VehicleSurrogate::VehicleSurrogate(): vp(0) &#123;&#125; // empty surrogateVehicleSurrogate::VehicleSurrogate(const Vehicle&amp; v): vp(v.copy()) &#123;&#125;VehicleSurrogate::~VehicleSurrogate() &#123; delete vp;&#125;VehicleSurrogate::VehicleSurrogate(const VehicleSurrogate&amp; v): vp(v.vp ? v.vp-&gt;copy() : 0) &#123;&#125;VehicleSurrogate&amp; VehicleSurrogate::operator=(const VehicleSurrogate&amp; v) &#123; if (this != &amp;v) &#123; delete vp; vp = (v.vp ? v.vp-&gt;copy() : 0); &#125; return *this;&#125;// call the corresponding object functionsdouble VehicleSurrogate::weight() const &#123; if (vp == 0) throw \"empty VehicleSurrogate.weight()\"; return vp-&gt;weight();&#125;void VehicleSurrogate::start() &#123; if (vp == 0) throw \"empty VehicleSurrogate.start()\"; vp-&gt;start();&#125; tip: 每次对copy的调用都是一个虚拟调用。类Vehicle的对象并不存在 赋值构造函数和赋值操作符中v.vp非零的检测是必需的 赋值操作符确保没有将代理赋值给自身 总结最开始的parking_pot容器可设计为：123VehicleSurrogate parking_lot[1000];Automobile x;parking_pot[num_vehicles++] = x; 将继承和容器共用需要处理两个问题： 控制内存分配 把不同类型的对象放进同一个容器中 采用基础C++技术，在现有的继承层次上加上一层抽象，合适地解决了这些问题。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"宏观经济现象鸟瞰","slug":"economics/宏观经济现象鸟瞰","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T04:12:28.225Z","comments":true,"path":"2017/01/21/economics/宏观经济现象鸟瞰/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/economics/宏观经济现象鸟瞰/","excerpt":"三个重要的宏观经济变量 实际国内生产总值(real GDP):经济体内所有人的实际总收入。人均国内生产总值(GDP per capita): 经济体内平均而言每个人的实际收入。 通货膨胀率(inflation rate):物价水平变动的百分比。(物价指数)用消费者价格指数(consumer price index, CPI)或GDP缩减指数(GDP deflator index)衡量。 失业率(unemployment rate):经济体中没有工作当正在积极找工作的劳动力比重。","text":"三个重要的宏观经济变量 实际国内生产总值(real GDP):经济体内所有人的实际总收入。人均国内生产总值(GDP per capita): 经济体内平均而言每个人的实际收入。 通货膨胀率(inflation rate):物价水平变动的百分比。(物价指数)用消费者价格指数(consumer price index, CPI)或GDP缩减指数(GDP deflator index)衡量。 失业率(unemployment rate):经济体中没有工作当正在积极找工作的劳动力比重。 GDP：衡量经济活动创造的价值经济体在既定时期内生产的所有的最终产品和服务的当期市场总值 核算GDP三种方法 生产法把GDP作为经济体里当期所生产的最终产品与服务的总值 收入法把GDP作为经济体中所有人的总收入国内顾客的购买总值=企业的总收益=工资+资本所得+中间投入品的购买最终消费=增加值=工资+资本所得(in China)增加值=劳动者报酬+生产税净额+固定资产折旧+营业盈额 支出法把GDP作为经济体里对产品与服务的总支出Y=C+I+G(GDP、消费、投资、政府购买)开放经济条件下Y=Cd+Id+Gd+EX(国内产品和服务的消费、国内产品和服务的投资、国内产品和服务的政府采购、国内产品和服务的出口)国外产品和服务的消费Cf=C-Cd国外产品和服务的投资If=I-Id国外产品和服务的政府采购Gf=G-Gd国外产品和服务的进口IM=Cf+If+Gf净出口(net export)NEX=EX-IM国民经济核算表达式Y=C+I+G+NEX 国民生产总值(gross national product,GNP)一国居民在一个既定时期内所获得的总收入GNP=GDP+来自国外的生产要素收入-对国外的生产要素支付 物价水平：衡量生活费用通货膨胀：物价水平上升 消费者价格指数(CPI)最常用的度量物价水平的指标 选定一个开始时期(基期) 选定一个典型消费者所购买的一篮子产品和服务的种类和数量 计算每一期购买同样一篮子产品和服务的支出 计算每一期的CPI(CPI=当期与基期一篮子产品和服务支出的比值) 通货膨胀率 = (CPI(后一期)-CPI(前一期))/CPI(前一期) 生产者价格指数(producer price index, PPI)度量物价水平的另一指标 典型生产者购买的一篮子产品和服务 GDP缩减指数 名义GDP(nominal GDP)：按照当期价格度量的GDP实际GDP(real GDP)：按照不变价格度量的GDP(尽可能反映经济体生产能力的变化) GDP缩减指数=名义GDP/实际GDP * 100% 名义GDP剔除通货膨胀的影响得到实际GDP 失业率：度量经济体痛苦程度就业：在一定年龄段的经济活动主体从事有报酬的活动 失业者：有劳动能力并愿意就业但找不到工作的经济活动主体 劳动力人口 = 劳动年龄(16~65)人口 - 不在劳动力(not in labor force)人口 劳动参与率 = 劳动力人口 / 劳动年龄人口 失业率 = 失业人口 / 劳动力人口 测算失业人口两种方法 收集失业者在劳动行政部门申报的数据大多数失业者有申报动机：失业申报可以领取失业救济金、获得再就业信息等 定期抽样调查估计失业人口 数据查找 中国国家统计局网站 http://www.stats.gov.cn 中国经济学教育科研网 http://www.cenet.org.cn/cn/ 美国 总统经济报告 www.access.gpo.gov/eop/ 美国统计概要 www.census.gov/compendia/statab 经济合作与发展组织 www.oecd.org 宾夕法尼亚大学国际比较中心 http://pwt.econ.upenn.edu/ 哈佛商学院宏观经济学资源网站 www.hbs.edu/units/bgie/internet","categories":[],"tags":[{"name":"宏观经济学","slug":"宏观经济学","permalink":"https://chenfeng.github.io/tags/宏观经济学/"}]},{"title":"现代经济中的市场和政府","slug":"economics/现代经济中的市场和政府","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:51:22.818Z","comments":true,"path":"2017/01/21/economics/现代经济中的市场和政府/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/economics/现代经济中的市场和政府/","excerpt":"什么是市场 市场(market)是买者和卖者相互作用并共同决定商品和劳务的价格和交易数量的机制","text":"什么是市场 市场(market)是买者和卖者相互作用并共同决定商品和劳务的价格和交易数量的机制 在市场中，是价格在协调生产者和消费者的决策。较高的价格趋于抑制消费者购买，同时会刺激生产；而较低的价格则鼓励消费，同时抑制生产。价格(price)在市场机制中起着平衡的作用 市场不断地解决生产什么、如何生产和为谁生产的问题，当平衡了所有影响经济的力量时，市场就达到了供给和需求的市场均衡(market equilibrium of supply and demand)。 市场均衡代表了所有不同的买者和卖者之间的一种平衡。在某一价格水平上，买者所愿意购买的数量正好等于卖者所愿意出售的数量，这一价格就达成了供给和需求的均衡。 市场如何解决三大经济问题 生产什么商品和劳务取决于消费者的货币选票——每天的购买决策。企业会受到利润(profit，净收益，等于总销售额和总成本之间的差额)最大化愿望的驱使。 如何生产取决于不同生产者之间的竞争。生产者的最佳方法是采用效率最高的生产技术以将成本降到最低点。 为谁生产主要取决于生产要素市场上的供给与需求。要素市场决定了工资、地租、利息和利润的水平(要素价格)。收入在消费者之间的分配取决于他们所拥有的要素的数量和价格。 经济的核心控制者是偏好和技术。消费者根据自己先天或后天的偏好(并以其货币选票加以表达)解决社会资源的最终用途，即在生产可能性边界上的各个点之间作决定。 可供利用的资源和技术对消费者的选择构成了一种基本的约束，经济不能超越于它的生产可能性边界。经济资源与可供利用的科学技术加在一起，限定了消费者花钱消费的对象 追逐个人利益的结果，是经常地增进社会的利益，其效果要比真的想要增进社会的利益时更好。(“看不见的手”在引导)(亚当·斯密《国富论》) 在一定条件下，完全竞争经济是有效率的(经济效率指的是无法在不损害其他人经济福利的前提下增进某个人的经济福利) 市场不灵的一种情况是垄断以及其他形式的不完全竞争。 第二种不灵表现为市场的外溢效果或外部性：正面的外部性包括科学发现等，而负面的外溢效果应包括环境污染。 市场的收入分配的后果在政治上或道义上时无法接受的。 贸易、货币和资本 发达经济以细密的贸易网络(基于大量的专业化和精细的劳动分工)为特征 当今的经济都大量使用货币(支付手段) 现代工业技术依赖于大规模的资本运用: 精密的机器、大型的工厂和库存 贸易、专业化和劳动分工 专业化是指让个人或国家各自集中精力去完成某一种(或一系列)任务，使得每个人或国家都能够发挥其特殊技能和资源优势 发达经济致力于专业化和劳动分工，因而能提高其资源的生产率。个人和国家用自己专业化生产的物品自愿地交换其他人的产品，能极大地增加消费品的范围和数量，并提高每个人的生活水平。 货币(money)是一种支付手段或交换媒介，即购物时所支付的现金和支票。 货币是供应适度是各国宏观经济政策的主要任务之一。 资本(capital)，一种被生产出来的要素，一种本身就是由经济过程产出的耐用的投入品 三大生产要素：资本、土地和劳动。 基本生产要素：土地和劳动，其供给主要取决于非经济要素。 资本使用之前必须首先被生产出来。资本在本质上意味着时间的耗费和间接的生产手段。 靠牺牲当前消费而获得的增长 许多经济活动都涉及到放弃现时消费以增加资本，提高经济未来的生产率，进而增加未来的消费 资本和私有财产 在市场经济中资本主要归私人拥有，从投资中得到的收益也归个人所有 产权赋予资本使用者使用、交换、装修、挖掘、钻探等利用其资本品的权利 个人占有资本并能从中获取利润，是资本主义的实质之所在 最有价值的经济资源，即劳动，不能像私人财产那样成为可以买卖的商品。人不能自由地卖出自己，只能在某个工资价位上将自己租借出去 政府的经济职能 现实世界中还不曾有一种经济能够完全依照“看不见的手”的原则而顺利地运行 政府对市场经济主要行使三项职能：提高效率、增进公平以及促进宏观经济的稳定与增长 政府通过促进竞争、控制诸如污染这类外部性问题，以及提供公共品等活动来提高经济效率 政府通过财政税收和预算支出等手段，向某些团体进行有倾斜的收入再分配，从而增进公平 政府通过财政政策和货币政策促进宏观经济的稳定和增长，在鼓励经济增长的同时减少失业和降低通货膨胀 效率 只有在完全竞争成立时，市场机制的优点才能充分体现出来 完全竞争(perfect competition)指的是所有的物品和劳务都有一个价格并都在市场上交易。意味着没有一家企业或一位消费者足以影响整个市场的价格 不完全竞争(imperfect competition)，当买者或卖者能够左右一种商品的价格时；社会的产出将会从生产可能性边界上移至边界之内，物品的产出就会低于有效率的水平。 不完全竞争导致价格高于成本，消费者购买量低于效率水平。过高的价格和过低的产出是伴随不完全竞争而来的非效率的标志 不完全竞争的极端情况是垄断，唯一的卖者独自决定某种物品或劳务的价格水平 外部性(溢出效应) 外部性(externalities)指的是企业或个人向市场之外的其他人所强加的成本或效益 一个行动可能在市场交易之外有助于或有损于其他人的利益，也即存在着根本不发生经济支付的经济交易 负的外部性已逐渐由微小的麻烦变成巨大的威胁，是政府进行干预的地方。 公共品 正外部性的极端情况是公共品 公共品(public goods)指一类商品：将该商品的效用扩展与他人的成本为零(非相克性)；无法排除他人参与共享(非相斥性)。 税收：政府对个人和公司的收入、工资、消费品销售额和其他项目所征收的税款。政府的收入来源，以提供公共品和实施收入再分配计划 公平 市场并不必然能够带来公平的收入分配。市场经济可能会产生令人难以接受的收入水平和消费水平的巨大差异 收入取决于一系列因素，包括努力程度、教育、继承权、要素价格和运气；由此导致的收入分配可能会同公平的结果相悖 物品追随的是货币选票而不是最大满足 累进税 转移支付，帮助根本没有收入的人 宏观经济增长与稳定 资本主义自产生以来不时地受通货膨胀(价格上升)和萧条(高失业率)的周期性困扰。这些波动被称为商业周期。 通过审慎地运用财政和货币政策，政府能够影响产出、就业和通货膨胀的水平 政府的财政政策是税收权力和预算支出权力 货币政策涉及到货币供应量和利率水平， 进而影响到资本品的投资和其他利率敏感性的支出(影响利率和信贷条件)","categories":[],"tags":[{"name":"微观经济学","slug":"微观经济学","permalink":"https://chenfeng.github.io/tags/微观经济学/"}]},{"title":"经济学基础知识","slug":"economics/经济学基础知识","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:49:51.899Z","comments":true,"path":"2017/01/21/economics/经济学基础知识/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/economics/经济学基础知识/","excerpt":"研究一个社会如何利用稀缺资源生产有价值的物品和劳务并将它们在不同人中间进行分配。 物品和资源是稀缺的 社会必须有效地加以利用 稀缺(sarcity)：相对于需求，物品总是有限的 效率(efficiency)：最有效地使用社会资源以满足人类的愿望和需要","text":"研究一个社会如何利用稀缺资源生产有价值的物品和劳务并将它们在不同人中间进行分配。 物品和资源是稀缺的 社会必须有效地加以利用 稀缺(sarcity)：相对于需求，物品总是有限的 效率(efficiency)：最有效地使用社会资源以满足人类的愿望和需要 经济学逻辑 后此谬误(the post hoc fallacy)仅仅因为一件事发生在另一件事之前就想当然地认为前者是后者的原因 不能保持其他条件不变(failure to hold other things constant)考虑某一问题是没能保持其他相关条件不变 合成谬误(the fallacy of composition)认为对局部成立的东西对总体也必然成立 经济组织三个经济问题基本经济问题： 生产什么(什么商品和多少)； 如何生产； 为谁生产(谁享用经济活动的成果) 实证经济学(positive economics)：讨论经济社会的事实规范经济学(normative economics)：提出价值判断，涉及伦理信条(应当是什么) 市场经济(market economy):主要由个人和私人企业决定生产和消费的经济制度 极端情况：自由放任(lasse-faire)经济 指令经济(command economy):由政府做出有关生产和分配的所有重大决策 政府通过它的资源所有权和实施经济政策的权力解答基本的经济问题 混合经济(mixed economy):既带有市场经济的成分又带有指令经济的成分 社会的技术可能性 投入和产出投入(inputs):指生产物品和劳务的过程中所使用的物品和劳务 产出(outputs):指生产过程中创造的各种有用的物品和劳务，可用于消费或进一步生产 投入也称生产要素(factors of production)，划分成三大基本范畴 土地(自然资源)，生产过程中大自然所赋予的 劳动，人们花费在生产过程中的时间和精力 资本资源，一个经济体为了生产其他的物品而生产出来的耐用品 生产可能性边界(production-possibility frontier, PPF)表示在技术知识和可投入品数量既定的条件下，一个经济体所能得到的最大产量。 PPF代表可供社会利用的物品和劳务的不同组合。 生产可能性边界说明许多基本的经济过程： 经济增长将边界向外推移(生产潜能的增长) 贫穷的国家必须将其大部分资源用于生产食品；富裕的国家能生产出更多奢侈品 贫穷的国家仅仅能承担很少的公共品；随着经济增长公共品及环境质量占产出量的比重势必加大 通过牺牲现在消费和生产更多的资本品，一国经济能更快速增长使未来有可能生产出更多两种物品 机会成本(opportunity cost)在存在稀缺的社会上，选择一种东西意味着需要放弃其他一些东西；一项选择的机会成本是相应的所放弃的物品和劳务的价值。 效率 有效率的生产(productive efficiency)必然位于生产可能性边界上；经济体无法在不减少一种物品产量的前提下生产出更多的另一种产品。 生产可能性边界表示社会为人们提供的各种选择 未利用资源和无效率 经济体中存在着未利用的资源(失业的劳动者、闲置的工厂、废弃的土地等)时，不可能处于生产可能性边界上，而是处于其边界之内的某个位置。 无资源的根源：商业周期(周期性经济危机)、罢工、政治动乱、革命等。","categories":[],"tags":[{"name":"微观经济学","slug":"微观经济学","permalink":"https://chenfeng.github.io/tags/微观经济学/"}]},{"title":"句柄类(handle)","slug":"Cplusplus_thinking/句柄类(handle)","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:47:41.789Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/句柄类(handle)/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/句柄类(handle)/","excerpt":"创建代理会复制所代理的对象，如何避免复制(保持多态性的前提下避免复制对象的代价) 某些类应当避免复制： 对象很大，资源消耗多 每个对象代表一种不能被轻易复制的资源，如文件 其它数据结构已经存储对象的地址，把副本地址插入那些数据结构中代价会非常大 对象代表位于网络连接另一端的其他对象 多态性环境中只知对象基类类型而不知对象本身类型","text":"创建代理会复制所代理的对象，如何避免复制(保持多态性的前提下避免复制对象的代价) 某些类应当避免复制： 对象很大，资源消耗多 每个对象代表一种不能被轻易复制的资源，如文件 其它数据结构已经存储对象的地址，把副本地址插入那些数据结构中代价会非常大 对象代表位于网络连接另一端的其他对象 多态性环境中只知对象基类类型而不知对象本身类型 避免使用指针复制对象： 使用对象指针比直接使用对象要困难 未初始化的指针非常危险且难以防范 管理内存的硬件总要检查被复制的指针是否真的指向程序所分配的内存位置上 复制未初始化指的针会导致硬件陷阱例如: 123456void f() &#123; // copy a pointer without initialization // would crash a program int* p; // without initialization int* q = p; // not being definited&#125; 多个指针指向同一个对象时应考虑何时删除此对象 handle classe(句柄类) 有时也称为smart pointer(智能指针) 绑定到所控制的类的对象上 简单示例类表示点平面坐标的类123456789class Point &#123;public: Point(): xval(0), yval(0) &#123;&#125; Point(int x, int y): xval(x), yval(y) &#123;&#125; int x() const &#123; return xval; &#125; int y() const &#123; return yval; &#125; Point&amp; x(int xv) &#123; xval = xv; return *this; &#125; Point&amp; y(int yv) &#123; yval = yv; return *this; &#125;&#125;; 使用一个无参构造函数和一个两个参数的构造函数而非一个缺省参数的构造函数Point(int x = 0, int y = 0): xval(x), yval(y) {}后者允许只用一个参数(另一个缺省为零)构造Point对象，而这几乎是错的 绑定到句柄将句柄h直接绑定到对象上Point p;Handle h(p); 删除p后应该使handle无效 handle应该控制它所绑定的对象(创建和销毁) 从效果上说handle就是一种只包含单个对象的容器 获取对象 handle行为上类似一个指针 应阻止使用者直接获得对象的实际地址 过多暴露内存分配策略，不利于改变分配的策略 隐蔽真正的对象地址，避免直接重载 operator-&gt;1234567class Handle &#123;public: Point* operator-&gt;(); // ...&#125;;Point* addr = h.operator-&gt;(); // get the object address // overloading operator-&gt; is to blame 引用计数型句柄(UPoint) 了解有多少句柄绑定在同一个对象上以确定何时删除对象 引用计数(use count)不能是句柄的一部分或对象的一部分 定义新的类容纳引用计数和Point对象 12345678910class UPoint &#123; // all the members are private friend class Handle; Point p; int u; UPoint(): u(1) &#123;&#125; UPoint(int x, int y): P(x, y), u(1) &#123;&#125; UPoint(const Point&amp; p0): p(p0), u(1) &#123;&#125;&#125;; 一个简单的Handle类实现 123456789101112131415161718192021222324252627282930313233343536373839404142class Handle &#123;public: Handle(); Handle(int, int); Handle(const Point&amp;); Handle(const Handle&amp;); Handle&amp; operator=(const Handle&amp;); ~Handle(); int x() const; int y() const; Handle&amp; x(int); Handle&amp; y(int);private: Upoint * up;&#125;;Handle::Handle(): up(new UPoint) &#123;&#125;Handle::Handle(int x, int y): up(new UPoint(x, y)) &#123;&#125;Handle::Handle(const Point&amp; p): up(new UPoint(p)) &#123;&#125;Handle::~Handle() &#123; if (--up-&gt;u == 0) delete up;&#125;// just increase the use count by 1Handle::Handle(const Handle&amp; h): up(h.up) &#123; ++up-&gt;up; &#125;// make sure it works when two handles use the same UPoint objectHandle&amp; Handle::operator=(const Handle&amp; h) &#123; ++h.up-&gt;u; if (--up-&gt;u == 0) delete up; up = h.up; return *this;&#125;int Handle::x() const &#123; return up-&gt;p.x(); &#125;int Handle::y() const &#123; return up-&gt;p.y(); &#125; 写时复制(copy on write)handle改动性函数两种不同语义Handle h(3, 4);Handle h2 = h;h2.x(5);int n = h.x(); // 3 or 5 ? 句柄为指针语义，n = 5 handle表现像指针或引用，h和h2绑定到同一对象 12345678Handle&amp; Handle::x(int x0) &#123; up-&gt;p.x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; up-&gt;p.y(y0); return *this;&#125; 句柄为值语义，n = 3 改变h2的内容不该影响h的值 必须保证所改动的UPont对象不同时被其它Handle所引用，否则复制UPoint12345678910111213141516Handle&amp; Handle::x(int x0) &#123; if (up-&gt;u != 1) &#123; --up-&gt;u; up = new UPoint(up-&gt;p); &#125; up-&gt;p.x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; if (up-&gt;u != 1) &#123; --up-&gt;u; up = new UPoint(up-&gt;p); &#125; up-&gt;p.y(y0); return *this;&#125; if (up-&gt;u != 1) {--up-&gt;u;up = new UPoint(up-&gt;p);} 此代码片段需要在每个改变UPoint对象的成员函数中重复(可设计为Handle的私有成员函数) 写时复制优点：在绝对必要时才进行复制，额外开销小 句柄类的改进 前述实现的缺点：把句柄捆绑到类T的对象上必须先定义具有类型T的成员的新类 当捆绑句柄到继承自T的静态类型未知的类的对象上时难以实现 将应用计数从数据中分离出来作为独立的对象 抽象地表示应用计数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UseCount &#123;public: UseCount(); UseCount(const UseCount&amp;); ~UseCount(); // judge whether use count would become zero bool only(); // judge whether use count should be deleted bool reattach(const UseCount&amp;); // provide a method to make this handle to be the only one bool makeonly();private: int* p; // make assignment illegal UseCount&amp; operator=(const UseCount&amp;);&#125;;UseCount::UseCount(): p(new int(1)) &#123;&#125;UseCount::UseCount(const UseCount&amp; u): p(u.p) &#123; ++*p; &#125;UseCount::~UseCount() &#123; if (--*p == 0) delete p;&#125;bool UseCount::only() &#123; return *p == 1; &#125;bool UseCount::reattach(const UseCount&amp; u) &#123; // increase u.p first to make it work when self-assignment ++*u.p; if (--*p == 0) &#123; delete p; p = u.p; return true; &#125; p = u.p; return false;&#125;bool UseCount::makeonly() &#123; if (*p == 1) return false; --*p; p = new int(1); return true;&#125; 重写Handle类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Handle &#123;public: // the same with previous definition Handle(); Handle(int, int); Handle(const Point&amp;); Handle(const Handle&amp;); Handle&amp; operator=(const Handle&amp;); ~Handle(); int x() const; int y() const; Handle&amp; x(int); Handle&amp; y(int);private: Point* p; UseCount u;&#125;;Handle::Handle(): p(new Point) &#123;&#125;Handle::Handle(int x, int y): p(new Point(x, y)) &#123;&#125;Handle::Handle(const Point&amp; p0): p(new Point(p0)) &#123;&#125;Handle::Handle(const Handle&amp; h): u(h.u), p(h.p) &#123;&#125;Handle::~Handle() &#123; if (u.only()) delete p;&#125;Handle&amp; Handle::operator=(const Handle&amp; h) &#123; if (u.reattach(h.u)) delete p; p = h.p; return *this;&#125;int Handle::x() const () &#123; return p-&gt;x();&#125;int Handle::y() const () &#123; return p-&gt;y();&#125;Handle&amp; Handle::x(int x0) &#123; if (u.makeonly()) p = new Point(*P); p-&gt;x(x0); return *this;&#125;Handle&amp; Handle::y(int y0) &#123; if (u.makeonly()) p = new Point(*P); p-&gt;y(y0); return *this;&#125; 总结 通过引入引用计数使得handle类能灵活地设计出来，而将引用计数抽象化表示使handle类能协同不同数据结构工作 UseCount类简化了实现中特定的子问题：接口设计只为简化引用计算句柄实现，而不为终端用户(end user)所用","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"模板（一）","slug":"Cplusplus_thinking/模板（一）","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:48:36.204Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/模板（一）/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/模板（一）/","excerpt":"容器类设计容器：保存值的集合的数据结构 语言内建容器：数组、结构体 C++没有提供更多的内建容器：不将容器的设计限定到某种单一的方法上(可能不存在唯一正确的方法) 容器包含对象 复制容器意味复制存储在容器中的值(而不是容器本身) 函数传参数方式 void f(const Container&amp;)避免大对象的复制 区分读和写 operator[]只用于取数 用成员函数update(i, x)修改索引为i的元素为x","text":"容器类设计容器：保存值的集合的数据结构 语言内建容器：数组、结构体 C++没有提供更多的内建容器：不将容器的设计限定到某种单一的方法上(可能不存在唯一正确的方法) 容器包含对象 复制容器意味复制存储在容器中的值(而不是容器本身) 函数传参数方式 void f(const Container&amp;)避免大对象的复制 区分读和写 operator[]只用于取数 用成员函数update(i, x)修改索引为i的元素为x 1234567891011121314151617template &lt;class T&gt; class Container &#123; // ...public: T operator[](Index) const; void update(Index, const T&amp;); // ...&#125;;Container&lt; Container&lt;int&gt; &gt;c;Index i, j;int k = c[i][j];// only way to modify the element in Container// c[i][j]void update(Index, const T&amp;);void update(Index, Index, const T&amp;);// hard to deal with much more dimension// c[i] return type T instead of T&amp;// c[i].update(j, new_value) does not work 获取容器的元素严格分清类型T(作右值)和类型T&amp;(作左值) 容器增长：按区块(chunk)增加容器大小的分配策略 容器操作容器数组：必须有缺省构造函数“顺序地”遍历容器中所有元素：先给元素强制规定顺序(解决方案：迭代器(iterator)) 容器元素的类型 类型为T的元素可以进行行为正确的复制、赋值和销毁T::T(const T&amp;) 可以判定两个元素是否相等operator==(const T&amp;, cosnt T&amp;) 为增加性能，有关于偏序关系或全序关系的定义(如set)operator&lt;(const T&amp;, const T&amp;) 考虑是否重载operator&lt;&lt;(ostream&amp;, const Container&amp;)兼顾不使用标准输入输出操作库或不用输入输出操作的用户，提供遍历整个容器的机制 容器不可通过继承关联起来1234567// if Container&lt;Airplane&gt; is derived from Container&lt;Vehicle&gt;Vehicle v;Container&lt;Airplane&gt; ca;Container&lt;Vehicle&gt;&amp; vp = ca;vp.insert(v);// that does not make any sence Demo : an array-like class 使用指针和使用下标的差别 12345678910111213// by indexint i;for (i = 0; i &lt; N; ++i) f(x[i]);// by pointerT* p;for (p = x; p &lt; x + N; ++p) f(*p);// a simplified versionT* p;while (p &lt; x + N) f(*p++); 区别： 下标值本身就有意义，与是否用作下标无关：通过下标进行元素访问的程序要另外知道正在使用的数组(才能访问整个数组) 要访问容器的元素没必要知道容器的标识，指针本身就包含所有的必要信息：程序只要拥有拥有一个指向数组元素的指针就能访问整个数组 这些影响设计，比”下标易于理解，指针效率高”的区别更为重要 禁止(数组)复制和赋值 使用operator[]存取元素 关于扩展：定长 缺省构造函数：可以创建包含数组的数组 123456789101112131415161718192021222324252627282930313233template&lt;class T&gt;class Array &#123;public: Array(): data(0), sz(0) &#123;&#125; Array(unsigned size): sz(size), data(new T(size)) &#123;&#125; ~Array() &#123; delete [] data; &#125; const T&amp; operator[](unsigned n) const &#123; if (n &gt;= sz || data == 0) throw \"Array subscript out of range\"; return data[n]; &#125; T&amp; operator[](unsigned n) &#123; if (n &gt;= sz || data == 0) throw \"Array subscript out of range\"; return data[n]; &#125; operator const T*() const &#123; return data; &#125; operator T*() &#123; return data; &#125;private: T* data; unsigned sz; Array(const Array* a); Array&amp; operator=(const Array&amp;);&#125;; 缺陷 (也存在于内建数组中)包含元素的Array消失后，它的元素地址还在 12345678void f() &#123; int *p; &#123; Array&lt;int&gt; x(20); p = &amp;x[10]; &#125; cout &lt;&lt; *p; // no exist&#125; 允许用户访问它的元素地址，透露太多内部运作的信息，违背了封装理念 允许Array被构造后改变长度会导致旧指针失效","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"模板（三）","slug":"Cplusplus_thinking/模板（三）","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:48:11.979Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/模板（三）/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/模板（三）/","excerpt":"迭代器 已经定义Array、Pointer和Ptr_to_const使得能部分确保安全性避免使用指针 进一步取代指针，需实现加法、减法和关系运算符 ‘’’C++void f() { int a[10]; int pa = a; int end = pa + 10; while (pa != end) *pa++ = 0;}‘’’ 基类及派生类都要定义这些操作","text":"迭代器 已经定义Array、Pointer和Ptr_to_const使得能部分确保安全性避免使用指针 进一步取代指针，需实现加法、减法和关系运算符 ‘’’C++void f() { int a[10]; int pa = a; int end = pa + 10; while (pa != end) *pa++ = 0;}‘’’ 基类及派生类都要定义这些操作 ‘’’C++template class Pointer: public Ptr_to_const {public: Pointer&amp; operator++() { ++sub; return *this; } Pointer&amp; operator--() { --sub; return *this; } Pointer&amp; operator++(int) { Pointer ret = *this; ++sub; return ret; } Pointer&amp; operator--(int) { Pointer ret = *this; --sub; return ret; } Pointer&amp; operator+=(int n) { sub += n; return *this; } Pointer&amp; operator-=(int n) { sub -= n; return *this; } // ... }; template Pointer operator+(const Pointer&amp; p, int n) { Pointer ret = p; return ret += n;} template Pointer operator+(int n, const Pointer&amp; p) { Pointer ret = p; return ret += n;} // subtration is similar‘’’ 两个指针当且仅当指向同一个Array的同一个元素(或都不指向任何Array)时才相等 ‘’’C++template int operator==(const Ptr_to_const&amp; op1, cosnt Ptr_to_const&amp; op2) { if (op1.ap != op2.ap) return 0; return (op1.sub == op2.sub);} template int operator&lt;(const Ptr_to_const&amp; op1, const Ptr_to_const&amp; op2) { if (op1.ap != op2.ap) throw “&lt; on different Arrays”; return op1.sub &lt; op2.sub;}‘’’ 迭代器能在不暴露容器内部结构的情况下访问容器的元素 删除元素 当元素不存在时的处理方法 禁止从容器中删除单个元素(可以删除整个容器) 在每个容器对象中保存一个有效迭代器的列表，删除一个元素则正好删除刚好指向这个被删除元素的迭代器 对容器中每个元素采用引用计数，删除任何一个元素都必须等到最后一个指向该元素的引用都不存在 让迭代器指向容器中元素与元素之间的位置上(难以实现；影响先有代码) 删除容器 容器本身已不存在，还有活动的迭代器的解决方法 删除操作延后到最后一个迭代器失效 采用处理删除单个元素的思想 用户确保一旦容器删除就不再使用迭代器 只要有活动迭代器存在就禁止删除容器本身","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"模板（二）","slug":"Cplusplus_thinking/模板（二）","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:46:20.301Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/模板（二）/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/模板（二）/","excerpt":"访问容器中的元素保留Array和一个指向T的指针之间的密切关系要付出一定的代价 用户能够轻易得到一个指向Array内部的指针，即使Array本身不存在了，这个指针仍被保留 不得不暴露类的内部机制，一旦内存变化肯定导致用户错误；resize之类的扩展有诸多潜在错误 增加防止出错的中间层","text":"访问容器中的元素保留Array和一个指向T的指针之间的密切关系要付出一定的代价 用户能够轻易得到一个指向Array内部的指针，即使Array本身不存在了，这个指针仍被保留 不得不暴露类的内部机制，一旦内存变化肯定导致用户错误；resize之类的扩展有诸多潜在错误 增加防止出错的中间层 模拟指针1234567891011template &lt;class T&gt; class Pointer &#123;public： Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(&amp;a), sub(n) &#123;&#125; Pointer(): ap(0), sub(0) &#123;&#125; // Array&lt;T&gt; cann't be default: reference should bind a objectprivate: Array&lt;T&gt;* ap; unsigned sub; // ...&#125;; 复制一个Pointer之后，原Pointer和其副本都指向一个位置 获取元素 最直接的方法会面临上述问题： 12345678template &lt;class T&gt; class Pointer &#123;public: T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125;&#125;; 另一种解决方案会带来赋值不方便的新问题： 123456789101112template &lt;class T&gt; class Pointer &#123;public: T operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125;&#125;;// \"t = *p\" is allowed but \"*p = t\" is forbidden// the point is that it is hard to implement \"*p = t\"// while \"T* tp = &amp;*p\" is allowed 引进update操作 12345678910111213141516171819202122template &lt;class T&gt; class Pointer &#123;public： Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(&amp;a), sub(n) &#123;&#125; Pointer(): ap(0), sub(0) &#123;&#125; T operator*() const &#123; if (ap == 0) throw \"* of unbound Pointer\"; return (*ap)[sub]; &#125; void update(const T&amp; t) &#123; if (ap == 0) throw \"update of unbound Pointer\"; (*ap)[sub] = t; &#125;private: Array&lt;T&gt;* ap; unsigned sub; // ...&#125;; 相应地，Array类使用update操作，但会带来无法实现包含Array的Array的功能的问题 12345678910111213template &lt;class T&gt; class Array &#123;public: T operator[](unsigned n) const &#123; if (n &gt;= sz) throw \"Array suubscript out of range\"; return data[n]; &#125; void update(unsigned n, const T&amp; t) &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; data[n] = t; &#125;&#125;; 方便性和安全性之间的权衡问题 选择何种方法取决于类会被确切地怎样使用 遗留问题 如果Array不存在了还可能存在一个指向它的空悬Pointer “软件工程基本定理”(though it isn’t a real theory): 通过引进一个额外的中间层能够解决任何问题。’ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091template &lt;class T&gt; class Array_data &#123; friend class Array&lt;T&gt;; friend class Pointer&lt;T&gt;; Array_data(unsigned size = 0): data(new T[size]), sz(size), use(1) &#123;&#125; ~Array_data() &#123; delete [] data; &#125; const T&amp; operator[](unsigned n) const &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; return data[n]; &#125; T&amp; operator[](unsigned n) &#123; if (n &gt;= sz) throw \"Array subscript out of range\"; return data[n]; &#125; // no implement that copy is no allowed Array_data(const Array_data&amp;); Array_data&amp; operator=(const Array_data&amp;); T* data; unsigned sz; int use;&#125;;template &lt;class T&gt; class Array &#123; friend class Pointer&lt;T&gt;;public: Array(unsigned size): data(new Array_data&lt;T&gt;(size)) &#123;&#125; ~Array() &#123; if (--data-&gt;use == 0) delete data; &#125; const T&amp; operator[](unsigned n) const &#123; return (*data)[n]; &#125; T* operator[](unsigned n) &#123; return (*data)[n]; &#125;private: Array(const Array&amp;); Array&amp; operator=(const Array&amp;); Array_data&lt;T&gt;* data;&#125;;template &lt;class T&gt; class Poiter: public Ptr_to_const&lt;T&gt; &#123;public: Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): ap(a.data), sub(n) &#123; ++ap-&gt;use; &#125; Pointer(): ap(0), sub(0) &#123;&#125; Pointer(const Pointer&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123; if (ap) ++ap-&gt;use; &#125; ~Pointer() &#123; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; &#125; Pointer&amp; operator=(const Pointer&lt;T&gt;&amp; p) &#123; if (p.ap) ++p.ap-&gt;use; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; ap = p.ap; sub = p.sub; return *this; &#125; T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;private: Array_data&lt;T&gt;* ap; unsigned sub;&#125;;// the following code does workArray&lt;int&gt;* ap = new Array&lt;int&gt;(10);Pointer&lt;int&gt; p(*ap, 5);delete ap;*p = 42; 指向const Array的Pointer 还无法使Pointer指向const Array的元素 const Array的实际对象很少，但通过引用传递Array参数(const Array&amp;)时还是有用的 定义独立的类，提供类型转换操作符给这个类，通过继承获得两种类型间的相似性 类Pointer从Ptr_to_const继承而来，即使对象不是const类型也能把指针保存在Array_data中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template &lt;class T&gt; class Ptr_to_const &#123;public: // catch a argument const Array&lt;T&gt;&amp; instead of Array&lt;T&gt;&amp; Ptr_to_const(const Array&lt;T&gt;&amp; a, unsigned n = 0): ap(a.data), sub(n) &#123; ++ap-&gt;use; &#125; Ptr_to_const(): ap(0), sub(0) &#123;&#125; Ptr_to_const(const Ptr_to_const&lt;T&gt;&amp; p): ap(p.ap), sub(p.sub) &#123; if (ap) ++ap-&gt;use; &#125; ~Ptr_to_const() &#123; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; &#125; Ptr_to_const&amp; operator=(const Ptr_to_const&lt;T&gt;&amp; p) &#123; if (p.ap) ++p.ap-&gt;use; if (ap &amp;&amp; --ap-&gt;use == 0) delete ap; ap = p.ap; sub = p.sub; return *this; &#125; const T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;private: Array_data&lt;T&gt;* ap; unsigned sub;&#125;;// redefine class Pointer to keep something about constanttemplate &lt;class T&gt; class Poiter: public Ptr_to_const&lt;T&gt; &#123;public: Pointer(Array&lt;T&gt;&amp; a, unsigned n = 0): Ptr_to_const&lt;T&gt;(a, n) &#123;&#125; Pointer() &#123;&#125; T&amp; operator*() const &#123; if (ap == 0) throw \"* of unbound Ptr_to_const\"; return (*ap)[sub]; &#125;&#125;; 增强操作重新设置Array大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;class T&gt; class Array &#123;public: void resize(unsigned n) &#123; // Array_data do the real operation data-&gt;resize(n); &#125; //...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::resize(unsigned n) &#123; if (n == sz) return ; T* odata = data; data = new T[n]; copy(odata, sz &gt; n ? n : sz); delete [] odata; sz = n;&#125;template &lt;class T&gt;void Array_data&lt;T&gt;::copy(T* arr, unsigned n) &#123; for (int i = 0; i &lt; n; ++i) data[i] = arr[i];&#125;// another way of changing Array sizetemplate &lt;class T&gt; class Array &#123;public: void reverse(unsigned new_sz) &#123; if (new_sz &gt;= data-&gt;sz) data-&gt;grow(new_sz); &#125; //...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::grow(unsigned new_sz) &#123; unsigned nsz = sz; if (nsz == 0) nsz = 1; whiel (nsz &lt;= new_sz) nsz *= 2; resize(nsz);&#125; 实现对Array的复制和赋值使包含Array的Array有效 不允许对Array_data对象复制，故不定义operator=调用Array_data::operator= 1234567891011121314151617181920template &lt;class T&gt; class Array &#123;public: Array(const Array&amp; a): data(new Array_data&lt;T&gt;(a.data-&gt;sz)) &#123; data-&gt;copy(a.data-&gt;data, a.data-&gt;sz); &#125; Array&amp; operator=(const Array&amp; a) &#123; if (this != &amp;a) data-&gt;clone(*a.data, a.data-&gt;data); return *this; &#125; // ...&#125;;template &lt;class T&gt;void Array_data&lt;T&gt;::clone(const Array_data&amp; a, unsigned n) &#123; delete [] data; data = new T[sz = a.sz]; copy(a.data, sz);&#125; 尚未完全消除指针的需求","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"类设计者的核查表","slug":"Cplusplus_thinking/类设计者的核查表","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:45:07.437Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/类设计者的核查表/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/类设计者的核查表/","excerpt":"","text":"构造函数简单的类 结构就是接口 不需要构造函数 数据成员私有阻止类的使用者私自改动提供相应接口 供使用者执行修改或访问等操作 无参构造函数声明对象数组必需 初始化数据成员每个构造函数都要负责为所有的数据成员设置经过明确定义的值除非该数据成员在类的对象存在一定时间后才有意义或其它特殊情况 析构函数该类分配了不会被成员函数自动释放的资源（动态内存）时必需 虚析构函数(类B派生的子类D，若可能对D类型对象的B*指针执行delete表达式时必需)例如:123456789101112class B &#123; string s;&#125;;class D : public B &#123; string t; // virtual ~B() &#123;&#125;;&#125;;int main() &#123; B* bp = new D; // no problem delete bp; // unless B has a virtual destructor // or the wrong dstructor would be called&#125; 拷贝构造函数当复制类的对象并非复制其数据成员和基类对象时必需 若不想使用者能够复制类的对象，就声明复制构造函数(赋值操作符)为私有的 赋值操作符当赋值类的对象并非复制其数据成员和基类对象时必需 考虑赋值给对象本身的情况例如: 1234567891011121314class String &#123;public: string&amp; operator=(const String &amp;s);private: char *data;&#125;;String&amp; String::operator=(const String&amp; s) &#123; if (&amp;s != this) &#123; // do nothing with self-assignment delete [] data; // delete old array data = new char[strlen(s.data) + 1]; strcpy(data, s.data); &#125; return *this;&#125; 若不想使用者能够设置类中的对象，就将赋值操作符私有化 析构函数、拷贝构造函数、赋值操作符= 通常为同时必需的 关系操作符类逻辑上支持相等操作则提供 operator== 和 operator!=类具有某种排序关系则提供余下的关系操作符(&lt; &gt; &lt;= &gt;=) 拷贝构造函数和赋值操作符的参数类型加上constlike X::X(const X&amp;) X::operator=(const X&amp;) 函数的const引用参数除非函数用来改变参数的值否则应为const引用例如: Complex operator+(const Complex&amp; x, const Complex&amp; y); 适当声明成员函数为const成员函数不用修改它的对象时 const对象只能使用声明为const的函数 设计理念：C++不可能自动处理所有这些事情(难以保证做得对)始终加入的话增加太多的额外负担，开销过大如给所有类自动添加一个虚析构函数，当类较小时开销明显作为变通方法，让编译器指出什么时候类该有什么必需的","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"面向对象编程","slug":"Cplusplus_thinking/面向对象编程","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:45:56.989Z","comments":true,"path":"2017/01/21/Cplusplus_thinking/面向对象编程/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/Cplusplus_thinking/面向对象编程/","excerpt":"一个面向对象程序范例 面向对象对象编程三要素： 数据抽象 继承 动态绑定 适用于大型程序 以算术表达式树形表示的面向对象解决方案为例","text":"一个面向对象程序范例 面向对象对象编程三要素： 数据抽象 继承 动态绑定 适用于大型程序 以算术表达式树形表示的面向对象解决方案为例 创建和打印表达式 定义表达式树节点类每个节点可能有一到三个子节点，可用一个联合加上一个指示节点类型的专门字段表示节点 三种节点： 包含一个整数值，无子节点 包含一个操作符，一个子节点 包含一个操作符，两个子节点 当需要用到一个类型字段时可以考虑定义一系列类并用继承组织起来能否更有效 用一个类表示“节点”概念 12345678910111213class Expr_node &#123; // print the expression friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr_node&amp;);protected: virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Expr_node&amp; e) &#123; e.print(o); return o;&#125; 用继承声明具体类型 12345678910111213141516171819202122232425262728293031323334353637// save first node-typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr_node* opnd; Unary_node(const string&amp; a, Expr_node* b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; *opnd &lt;&lt; \")\"; &#125;&#125;;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr_node* left; Expr_node* right; Binary_node(const string&amp; a, Expr_node* b, Expr_node* c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; *left &lt;&lt; op &lt;&lt; *right &lt;&lt; \")\"; &#125;&#125;; 用句柄类管理指针避免使用者管理内存的麻烦使用者关心的只是树和子树而非单个节点，定义句柄类Expr隐藏Expr_node继承层次 12345678910111213141516171819202122232425class Expr &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int); Expr(const string&amp;, Expr); Expr(const string&amp;, Expr, Expr); Expr(const Expr&amp;); Expr&amp; operator=(const Expr&amp;); ~Expr() &#123; delete p; &#125;&#125;;Expr::Expr(int n) &#123; p = new Int_node(n);&#125;Expr::Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t);&#125;Expr::Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right);&#125; 改进 可在Expr_node派生层次加入虚函数copy 加入引用计数避免复制下层Expr_node会更有效率123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Expr_node &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); friend class Expr; // add a use count int use;protected: Expr_node(): use(1) &#123;&#125; virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125;&#125;;class Expr &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp;);&#125;;// assignment operator increase use count of the right objectExpr&amp; Expr::operator=(const Expr&amp; rhs) &#123; rhs.p-&gt;use++; if (--p-&gt;use == 0) delete p; p = rhs.p; return *this;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Expr&amp; t) &#123; t.p-&gt;print(o); return o;&#125;// save first typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr opnd; Unary_node(const string&amp; a, Expr b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; opnd &lt;&lt; \")\"; &#125;&#125;;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr right; Binary_node(const string&amp; a, Expr b, Expr c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; \")\"; &#125;&#125;; 扩展新操作：表达式求值方法和打印表达式相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Expr_node &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); friend class Expr; int use;protected: Expr_node(): use(1) &#123;&#125; virtual void print(ostream&amp;) const = 0; virtual ~Expr_node() &#123;&#125; // add a pure virtual function virtual int eval() const = 0;&#125;;class Expr &#123; friend class Expr_node; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp; t); // new function: calculate the evaluation int eval() const &#123; return p-&gt;eval(); &#125;&#125;;// save first typeclass Int_node: public Expr_node &#123; friend class Expr; int n; Int_node(int k): n(k) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; n &#125;; // new function int eval() const &#123; return n; &#125;&#125;;// svae second typeclass Unary_node: public Expr_node &#123; friend class Expr; string op; Expr opnd; Unary_node(const string&amp; a, Expr b): op(a), opnd(b) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; op &lt;&lt; opnd &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Unary_node::eval() const &#123; // only consider certain operands if (op == \"-\") return -opnd.eval(); throw \"error, bad op \" + op + \" int UnaryNode\";&#125;// save third typeclass Binary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr right; Binary_node(const string&amp; a, Expr b, Expr c): op(a), left(b), right(c) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; op &lt;&lt; right &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Binary_node::eval() const &#123; int op1 = left.eval(); int op2 = right.eval(); if (op == \"-\") return op1 - op2; if (op == \"+\") return op1 + op2; if (op == \"*\") return op1 * op2; if (op == \"/\" &amp;&amp; op2 != 0) return op1 / op2; throw \"error, bad op \" + op + \"in BinaryNode\";&#125; 类的抽象对算术表达式进行了精确建模 扩展程序以计算表达式所需要增加的代码较少 扩展增加新节点类型如增加Ternary_node表示三元操作符(?:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Ternary_node: public Expr_node &#123; friend class Expr; string op; Expr left; Expr middle; Expr right; Ternary_node(const string&amp; a, Expr b, Expr c, Expr d): op(a), left(b), middle(c), right(d) &#123;&#125; void print(ostream&amp; o) const &#123; o &lt;&lt; \"(\" &lt;&lt; left &lt;&lt; \" ? \" &lt;&lt; middle &lt;&lt; \" : \" &lt;&lt; right &lt;&lt; \")\"; &#125; // new function int eval() const;&#125;;int Ternary_node::eval() const &#123; if (left.eval()) return middle.eval(); else return right.eval();&#125;// add a constructor for Ternary_node in Exprclass Expr &#123; friend class Expr_node; friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Expr&amp;); Expr_node* p;public: Expr(int n) &#123; p = new Int_node(n); &#125; Expr(const string&amp; op, Expr t) &#123; p = new Unary_node(op, t); &#125; Expr(const string&amp; op, Expr left, Expr right) &#123; p = new Binary_node(op, left, right); &#125; Expr(const string* op, Expr left, Expr middle, Expr right) &#123; p = new Ternary_node(op, left, middle, right); &#125; Expr(const Expr&amp; t) &#123; p = t.p; ++p-&gt;use; &#125; ~Expr() &#123; if (--p-&gt;use == 0) delete p; &#125; Expr&amp; operator=(const Expr&amp; t); // new function: calculate the evaluation int eval() const &#123; return p-&gt;eval(); &#125;&#125;; 总结面向对象编程能简化程序的设计和更新过程 对下层系统中的对象进行建模 保证修改时耦合度低","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://chenfeng.github.io/tags/C/"}]},{"title":"宏观经济学鸟瞰","slug":"economics/宏观经济学鸟瞰","date":"2017-01-20T16:00:00.000Z","updated":"2017-03-25T03:50:30.299Z","comments":true,"path":"2017/01/21/economics/宏观经济学鸟瞰/","link":"","permalink":"https://chenfeng.github.io/2017/01/21/economics/宏观经济学鸟瞰/","excerpt":"研究对象：整体经济行为 个体行为的总体成果 不是研究特定部门或特定经济活动主体的行为 经济生活中的重大问题 基本研究方法：考察经济的总体趋势 收集不同时期、不同国家有关收入、通货膨胀和失业等变量的数据，尝试构建有助于理解这些数据的一般理论 发展历程","text":"研究对象：整体经济行为 个体行为的总体成果 不是研究特定部门或特定经济活动主体的行为 经济生活中的重大问题 基本研究方法：考察经济的总体趋势 收集不同时期、不同国家有关收入、通货膨胀和失业等变量的数据，尝试构建有助于理解这些数据的一般理论 发展历程 凯恩斯革命 系统收集、处理总量数据，为宏观经济学的研究提供科学基础 对经济波动的系统研究 始于1929年的“大萧条” 凯恩斯《就业、利息和货币通论》(General Theory of Employment, Interest and Money) 有效需求：总需求(aggregate demand) 构成现代宏观经济学的要素 乘数，解释需求冲击如何被放大以及如何导致产出更大的变化 流动性偏好，凯恩斯对货币需求的称谓，解释货币政策如何影响利率和有效需求 预期在影响消费和投资方面的重要性，动物精神，即预期的变化是造成需求和产出变化的主要因素 凯恩斯主义的发展 新古典综合(neoclassical synthesis)：整合凯恩斯思想和古典思想 IS-LM模型 用数学语言对凯恩斯的观点进行表述 预期没有起到任何作用 缺少对价格和工资的调整 消费理论：持久收入在消费决策中具有重要作用 投资理论 货币需求理论：基于流动性、投资报酬率和风险发展不同资产之间的选择理论 凯恩斯主义和货币主义(争论) 货币政策和财政政策(的效果) 凯恩斯强调，治理经济衰退中财政政策优于货币政策，IS曲线非常陡峭，推论货币政策作用不大 弗里德曼、施瓦茨考察货币史发现货币政策非常有效，可以解释大多数产出波动 IS曲线并没有想象的那样陡峭，财政政策和货币政策都会产生效果 菲利普斯曲线 失业和通胀之间存在可靠的交替关系 失业和通胀之间并不存在长期的交替关系：违背基本的经济规律 宏观经济管理模式(的作用) 凯恩斯主义：政府在宏观经济管理上要相机决策；经济学知识可用以稳定经济，政策制定者能够做正确的事情 弗里德曼质疑政府的良好初衷未必能可信地做正确的事情，建议政府在宏观经济管理上采取固定法则 理性预期批判 危机(20世纪70年代) 经济生活中发生石油危机 滞涨(stagflation): 高失业和高通胀同时存在 石油危机是一次不利的供给冲击 一部分经济学家开始从理论上质疑凯恩斯主义 凯恩斯主义经济学在石油危机中所表现出的漏洞：忽略预期影响经济活动主体行为的全面含义 解决办法：人们基于目前所有的信息理性地做出预期 凯恩斯主义经济学遭到严重破坏(经济活动主体是理性的，其预期也是理性的) 卢卡斯批判(Lucas Critique) 如果政策发生变化，人们会基于新的政策形成预期，其行为也会发生变化，从而导致原先的宏观经济(计量)模型可能会对在新政策下将要发生的事情做出糟糕的指导。 如20世纪70年代初期的菲利普斯曲线 理性预期与菲利普斯曲线 凯恩斯模型中，由于价格和工资将沿着菲利普斯曲线缓慢调整，产出是缓慢而不是迅速调整到潜在产出水平。 卢卡斯：供给和价格的调整很大程度上取决于工资制定者对通胀的预期方式，一旦我们假定工资制定是理性预期的，调整可能快得多 最优控制与博弈论 凯恩斯主义采用的(宏观经济政策)分析工具，最优控制等，忽视了宏观经济政策制定者与经济活动主体之间的互动 理性预期的第三个含义：如果经济活动主体是理性预期的，那么政策通常是政策制定者与经济活动主体之间的博弈 采用博弈论研究宏观经济政策 理性预期的整合(20世纪70年代和80年代) 消费随机游走假说(Random-Walk Model of Consumption) 理性预期引入到消费研究领域：如果消费者是理性预期的且非常有远见，那么对于下一年消费的最好预测就是今天的消费 消费的变化难以预测：消费者只有得知有关将来的新信息后才会改变消费行为，但将来的新信息是不可预测的 工资与价格的交错调整(staggered price adjustment) 工资和价格的调整过程不会出现突然的同步调整，而是交错调整，可能是缓慢的 即使经济活动主体是理性预期的，产出也是缓慢调整到其潜在产出水平的 政府有效需求管理的有效性并不依赖于理性预期的假定，而是依赖于市场瞬时出清的假定 政策理论 博弈不仅存在于政策制定者和经济活动主体之间，也存在与政策制定者(政党、央行和中央政府，或不同国家政府)之间 当前发展 新古典主义，新凯恩斯主义，新增长理论 实际商业周期理论(real business cycle, RBC)：经济体的产出通常处于其潜在水平，因此所有波动都是源于潜在产出水平自身的变动，而不是源于对潜在产出水平的偏离。 RBC强调经济波动的根源是技术进步 新凯恩斯主义(New Keynesians) 以最大化行为和理性预期为基础构建严密可信的工资、价格粘性模型 研究方向主要集中在劳动力市场的工资决定、信用市场的不完全以及名义刚性(nominal rigidities) 由于工资和价格决策的交错，产出会偏离潜在水平很长一段时间； 菜单成本理论(menu cost): 即使改变价格的成本很小也会导致交错的价格调整，产生名义价格刚性 新经济增长理论(new growth theory) 经济体增长速度取决于技术进步速度，决定技术进步的因素 规模报酬递增在增长中的作用，有效地分析框架 微观经济学经济学家如何思考 经济学家最基本的工具：数据、术语、思考问题的方式；利用这些工具构建模型(model)，用数学术语清晰地说明变量之间的关系。 外生变量(exogenous variables)：模型中给定的变量 内生变量(endogenous variables)：模型要解释的变量 模型界定外生变量如何影响内生变量 供求模型某种商品的竞争性市场，市场需求曲线单调下降，市场供给曲线单调上升，交点为市场均衡点。 内生变量：对应价格为均衡价格，对应商品数量为均衡交易数量 外生变量：消费习惯、原材料来源、技术水平、政治法律等的变化，市场规模或居民收入水平变化等 需求膨胀：需求方购买商品的愿望和能力增强，商品的需求量在每个价格水平上都有所增加；需求曲线向右平移，会导致市场均衡点上升，均衡价格和均衡交易量同时上升 需求收缩：需求方购买商品的愿望和能力减弱，商品的需求量在每个价格水平上都有所下降；需求曲线向左平移，会导致市场均衡点下降，均衡价格和均衡交易量同时下降 供给膨胀：供给方出售商品的愿望增强，商品的供给量在每个价格水平上都有所增加;供给曲线向右平移，市场均衡点下降，均衡价格下降，均衡交易量上升 供给收缩：供给方出售商品的愿望减弱，商品的供给量在每个价格水平上都有所减少；供给曲线向左平移，市场均衡点上升，均衡价格上升，均衡交易量下降 从微观到宏观宏观经济理论必须与微观经济活动主体的基本行为一致 试图在理论水平上理解单个家庭和企业的决策过程 试图通过加总经济体中微观主体的所有决定来解释整体经济行为 通过手机分析数据，实证检验宏观经济学模型是否与现实一致 基本假定一种产品或服务的价格可以迅速调整；市场可以自动走向供求均衡，市场迅速出清 现实中存在工资和价格缓慢调整的情况，价格黏性 价格并不总是黏性的，最终会随着供求的变动而变动；这一假定可以描述经济体的长期趋势 基本模型 总需求(aggregate demand, AD)：在货币政策、财政政策以及消费者信心不变的情况下，每给定一个价格水平，产品市场和货币市场同时处于均衡状态时的产量水平 总需求函数(aggregate demand function)：Y = D(P)，经济体中价格水平P，总需求量Y 总需求曲线(aggregate deamnd curve) 其它条件不变(ceteris paribus)：除价格水平之外其它与经济体的总需求相关的条件都保持不变 总供给(aggregate supply)：在经济体中，对于每一既定价格水平，厂商愿意提供的产量 总供给函数(aggregate supply function)：Y = S(P) 长期总供给曲线是垂直的。其它条件发生变化(技术进步等)，生产能力提高时总供给曲线向右平移 在短期，价格是黏性的，总供给曲线是水平线 通常情况下，短期总供给曲线是向右上方倾斜","categories":[],"tags":[{"name":"宏观经济学","slug":"宏观经济学","permalink":"https://chenfeng.github.io/tags/宏观经济学/"}]}]