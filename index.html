<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="chenxfeng's blog">
<meta property="og:url" content="https://chenfeng.github.io/index.html">
<meta property="og:site_name" content="chenxfeng's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chenxfeng's blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chenfeng.github.io/"/>





  <title> chenxfeng's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chenxfeng's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/06/Cplusplus_thinking/模板之迭代器配接器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/Cplusplus_thinking/模板之迭代器配接器/" itemprop="url">
                  模板之迭代器配接器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-06T00:00:00+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>迭代器配接器(iterator adaptor): 把迭代器作为参数并转换为其他迭代器的模板</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>一个泛型函数: 找出第一次出现某个值的位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class X&gt;</div><div class="line">T find(T start, T beyond, const X&amp; x) &#123;</div><div class="line">    while (start != beyond &amp;&amp; *start != x)</div><div class="line">        ++*start;</div><div class="line">    return start;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>普通指针可以充当输入迭代器</p>
</li>
<li><p>找出最后一个与某个特定值相等的实例</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class X&gt;</div><div class="line">T find(T start, T beyond, const X&amp; x) &#123;</div><div class="line">    T result = beyond;</div><div class="line">    while (start != beyond) &#123;</div><div class="line">        if (*start == x) </div><div class="line">            result = start;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>T是输入迭代器，只能这样实现</li>
<li><p>缺陷: 总是需要查找数据结构中的所有元素，即使要查找的值就在尾部</p>
</li>
<li><p>采用双向迭代器: 可以使用—操作符</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class X&gt;</div><div class="line">T rfind(T start, T beyond, const X&amp; x) &#123;</div><div class="line">    if (start != beyond) &#123;</div><div class="line">        T p = beyond;</div><div class="line">        do &#123;</div><div class="line">            if (*--p == x) return p;</div><div class="line">        &#125; while (p != start)</div><div class="line">    &#125;</div><div class="line">    return beyond;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="方向不对称性"><a href="#方向不对称性" class="headerlink" title="方向不对称性"></a>方向不对称性</h3><ul>
<li><p>反转某个算法的方向时并不能总是精确地保持原有的对称性</p>
</li>
<li><ul>
<li>Cpp语言定义的迭代器的特性: 通常迭代器确保逾尾值有效但对超出头部的值没有相应的保障</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (int* p = a; p &lt; a + 10; ++p)</div><div class="line">    *p = 0;</div></pre></td></tr></table></figure>
<ul>
<li>循环结束时p等于a+10</li>
<li><ul>
<li>C/Cpp语言保证(且只保证)能够定位任何超出数组尾部之后的那一个元素的地址</li>
</ul>
</li>
<li><ul>
<li>a+10是合法的，a+11是非法的，a-1是非法的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 无效的代码</div><div class="line">for (int* p = a+9; p &gt;= a; p--)</div><div class="line">    *p = 0;</div><div class="line"></div><div class="line">// 有效的代码</div><div class="line">int* p = a + 10;</div><div class="line">while (p &gt; a)</div><div class="line">    *--p = 0;</div></pre></td></tr></table></figure>
<h3 id="一致性和不对称性"><a href="#一致性和不对称性" class="headerlink" title="一致性和不对称性"></a>一致性和不对称性</h3><ul>
<li>后向查找不到时返回超出头部的指针</li>
<li><p>每个迭代器指向数据结构中正要查找的元素的后面的位置</p>
</li>
<li><p>rnfind(reverse neighbor find): </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class X&gt;</div><div class="line">T rnfind(T start, T beyond, const X&amp; x) &#123;</div><div class="line">    while (beyond != start &amp;&amp; beyond[-1] != x)</div><div class="line">        --beyond;</div><div class="line">    return beyond;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>beyond[-1] : *(beyond-1)</li>
<li><ul>
<li>T必须是一个随机存取迭代器而不仅仅是双向迭代器</li>
</ul>
</li>
</ul>
<h3 id="自动反向"><a href="#自动反向" class="headerlink" title="自动反向"></a>自动反向</h3><ul>
<li>新类型TR(T reverse): 将T转换为TR，指向T所指向的元素的前一个元素</li>
<li>迭代器适配器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template &lt;class It, class T&gt;</div><div class="line">class Rev &#123;</div><div class="line">    friend bool operator==(const Rev&lt;It, T&gt;, const Rev&lt;It, T&gt;);</div><div class="line">    friend bool operator!=(const Rev&lt;It, T&gt;, const Rev&lt;It, T&gt;);</div><div class="line"></div><div class="line">public:</div><div class="line">    Rev();</div><div class="line">    Rev(It i);</div><div class="line">    operator It();</div><div class="line">    Rev&lt;It, T&gt;&amp; operator++();</div><div class="line">    Rev&lt;It, T&gt;&amp; operator--();</div><div class="line">    Rev&lt;It, T&gt;&amp; operator++(int);</div><div class="line">    Rev&lt;It, T&gt;&amp; operator--(int);</div><div class="line">    T&amp; operator*();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>解引用操作实际发生在私有数据成员所指向元素的前一个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">template &lt;class It, class T&gt;</div><div class="line">class Rev &#123;</div><div class="line">    friend bool operator==(const Rev&lt;It, T&gt;, const Rev&lt;It, T&gt;);</div><div class="line">    friend bool operator!=(const Rev&lt;It, T&gt;, const Rev&lt;It, T&gt;);</div><div class="line"></div><div class="line">public:</div><div class="line">    Rev() &#123; &#125;</div><div class="line">    Rev(It i): it(i) &#123; &#125;</div><div class="line">    operator It() &#123;</div><div class="line">        return it;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Rev&lt;It, T&gt;&amp; operator++() &#123;</div><div class="line">        --it;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">    Rev&lt;It, T&gt;&amp; operator--() &#123;</div><div class="line">        ++it;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Rev&lt;It, T&gt;&amp; operator++(int) &#123;</div><div class="line">        Rev&lt;It, T&gt; r = *this;</div><div class="line">        --it;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">    Rev&lt;It, T&gt;&amp; operator--(int) &#123;</div><div class="line">        Rev&lt;It, T&gt; r = *this;</div><div class="line">        ++it;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    T&amp; operator*() &#123;</div><div class="line">        It i = it;</div><div class="line">        --i;</div><div class="line">        return *i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    It it;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;class It, class T&gt;</div><div class="line">bool operator==(const Rev&lt;It, T&gt;&amp; x, const Rev&lt;It, T&gt;&amp; y) &#123;</div><div class="line">    return x.it == y.it;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template &lt;class It, class T&gt;</div><div class="line">bool operator!=(const Rev&lt;It, T&gt;&amp; x, const Rev&lt;It, T&gt;&amp; y) &#123;</div><div class="line">    return x.it != y.it;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以通过与迭代器相关联的容器，将一个双向迭代器由前向遍历迭代器转变为后向遍历迭代器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef Rev&lt;int*, int&gt; R</div><div class="line"></div><div class="line">int* p = find(x, x+100, 42);</div><div class="line">R r = find(R(x+100), R(x), 42);</div></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li><p>取决于描述数据结构的双向迭代器的可用性</p>
</li>
<li><p>编写进行接口适配的模板</p>
</li>
<li><p>STL的更通用的模板: reverse_bidirectional_iterator</p>
</li>
<li><p>随机存取迭代器: 可以使用reverse_iterator</p>
</li>
<li><p>迭代器配接器的其他应用</p>
</li>
<li><ul>
<li>边界检查配接器</li>
</ul>
</li>
<li><ul>
<li>被生成的迭代器类型可以将源迭代器的值限定在由创建该类型的对象时确定的一对边界中</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/05/Cplusplus_thinking/模板之使用泛型迭代器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/Cplusplus_thinking/模板之使用泛型迭代器/" itemprop="url">
                  模板之泛型迭代器的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>一个小程序，使用不同类型迭代器做不同的事</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 复制顺序的数据结构</div><div class="line">template &lt;class In, class Out&gt;</div><div class="line">Out copy(In start, In end, Out dest) &#123;</div><div class="line">    while (start != end)</div><div class="line">        *dest++ = *start++;</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    char* hello = &quot;Hello &quot;;</div><div class="line">    char* world = &quot;world&quot;;</div><div class="line">    char message[15];</div><div class="line">    char* p = message;</div><div class="line"></div><div class="line">    p = copy(hello, hello + 6, p);</div><div class="line">    p = copy(world, world + 5, p);</div><div class="line">    *p = &apos;\0&apos;;</div><div class="line"></div><div class="line">    cout &lt;&lt; message &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><ul>
<li>模板参数类型In和Out分别作为输入迭代器和输出迭代器</li>
<li>支持相等(==/!=)比较和++自增操作符(前置/后置)</li>
<li><p>作为函数的参数被传递、返回、保存在数据结构中等</p>
</li>
<li><p>区别在于各自如何访问迭代器所代表的数据</p>
</li>
<li><ul>
<li>通过一元操作符*支持间接引用</li>
</ul>
</li>
<li><ul>
<li>输入迭代器只需要能读取一个值</li>
</ul>
</li>
<li><ul>
<li>输出迭代器只需要能够赋值</li>
</ul>
</li>
<li><ul>
<li><code>*out = *in</code>必须按照预想工作，<code>*in = *out</code>则不必</li>
</ul>
</li>
<li><p>输出迭代器表示定位时都必须给迭代器赋一个值，且只能赋一次</p>
</li>
<li><p>输入迭代器增加到超过某个特定的输入值，那么这个值将再也不能被访问</p>
</li>
</ul>
<h3 id="虚拟序列"><a href="#虚拟序列" class="headerlink" title="虚拟序列"></a>虚拟序列</h3><ul>
<li><p>创建一个用来读取相同常量值序列的输入迭代器</p>
</li>
<li><p>设置数组的元素为某个特定值(把x的元素都设成0):</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int x[100];</div><div class="line">Constant_iterator c(0);</div><div class="line"></div><div class="line">copy(c, c + 100, x);</div></pre></td></tr></table></figure>
<ul>
<li>c的行为类似指向一个无界“数组”的“指针”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Constant_iterator &#123;</div><div class="line">public:</div><div class="line">    Constant_iterator(int k=0);</div><div class="line">    int operator*() const;</div><div class="line">    Constant_iterator&amp; operator++();</div><div class="line">    Constant_iterator operator++(int);</div><div class="line"></div><div class="line">private:</div><div class="line">    int n;</div><div class="line">    int count;</div><div class="line">    friend int operator==(const Constant_iterator&amp;, const Constant_iterator&amp;);</div><div class="line">    friend int operator!=(const Constant_iterator&amp;, const Constant_iterator&amp;);</div><div class="line">    friend Constant_iterator operator+(const Constant_iterator&amp;, int);</div><div class="line">    friend Constant_iterator operator+(int, const Constant_iterator&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>缺省拷贝构造函数和赋值操作符</p>
</li>
<li><p>成员count跟踪产生的值的数量，比较操作符可以判断何时到达“序列”尾部</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Constant_iterator::Constant_iterator(int k=0): n(k) &#123; &#125;</div><div class="line"></div><div class="line">int Constant_iterator::operator*() const &#123;</div><div class="line">    return n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>构造函数记住迭代器生成的值，解引用(dereference)操作符返回这个值</p>
</li>
<li><p>自增操作符递增遍历过的值的数目的计数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Constant_iterator&amp; Constant_iterator::operator++() &#123;</div><div class="line">    ++count;</div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Constant_iterator Constant_iterator::operator++(int) &#123;</div><div class="line">    Constant_iterator r = *this;</div><div class="line">    ++count;</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>+操作会把int对象增加增加到计数中，类似“哨岗”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Constant_iterator operator+(const Constant_iterator&amp; p, int n) &#123;</div><div class="line">    Constant_iterator r = p;</div><div class="line">    r.count += n;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Constant_iterator operator+(int n, const Constant_iterator&amp; p) &#123;</div><div class="line">    return p + n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当且仅当两个迭代器生成相同数量的值并且这些值都相等时这两个迭代器才相等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int operator==(const Constant_iterator&amp; p, const Constant_iterator&amp; q) &#123;</div><div class="line">    return p.count == q.count &amp;&amp; p.n == q.n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int operator!=(const Constant_iterator&amp; p, const Constant_iterator&amp; q) &#123;</div><div class="line">    return !(p == q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>创建了一个迭代器，表示包含相等值的“虚拟数组”(实际上并不存在)</p>
</li>
<li><p>可以创建类似的起点和步长固定的迭代器</p>
</li>
</ul>
<h3 id="输出流迭代器"><a href="#输出流迭代器" class="headerlink" title="输出流迭代器"></a>输出流迭代器</h3><ul>
<li><p>定义一个可以把值打印出来的输出迭代器(类ostream_iterator的一个对象)</p>
</li>
<li><p><code>ostream_iterator&lt;int&gt; out(cout)</code></p>
</li>
<li><ul>
<li><code>*out++ = x;</code> 打印x到cout上</li>
</ul>
</li>
<li><p>ostream_iterator类设计构造函数设计为接受两个参数: ostream对象和const char*对象</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class ostream_iterator &#123;</div><div class="line">public:</div><div class="line">    ostream_iterator(ostream&amp; os, const char* s): strm(&amp;os), str(s) &#123; &#125;</div><div class="line"></div><div class="line">    ostream_iterator&amp; operator++() &#123;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">    ostream_iterator&amp; operator++(int) &#123;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">    ostream_iterator&amp; operator*() &#123;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">    ostream_iterator&amp; operator=(const T&amp; t) &#123;</div><div class="line">        *strm &lt;&lt; t &lt;&lt; str;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    ostream* strm;</div><div class="line">    const char* str;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>用例: 将42重复10次打印到标准输出上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    ostream_iterator&lt;int&gt; oi(cout, &quot; \n&quot;);</div><div class="line">    Constant_iterator c(42);</div><div class="line"></div><div class="line">    copy(c, c + 10, oi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="输入流迭代器"><a href="#输入流迭代器" class="headerlink" title="输入流迭代器"></a>输入流迭代器</h3><ul>
<li><p>创建一个从某个istream中取值的输入迭代器</p>
</li>
<li><ul>
<li>输入迭代器必须实现比较操作以判断是否到达文件尾部</li>
</ul>
</li>
<li><ul>
<li>进行尝试性地读取才能判断是否已经到达文件尾部，而读取值很耗费系统资源</li>
</ul>
</li>
<li><p>“惰性读取”策略</p>
</li>
<li><ul>
<li>每个istream_iterator对象有一个只能容纳一个元素的缓冲区和一个表明缓冲区是否已满的标志</li>
</ul>
</li>
<li><ul>
<li>另一个标志说明是否到达文件尾部</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class istream_iterator &#123;</div><div class="line">private:</div><div class="line">    T buffer;</div><div class="line">    istream* strm;</div><div class="line">    int full;</div><div class="line">    int eof;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>当且仅当buffer内有一个有用值时full为true</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class istream_iterator &#123;</div><div class="line">public:</div><div class="line">    istream_iterator(istream&amp; is): strm(&amp;is), full(0), eof(0) &#123; &#125;</div><div class="line">    istream_iterator(): strm(0), full(0), eof(1) &#123; &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>可以使用缺省的复制操作</li>
<li>自增操作符: 确保一旦迭代器遍历过一个值之后不会再读取这个值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class istream_iterator &#123;</div><div class="line">public:</div><div class="line">    istream_iterator&amp; operator++() &#123;</div><div class="line">        full = 0;</div><div class="line">        return *this;</div><div class="line">    &#125;</div><div class="line">    istream_iterator operator++(int) &#123;</div><div class="line">        istream_iterator r = *this;</div><div class="line">        full = 0;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>必须预读以便判断是否到达文件尾部</p>
</li>
<li><p>惰性计算策略，首先检查是否需要输入，若需要则读取数据并适当地设置状态</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class istream_iterator &#123;</div><div class="line">private:</div><div class="line">    void fill() &#123;</div><div class="line">        if (!full &amp;&amp; !eof) &#123;</div><div class="line">            if (*strm &gt;&gt; buffer)</div><div class="line">                full = 1;</div><div class="line">            else </div><div class="line">                eof = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">    T operator*() &#123;</div><div class="line">        fill();</div><div class="line">        assert(full);</div><div class="line">        return buffer;</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>只有当两个istream_iterator是同一个对象或者两者都处于文件尾部时才相等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">int operator==(istream_iterator&lt;T&gt;&amp; p, istream_iterator&lt;T&gt;&amp; q) &#123;</div><div class="line">    if (p.eof &amp;&amp; q.eof) return 1;</div><div class="line">    if (!p.eof &amp;&amp; !q.eof) return &amp;p == &amp;q;</div><div class="line">    p.fill();</div><div class="line">    q.fill();</div><div class="line">    return p.eof == q.eof;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template &lt;class T&gt;</div><div class="line">int operator!=(istream_iterator&lt;T&gt;&amp; p, istream_iterator&lt;T&gt;&amp; q) &#123;</div><div class="line">    return !(p == q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将一个输入文件复制值到一个输出文件中去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    ostream_iterator&lt;int&gt; output(cout, &quot; \n&quot;);</div><div class="line">    istream_iterator&lt;int&gt; input(cin);</div><div class="line">    istream_iterator&lt;int&gt; eof;</div><div class="line"></div><div class="line">    copy(input, eof, output);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li>看上去像指针的结构，容易被设想成仅仅是一个指针</li>
<li><p>深入研究某个算法使用到的指针操作会发现可以针对其他的数据结构模拟指针</p>
</li>
<li><p>istream_iterator和ostream_iterator类标准模板库的组成部分</p>
</li>
<li><ul>
<li>而Constan_iterator不是(Why capital)</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/05/Cplusplus_thinking/模板之泛型迭代器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/Cplusplus_thinking/模板之泛型迭代器/" itemprop="url">
                  模板之泛型迭代器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>了解另外的算法，分析各自对相应模板参数类型强加的行为</li>
</ul>
<h3 id="一个不同的算法"><a href="#一个不同的算法" class="headerlink" title="一个不同的算法"></a>一个不同的算法</h3><ul>
<li>颠倒一个序列中的所有元素的顺序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 不是很正确</div><div class="line">template &lt;class P, class T&gt;</div><div class="line">void reverse(P start, P beyond) &#123;</div><div class="line">    while (start &lt; beyond) &#123;</div><div class="line">        T t = *start;</div><div class="line">        --beyond;</div><div class="line">        *start = *beyond;</div><div class="line">        *beyond = t;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>需要定义++p、p!=beyond和*p</li>
<li><p>需要定义p&lt;beyond和—p，并且确保*p是一个左值</p>
</li>
<li><p>比较难以保证: p &lt; beyond</p>
</li>
<li><ul>
<li>判断两个值是否相等和判断两者的先后次序之间存在很大的差别</li>
</ul>
</li>
<li><ul>
<li>例如放在一个单向链表之中</li>
</ul>
</li>
<li><p>用 p != beyond 替换 p &lt; beyond</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template &lt;class P, class T&gt;</div><div class="line">void reverse2(P start, P beyond) &#123;</div><div class="line">    while (start != beyond) &#123;</div><div class="line">        --beyond;</div><div class="line">        if (start != beyond) &#123;</div><div class="line">            T t = *start;</div><div class="line">            *start = *beyond;</div><div class="line">            *beyond = t;</div><div class="line">            ++start;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>用两个(不)等于检查替换了一个次序检查</li>
<li><ul>
<li>输入有效的前提下，start与beyond不会擦肩而过</li>
</ul>
</li>
<li><p>双重检查消耗资源，但所耗不多，且使得该算法能在更多种类的数据结构中使用</p>
</li>
<li><p>考虑对类型P的递减操作要求 </p>
</li>
<li>两种方法不用递减(辅助存储区、开销大)</li>
<li><ul>
<li>分配一个辅助的T数组，把数据复制到这个数组中，按逆序复制回去</li>
</ul>
</li>
<li><ul>
<li>分配一个辅助的P数组</li>
</ul>
</li>
</ul>
<h3 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h3><ul>
<li>针对不同算法，可行的数据结构面临的问题不同</li>
<li><ul>
<li>在一个不同向后读取(逆向读取)的顺序文件中找出一条特定的记录，支持operator—的要求显得过于苛刻</li>
</ul>
</li>
<li><p>不能对不同目标使用同一套需求</p>
</li>
<li><p>必须对需求进行适当的分类: 找出一套能很好的适合某个算法集的需求以及另一套适合另一个算法集的需求</p>
</li>
</ul>
<h3 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h3><ul>
<li>一个对象希望完全模拟指向序列的指针，能够使用p取出序列元素，使p指向序列下一个元素，能够判断是否到达最后一个元素</li>
<li><ul>
<li>需要*p、++P、p!=q</li>
</ul>
</li>
<li><ul>
<li>p++、p==q</li>
</ul>
</li>
<li><ul>
<li>复制p</li>
</ul>
</li>
<li><p>满足这些需求的类型允许按照某个预先规定的顺序读(<strong>但不是写</strong>)序列中的元素</p>
</li>
<li><ul>
<li><strong>输入迭代器(input iterator)</strong>: 一类迭代器</li>
</ul>
</li>
</ul>
<h3 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h3><ul>
<li><p>可以读取一个序列，能够对该序列进行读写操作</p>
</li>
<li><p>输出迭代器</p>
</li>
<li><p>输入迭代器和输出迭代器之间的唯一区别在*p的行为</p>
</li>
<li><ul>
<li>输入迭代器可以读取但不一定允许修改</li>
</ul>
</li>
<li><ul>
<li>输出迭代器允许改变但不一定允许读取(p在改变前定位的存储空间可能包括一个不能被合法复制的无效值)</li>
</ul>
</li>
<li><p>使用输入和输出迭代器可以写出泛型复制函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">template &lt;class In, class Out&gt;</div><div class="line">void copy(In start, In beyond, Out result) &#123;</div><div class="line">    while (start != beyond) &#123;</div><div class="line">        *result = *start;</div><div class="line">        ++result;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>精简版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template &lt;class In, class Out&gt;</div><div class="line">void copy(In start, In beyond, Out result) &#123;</div><div class="line">    while (start != beyond)</div><div class="line">        *result++ = *start++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="前向迭代器"><a href="#前向迭代器" class="headerlink" title="前向迭代器"></a>前向迭代器</h3><ul>
<li><p>能够遍历序列的元素，以某种方式改变每个元素，一旦接触某个元素之后就再也不能访问这个元素</p>
</li>
<li><p>将输入迭代器和输出迭代器的操作结合在一起的迭代器</p>
</li>
<li><p>前向迭代器(forward iterator)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class Iter, class Function&gt;</div><div class="line">void apply(Iter start, Iter beyond, Function f) &#123;</div><div class="line">    while (start != beyond) &#123;</div><div class="line">        *start = f(*start);</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用*start进行读取和写入: 前向迭代器</li>
<li>类型Function: 可以使任何能够像函数一样运行的对象的类型</li>
<li><ul>
<li>函数对象: 重载了函数调用操作符operator()</li>
</ul>
</li>
</ul>
<h3 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h3><ul>
<li>支持operator—</li>
</ul>
<h3 id="随机存取迭代器"><a href="#随机存取迭代器" class="headerlink" title="随机存取迭代器"></a>随机存取迭代器</h3><ul>
<li>p指向序列第一个元素，到达第1000个元素的方式</li>
<li><ul>
<li>执行1000次++p？</li>
</ul>
</li>
<li><ul>
<li>p += 1000</li>
</ul>
</li>
<li><ul>
<li>p指向数组元素或者行为类似于指向链表元素的指针的类</li>
</ul>
</li>
<li><ul>
<li>可能简单方便而效率极差</li>
</ul>
</li>
<li><p>有些算法必须能够高效访问数据结构的任何元素，如折半查找</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">template &lt;class P, class X&gt;</div><div class="line">P binsearch(P start, P beyond, X x) &#123;</div><div class="line">    P low = start, high = beyond;</div><div class="line"></div><div class="line">    while (low != high) &#123;</div><div class="line">        P mid = low + (high - low) / 2;</div><div class="line">        if (x == *mid)</div><div class="line">            return mid;</div><div class="line">        if (x &lt; *mid)</div><div class="line">            high = mid;</div><div class="line">        else</div><div class="line">            low = mid + 1;</div><div class="line">    &#125;</div><div class="line">    return beyond;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>关键是能够快速计算指向某个序列中间元素的指针</p>
</li>
<li><p>随机访问迭代器增加了操作：+、-、+=、-=和[]</p>
</li>
</ul>
<h3 id="是否用继承关联"><a href="#是否用继承关联" class="headerlink" title="是否用继承关联"></a>是否用继承关联</h3><ul>
<li>前向迭代器能作为输入迭代器或者输出迭代器工作</li>
<li>双向迭代器能像前向迭代器、输入迭代器和输出迭代器一样工作</li>
<li><p>随机访问迭代器可以像任何其他的迭代器一样工作</p>
</li>
<li><p>但是迭代器不属于继承这种关联类型的范畴</p>
</li>
<li><ul>
<li>一系列类型应该满足或者不应该满足的需求的集合</li>
</ul>
</li>
<li><p>继承增加了更多地需求</p>
</li>
<li><ul>
<li>一个特殊的基类</li>
</ul>
</li>
<li><ul>
<li>迭代器必须是类而不是內建类型(不能把指针当作迭代器使用了)</li>
</ul>
</li>
<li><p>概念继承(conceptual inheritance): 构建C++库的概念框架的一部分</p>
</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>效率是使用C++的原因之一</li>
<li>STL赋予迭代器 强的性能要求: 特定类型的迭代器要支持的每种操作都要快(分摊执行时间必须是O(1))</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>泛型算法: 对于所操作数的数据结构的细节信息只加入最低限度的了解</p>
<ul>
<li>将用来访问数据结构的类型分类</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/04/Cplusplus_thinking/模板之抽象接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Cplusplus_thinking/模板之抽象接口/" itemprop="url">
                  模板之抽象接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-04T00:00:00+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前面探讨了模板的经典用途: 建立容器类</p>
</blockquote>
<ul>
<li>描述一个或一组程序的接口的通用方式</li>
<li>使用模板提供抽象接口，可以写出独立于任何一种实际类型的函数</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>系统的在概念上具有不同特性的部分能谨慎地分隔开，有利于(代码)复用</li>
</ul>
<h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><ul>
<li>一个将整数数组元素相加的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int sum(int * p, int n) &#123;</div><div class="line">    int result = 0;</div><div class="line">    for (int i = 0; i &lt; n; i++)</div><div class="line">        result += p[i];</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用这个函数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    int x[10];</div><div class="line">    for (int i = 0; i &lt; 10; i++) </div><div class="line">        x[i] = i;</div><div class="line">    cout &lt;&lt; sum(x, 10) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sum函数知道三件事: </p>
<ol>
<li><p>它把一组数加在一起</p>
</li>
<li><p>它所加的数是整数</p>
</li>
<li><p>它所加的整数以一种特殊的方式存储了起来</p>
</li>
</ol>
<blockquote>
<p>划分这个程序使把每一个特征分离到不同的部分中</p>
</blockquote>
<h3 id="分离迭代方式"><a href="#分离迭代方式" class="headerlink" title="分离迭代方式"></a>分离迭代方式</h3><ul>
<li><p>函数的一个依赖: 添加的元素是放在数组中</p>
</li>
<li><p>用类抽象这种依赖: 迭代器</p>
</li>
<li><ul>
<li>一个构造函数用来创建要处理的数据</li>
</ul>
</li>
<li><ul>
<li>请求序列中下一个元素的方法</li>
</ul>
</li>
<li><ul>
<li>告知遍历元素何时完成的方法</li>
</ul>
</li>
<li><ul>
<li>赋值操作符、复制构造函数、析构函数，使对象可以当作值使用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Int_iterator &#123;</div><div class="line">public:</div><div class="line">    Int_iterator(int*, int);  // 第一个元素的地址、元素数量</div><div class="line">    ~Int_iterator();</div><div class="line"></div><div class="line">    int valid() const;</div><div class="line">    int next();</div><div class="line"></div><div class="line">    Int_iterator(const Int_iterator&amp;);</div><div class="line">    Int_iterator&amp; operator=(const Int_iterator&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>改写sum函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int sum(Int_iterator ir) &#123;</div><div class="line">    int result = 0;</div><div class="line">    while (ir.valid())</div><div class="line">        result += ir.next()</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>不需要再<strong>直接</strong>知道正在添加的元素是如何保存的: 封装在Int_iterator中</p>
</li>
<li><p>使用新的函数: </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    int x[10];</div><div class="line">    for (int i = 0; i &lt; 10; i++) </div><div class="line">        x[i] = i;</div><div class="line">    cout &lt;&lt; sum(Int_iterator(x, 10)) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现未泛型化的迭代器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Int_iterator &#123;</div><div class="line">public:</div><div class="line">    Int_iterator(int* p, int c): data(p), len(c) &#123; &#125;</div><div class="line"></div><div class="line">    int valid() const &#123;</div><div class="line">        return len &gt; 0;</div><div class="line">    &#125;</div><div class="line">    int next() &#123;</div><div class="line">        --len;</div><div class="line">        return *data++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    int* data;</div><div class="line">    int len;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="遍历任意类型"><a href="#遍历任意类型" class="headerlink" title="遍历任意类型"></a>遍历任意类型</h3><ul>
<li>通用的Iterator模板</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">class Iterator &#123;</div><div class="line">public:</div><div class="line">    Iterator(T* p, int c): data(p), len(c) &#123; &#125;</div><div class="line"></div><div class="line">    int valid() const &#123;</div><div class="line">        return len &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    T next() &#123;</div><div class="line">        --len;</div><div class="line">        return *data++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    T* data;</div><div class="line">    int len;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>typedef Iterator&lt;int&gt; Int_iterator</code>使Int_iterator类型等价于Iterator<int></int></li>
</ul>
<h3 id="增加其他类型"><a href="#增加其他类型" class="headerlink" title="增加其他类型"></a>增加其他类型</h3><ul>
<li><p>求出任意类型的值的和</p>
</li>
<li><p>将sum函数做成模板</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T sum(Iterator&lt;T&gt; ir) &#123;</div><div class="line">    T result = 0;</div><div class="line">    while (ir.valid())</div><div class="line">        result += ir.next();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>类型T满足: </li>
<li><ul>
<li>可以把0转换成该类的对象</li>
</ul>
</li>
<li><ul>
<li>对该类的对象定义类</li>
</ul>
</li>
<li><ul>
<li>对象具有类似值的语义，sum函数可以把对象作为值返回</li>
</ul>
</li>
</ul>
<h3 id="存储技术抽象化"><a href="#存储技术抽象化" class="headerlink" title="存储技术抽象化"></a>存储技术抽象化</h3><ul>
<li><p>该迭代器只能访问存储在数组中的值</p>
</li>
<li><p>值可以保存在链表、文件中</p>
</li>
<li><p>需要反映不同数据结构的不同迭代器</p>
</li>
<li><p>把Iterator类转变成一个抽象基类，可以表示许多不同类型的迭代器类中的任何一个</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class Iterator &#123;</div><div class="line">public:</div><div class="line">    virtual int valid() const = 0;</div><div class="line">    virtual T next() const = 0;</div><div class="line">    virtual ~Iterator() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Array_iterator<t>就是一种Iterator<t>: </t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class Array_iterator : public Iterator&lt;T&gt; &#123;</div><div class="line">public:</div><div class="line">    Array_iterator(T* p, int c): data(p), len(c) &#123;&#125;</div><div class="line"></div><div class="line">    int valid() const &#123;</div><div class="line">        return len &gt; 0;</div><div class="line">    &#125;</div><div class="line">    T next() &#123;</div><div class="line">        --len;</div><div class="line">        return *data++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    T* data;</div><div class="line">    int len;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>sum函数接受指向Iterator的引用作为参数以允许动态绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T sum(Iterator&lt;T&gt;&amp; ir) &#123;</div><div class="line">    T result = 0;</div><div class="line">    while (ir.valid())</div><div class="line">        result += ir.next();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用sum时将迭代器传给它</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    int x[10];</div><div class="line">    for (int i = 0; i &lt; 10; i++)</div><div class="line">        x[i] = i;</div><div class="line">    Array_iterator&lt;int&gt; it(x, 10);</div><div class="line">    cout &lt;&lt; sum(it) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不能使用如下的调用方式: </li>
<li><ul>
<li><code>cout &lt;&lt; sum(Array_iterator&lt;int&gt;(x, 10)) &lt;&lt; endl</code></li>
</ul>
</li>
<li><ul>
<li>子表达式<code>Array_iterator&lt;int&gt;(x, 10)</code>不是左值，没有绑定其上的非const引用</li>
</ul>
</li>
<li><p><strong>每次遍历sum函数中的内部循环时都需要调用虚函数: 动态绑定(开销较大，尤其对象复杂时)</strong></p>
</li>
<li><ul>
<li>可以取消动态绑定减少额外开销，但需要在编译时知道相加元素类型</li>
</ul>
</li>
</ul>
<p><em>另一种实现方式(不采用继承)</em></p>
<ul>
<li>让sum函数有两种类型的参数: 迭代器类型以及被加对象的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template &lt;class Iter, class T&gt;</div><div class="line">T sum(Iter it) &#123;/*...*/&#125;</div></pre></td></tr></table></figure>
<ul>
<li>并不奏效: 定义了一个返回类型与参数无关的函数</li>
<li><ul>
<li>sum(x)的类型独立于x的类型(可能在C++中非法)</li>
</ul>
</li>
<li><ul>
<li>需要检查大量上下文条件才有办法判断表达式的类型</li>
</ul>
</li>
<li><p>solution: 定义sum接收一个对求和结果的引用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class Iter&gt;</div><div class="line">void sum2(T&amp; result, Iter it) &#123;</div><div class="line">    result = 0;</div><div class="line">    while (ir.valid()) </div><div class="line">        result += ir.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>重写main程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    int x[10];</div><div class="line">    for (int i = 0; i &lt; 10; ++i)</div><div class="line">        x[i] = i;</div><div class="line">    int r;</div><div class="line">    sum2(r, Iterator&lt;int&gt;(x, 10));</div><div class="line">    cout &lt;&lt; r &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以通过保留sum接口使得原来的主程序可以运行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T sum(T* p, int n) &#123;</div><div class="line">    T r = 0;</div><div class="line">    sum2(r, Iterator&lt;T&gt;(p, n));</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    int x[10];</div><div class="line">    for (int i = 0; i &lt; 10; ++i)</div><div class="line">        x[i] = i;</div><div class="line">    cout &lt;&lt; sum(x, 10) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实证"><a href="#实证" class="headerlink" title="实证"></a>实证</h3><ul>
<li><p>利用sum2对一个从istream中生成的、数量不限的数字集合求和</p>
</li>
<li><p>可以当做迭代器的类: Reader</p>
</li>
<li><ul>
<li>Reader<t>对象从一个istream中读取一个T值的序列</t></li>
</ul>
</li>
<li><p>必须在读取数据前检查istream中是否还有数据存在</p>
</li>
<li><ul>
<li>从istream中读取数据看读取是否有效</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class Reader &#123;</div><div class="line">public:</div><div class="line">    Reader(istream&amp; is): i(is) &#123; advance(); &#125;</div><div class="line">    int valid() const &#123;</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line">    T next() &#123;</div><div class="line">        T result = data;</div><div class="line">        advance();</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    istream&amp; i;</div><div class="line">    int status;</div><div class="line">    T data;</div><div class="line">    void advance() &#123;</div><div class="line">        i &gt;&gt; data;</div><div class="line">        status = i != 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>每个Reader对象绑定一个给予构造函数的istream的引用</li>
<li><ul>
<li><code>Reader&lt;double&gt;(cin)</code>是一个从cin中取回double值的Reader对象</li>
</ul>
</li>
<li><p>从输入中读取的数字相加</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    cout &lt;&lt; &quot;Enter numbers: &quot; &lt;&lt; endl;</div><div class="line">    double r = 0;</div><div class="line">    sum2(r, Reader&lt;double&gt;(cin));</div><div class="line">    cout &lt;&lt; r &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li>任何一个大规模系统的关键在于将它划分成可以独立处理的小模块</li>
<li><ul>
<li>在小模块之间定义清晰的接口</li>
</ul>
</li>
<li><p>学生注册系统: </p>
</li>
<li><ul>
<li>窗口接口 + 数据库接口</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template &lt;class W, class DB&gt;</div><div class="line">class Registration &#123;</div><div class="line">public:</div><div class="line">    // 学生注册所需的任何操作</div><div class="line">&#125;；</div><div class="line"></div><div class="line">// 为正在使用的任何窗口和数据库系统实例化一个Registration对象</div><div class="line">int main() &#123;</div><div class="line">    Registration&lt;wizzy_window, dazzling_DB&gt; r;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只要wizzy_window满足窗口系统的规范，dazzling_DB满足数据库系统的规范</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/04/Cplusplus_thinking/模板和泛型算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Cplusplus_thinking/模板和泛型算法/" itemprop="url">
                  模板之抽象接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-04T00:00:00+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>1994年7月，安大略基奇纳召开的C++标准会议<br>通过Alex Stepanov提出的提议: 将他和他的同事们在Hewlett-Packard实验室开发<br>的一系列泛型算法作为一部分收录到标准C++库中<br>标准模板库(Standard Template Library, STL)</p>
</blockquote>
<ul>
<li><p>泛型算法: 一种以对它所作用的数据结构尽可能少的假设的方式表达的算法</p>
</li>
<li><p>模板使某种程度的泛型(genericity)更加容易</p>
</li>
<li><p>编写与所排序的值的类型无关的程序的一种典型方法</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">void sort(T* ptr, int size) &#123;</div><div class="line">    // ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>STL库中，某个程序表述的算法既能够使用多种数据结构有能获得高效的运行(与为单个类型设计的手写代码一样快)</li>
<li>与內建类型结合的非常好</li>
</ul>
<h3 id="一个特例"><a href="#一个特例" class="headerlink" title="一个特例"></a>一个特例</h3><ul>
<li>找到整数数组中的第一个等于某个给定值的元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const int* find1(const int* array, int n, int x) &#123;</div><div class="line">    const int* p = array;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        if (*p == x) return p;</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>必须知道的情况: </li>
<li><ul>
<li>正在查找的某个类型为int的值</li>
</ul>
</li>
<li><ul>
<li>正在一个int对象数组中查找</li>
</ul>
</li>
<li><ul>
<li>已经预先知道数组中元素的数目</li>
</ul>
</li>
<li><ul>
<li>知道第一个元素的地址</li>
</ul>
</li>
<li><p>尽可能去除假设条件提高算法通用性(泛型化)</p>
</li>
</ul>
<h3 id="泛型化元素类型"><a href="#泛型化元素类型" class="headerlink" title="泛型化元素类型"></a>泛型化元素类型</h3><ul>
<li>采用模板去除对int的依赖性(前两个要求)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T* find2(T* array, int n, const T&amp; x) &#123;</div><div class="line">    T* p = array;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        if (*p == x) return p;</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>const T&amp; x</code>: </li>
<li><ul>
<li>复制一个类型位置的对象的代价可能很昂贵</li>
</ul>
</li>
<li><ul>
<li>T对象甚至不允许复制(私有的拷贝构造函数)</li>
</ul>
</li>
<li><p>可以用find2处理任何支持operator==的数据结构</p>
</li>
</ul>
<h3 id="推迟计数"><a href="#推迟计数" class="headerlink" title="推迟计数"></a>推迟计数</h3><ul>
<li><p>抽象数据存储方面的信息: 生成一个搜索数组或者链表、文件的函数</p>
</li>
<li><ul>
<li>避免必须预先知道有多少个元素</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>通用性越好的数据结构预先计算元素个数的代价就越昂贵</li>
</ul>
</li>
</ul>
</li>
<li><p>接受指向第一个元素和最后一个元素的两个指针</p>
</li>
<li><ul>
<li>直接引用最后一个元素是很危险的: 根本没有元素存在，指向最后一个元素的指针在指向第一个元素之前</li>
</ul>
</li>
<li><ul>
<li>将指向位于最后一个元素之后的元素的指针作为参数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T* find3(T* array, T* beyond, const T&amp; x) &#123;</div><div class="line">    T* p = array;</div><div class="line">    while (p != beyond) &#123;</div><div class="line">        if (*p == x) return p;</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用!=而不是&lt; : 以后替代指针的类型可能能够很好定义!=而不能定义&lt;</li>
<li>对指针所作假设 : 可以把0转换成一个与其他所有的值不同的指针值(return 0)</li>
<li><ul>
<li>改进: 找不到元素返回一个beyond而不是0</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T* find4(T* array, T* beyond, const T&amp; x) &#123;</div><div class="line">    T* p = array;</div><div class="line">    while (p != beyond) &#123;</div><div class="line">        if (*p == x) return p;</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line">    return beyond;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>简化代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">T* find5(T* array, T* beyond, const T&amp; x) &#123;</div><div class="line">    T* p = array;</div><div class="line">    while (p != beyond &amp;&amp; *p != x)</div><div class="line">        ++p;</div><div class="line">    return beyond;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="地址独立性"><a href="#地址独立性" class="headerlink" title="地址独立性"></a>地址独立性</h3><ul>
<li><p>程序仍依赖传入的指针(指向要查找的数据的开头)</p>
</li>
<li><p>但只依赖于指针的某些保留特性</p>
</li>
<li><ul>
<li>把指针当作参数接受，作为结构返回</li>
</ul>
</li>
<li><ul>
<li>可以比较指针相不相等</li>
</ul>
</li>
<li><ul>
<li>解引用(dereference)指针得到一个值: *p</li>
</ul>
</li>
<li><ul>
<li>递增指针以指向下一个元素</li>
</ul>
</li>
<li><p>传入的指针可以用满足以上特性但非內建指针的类型替换</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class P, class T&gt;</div><div class="line">T* find6(P array, P beyond, const T&amp; x) &#123;</div><div class="line">    while (start != beyond &amp;&amp; *start != x)</div><div class="line">        ++start;</div><div class="line">    return start;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>变得更通用</li>
</ul>
<h3 id="查找非数组"><a href="#查找非数组" class="headerlink" title="查找非数组"></a>查找非数组</h3><ul>
<li>一个包含类String的元素的单向链表(不成熟的实现):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Node &#123;</div><div class="line">    String value;</div><div class="line">    Node* next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>找出包含某个特定值的结点:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Node* listfind(Node* p, const String&amp; x) &#123;</div><div class="line">    while (p &amp;&amp; *p != x)</div><div class="line">        p = p-&gt;next;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义辅助类可以调用用find6</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Nodep &#123;</div><div class="line">public:</div><div class="line">    Nodep(Node* p): pt(p) &#123; &#125;</div><div class="line">    String&amp; operator*() &#123;</div><div class="line">        return pt-&gt;value;</div><div class="line">    &#125;</div><div class="line">    void operator++() &#123;</div><div class="line">        pt = pt-&gt;next;</div><div class="line">    &#125;</div><div class="line">    friend int operator==(const Nodep&amp;, const Nodep&amp;);</div><div class="line">    friend int operator!=(const Nodep&amp;, const Nodep&amp;);</div><div class="line">    operator Node*() &#123;</div><div class="line">        return pt;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    Node* pt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int operator==(const Nodep&amp; p, const Nodep&amp; q) &#123;</div><div class="line">    return p.pt == q.pt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int operator!=(const Nodep&amp; p, const Nodep&amp; q) &#123;</div><div class="line">    return p.pt != q.pt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以直接调用find6: <code>find6(Nodep(p), Nodep(0), x);</code></li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul>
<li>Nodep结构使任何泛型算法都能够运用到正在使用特定链表结构中</li>
<li><ul>
<li>即使泛型算法的设计者从没见过这个链表结构</li>
</ul>
</li>
</ul>
<blockquote>
<p>任何实际的列表类都有一个配套的迭代器类</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/04/Cplusplus_thinking/模板之序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Cplusplus_thinking/模板之序列/" itemprop="url">
                  模板之序列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-04T00:00:00+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>容器类应该包含对象，而迭代器类的对象标识容器中的位置</p>
</blockquote>
<p>Seq类: 精简指令集容器类，模仿纯Lisp中的列表(list)</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/07/04/Cplusplus_thinking/模板之序列/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/07/01/computer_network/computer_network_9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/01/computer_network/computer_network_9/" itemprop="url">
                  网络管理(Network Management)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-01T00:00:00+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Infrastructure-for-network-management"><a href="#Infrastructure-for-network-management" class="headerlink" title="Infrastructure for network management"></a>Infrastructure for network management</h2><blockquote>
<p><img src="\img\network_management_infrastructure.png" alt="network_management_infrastructure.png"></p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/07/01/computer_network/computer_network_9/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/06/30/computer_network/computer_network_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/30/computer_network/computer_network_8/" itemprop="url">
                  网络安全(Security)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-30T00:00:00+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="What-is-network-security"><a href="#What-is-network-security" class="headerlink" title="What is network security"></a>What is network security</h2><ul>
<li><strong>confidentiality(机密性)</strong>: only sender, intended receiver should “understand” message contents</li>
<li><ul>
<li>sender encrypts message</li>
</ul>
</li>
<li><ul>
<li>receiver decrypts message</li>
</ul>
</li>
<li><p><strong>authentication(身份验证)</strong>: sender, receiver want to confirm identity of each other </p>
</li>
<li><p><strong>message integrity(完整性)</strong>: sender, receiver want to ensure message not altered (in transit, or afterwards) without detection</p>
</li>
<li><p><strong>access and availability(可用性)</strong>: services must be accessible and available to users</p>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/30/computer_network/computer_network_8/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/06/29/computer_network/computer_network_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/29/computer_network/computer_network_7/" itemprop="url">
                  多媒体网络(Multimedia Networking)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-29T00:00:00+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="multimedia-networking-applications"><a href="#multimedia-networking-applications" class="headerlink" title="multimedia networking applications"></a>multimedia networking applications</h2><h3 id="Multimedia-audio"><a href="#Multimedia-audio" class="headerlink" title="Multimedia: audio"></a>Multimedia: audio</h3><ul>
<li>analog audio signal sampled at constant rate</li>
<li><ul>
<li>telephone: 8,000 samples/sec</li>
</ul>
</li>
<li><ul>
<li>CD music: 44,100 samples/sec</li>
</ul>
</li>
<li><p>each sample quantized, i.e., rounded</p>
</li>
<li><ul>
<li>e.g., 2^8=256 possible quantized values</li>
</ul>
</li>
<li><ul>
<li>each quantized value represented by bits, e.g., 8 bits for 256 values</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="\img\multimedia_audio.png" alt="multimedia_audio.png"></p>
</blockquote>
<ul>
<li>example: 8,000 samples/sec, 256 quantized values: 64,000 bps</li>
<li><ul>
<li>1 byte per sample, 8 bit * 8000 = 64,000 bps</li>
</ul>
</li>
<li>receiver converts bits back to analog signal:</li>
<li><ul>
<li>some quality reduction</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/29/computer_network/computer_network_7/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://chenfeng.github.io/2017/06/28/computer_network/computer_network_6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenxf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxfeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/28/computer_network/computer_network_6/" itemprop="url">
                  无线网络和移动网络(Wireless and Mobile Networks)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-28T00:00:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ul>
<li><p>number of wireless (mobile) phone subscribers now exceeds number of wired phone subscribers (5-to-1)!</p>
</li>
<li><p>number of wireless Internet-connected devices equals number of wireline Internet-connected devices</p>
</li>
<li><ul>
<li>laptops, Internet-enabled phones promise anytime untethered Internet access</li>
</ul>
</li>
<li><p>two important (but different) challenges</p>
</li>
<li><ul>
<li>wireless: communication over wireless link</li>
</ul>
</li>
<li><ul>
<li>mobility: handling the mobile user who changes point of attachment to network</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/06/28/computer_network/computer_network_6/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="chenxf" />
          <p class="site-author-name" itemprop="name">chenxf</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenxf</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
